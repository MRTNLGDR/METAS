
## Pasta public/

### public/favicon.ico

Um arquivo binário que serve como ícone da aplicação exibido nas abas do navegador.

### public/robots.txt

# Permitir todos os crawlers
User-agent: *
Allow: /

# Sitemap
Sitemap: https://seudominio.com/sitemap.xml

### public/manifest.json

`{   "short_name": "Knowledge System",  "name": "Knowledge Processing System",  "icons": [    {      "src": "favicon.ico",      "sizes": "64x64 32x32 24x24 16x16",      "type": "image/x-icon"    },    {      "src": "assets/images/logo192.png",      "type": "image/png",      "sizes": "192x192"    },    {      "src": "assets/images/logo512.png",      "type": "image/png",      "sizes": "512x512"    }  ],  "start_url": ".",  "display": "standalone",  "theme_color": "#000000",  "background_color": "#ffffff" }`

### public/assets/images/logo192.png e public/assets/images/logo512.png

Imagens do logo da aplicação em diferentes tamanhos.

### public/assets/fonts/

Arquivos de fontes personalizadas utilizadas na aplicação.

## Pasta src/

### src/main.tsx

`import React from "react"; import ReactDOM from "react-dom/client"; import { BrowserRouter } from "react-router-dom"; import { QueryClient, QueryClientProvider } from "@tanstack/react-query"; import App from "./App.tsx"; import "./index.css"; import { Toaster } from "./components/ui/sonner"; import { ThemeProvider } from "./components/theme-provider"; // Criar uma instância do QueryClient const queryClient = new QueryClient({   defaultOptions: {    queries: {      refetchOnWindowFocus: false,      retry: 1    },  }, }); ReactDOM.createRoot(document.getElementById("root")!).render(   <React.StrictMode>    <ThemeProvider defaultTheme="system" storageKey="knowledge-theme">      <QueryClientProvider client={queryClient}>        <BrowserRouter>          <App />          <Toaster position="top-right" />        </BrowserRouter>      </QueryClientProvider>    </ThemeProvider>  </React.StrictMode> );`

### src/App.tsx

`import React from "react"; import { Route, Routes } from "react-router-dom"; import "./App.css"; import { Layout } from "./components/layout/Layout"; import Home from "./pages/Home"; import AgentsPage from "./pages/Agents"; import ConnectionsPage from "./pages/ConnectionsPage"; import LLMManagerPage from "./pages/LLMManagerPage"; import NotFound from "./pages/NotFound"; import MediaProcessorPage from "./pages/MediaProcessorPage"; import DocumentsPage from "./pages/documents"; import MarkdownEditorPage from "./pages/markdown-editor"; import { SidebarProvider } from "./components/ui/sidebar"; import DashboardPage from "./pages/dashboard"; import SettingsPage from "./pages/settings"; import MetricsPage from "./pages/metrics"; function App() {   return (    <SidebarProvider>      <Routes>        <Route path="/" element={<Layout />}>          <Route index element={<Home />} />          <Route path="dashboard" element={<DashboardPage />} />          <Route path="agents" element={<AgentsPage />} />          <Route path="connections" element={<ConnectionsPage />} />          <Route path="llm-manager" element={<LLMManagerPage />} />          <Route path="media" element={<MediaProcessorPage />} />          <Route path="documents" element={<DocumentsPage />} />          <Route path="markdown-editor" element={<MarkdownEditorPage />} />          <Route path="metrics" element={<MetricsPage />} />          <Route path="settings" element={<SettingsPage />} />          <Route path="*" element={<NotFound />} />        </Route>      </Routes>    </SidebarProvider>  ); } export default App;`

### src/index.css

`@tailwind base; @tailwind components; @tailwind utilities; @layer base {   :root {    --background: 0 0% 100%;    --foreground: 240 10% 3.9%;    --card: 0 0% 100%;    --card-foreground: 240 10% 3.9%;    --popover: 0 0% 100%;    --popover-foreground: 240 10% 3.9%;    --primary: 240 5.9% 10%;    --primary-foreground: 0 0% 98%;    --secondary: 240 4.8% 95.9%;    --secondary-foreground: 240 5.9% 10%;    --muted: 240 4.8% 95.9%;    --muted-foreground: 240 3.8% 46.1%;    --accent: 240 4.8% 95.9%;    --accent-foreground: 240 5.9% 10%;    --destructive: 0 84.2% 60.2%;    --destructive-foreground: 0 0% 98%;    --border: 240 5.9% 90%;    --input: 240 5.9% 90%;    --ring: 240 5.9% 10%;    --radius: 0.5rem;  }   .dark {    --background: 240 10% 3.9%;    --foreground: 0 0% 98%;    --card: 240 10% 3.9%;    --card-foreground: 0 0% 98%;    --popover: 240 10% 3.9%;    --popover-foreground: 0 0% 98%;    --primary: 0 0% 98%;    --primary-foreground: 240 5.9% 10%;    --secondary: 240 3.7% 15.9%;    --secondary-foreground: 0 0% 98%;    --muted: 240 3.7% 15.9%;    --muted-foreground: 240 5% 64.9%;    --accent: 240 3.7% 15.9%;    --accent-foreground: 0 0% 98%;    --destructive: 0 62.8% 30.6%;    --destructive-foreground: 0 0% 98%;    --border: 240 3.7% 15.9%;    --input: 240 3.7% 15.9%;    --ring: 240 4.9% 83.9%;  } } @layer base {   * {    @apply border-border;  }  body {    @apply bg-background text-foreground;    font-feature-settings: "rlig" 1, "calt" 1;  } } @layer utilities {   .scrollbar-none {    -ms-overflow-style: none;    scrollbar-width: none;  }     .scrollbar-none::-webkit-scrollbar {    display: none;  }   .glass-morphism {    @apply backdrop-blur-xl bg-white/5 border border-white/10;  }     .text-gradient {    @apply bg-gradient-to-br from-primary via-primary/90 to-primary/70 bg-clip-text text-transparent;  } }`

### src/pages/Home.tsx

`import React from "react"; import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { ArrowRight, FileText, Image, Layers, Zap } from "lucide-react"; import { Link } from "react-router-dom"; export default function Home() {   return (    <div className="container py-8">      <header className="mb-8">        <h1 className="text-4xl font-bold mb-2">Sistema de Processamento de Conhecimento</h1>        <p className="text-lg text-muted-foreground">          Transforme documentos, mídias e ideias em conhecimento estruturado        </p>      </header>       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">        <Card>          <CardHeader className="pb-2">            <FileText className="h-8 w-8 text-primary mb-2" />            <CardTitle>Processamento de Documentos</CardTitle>          </CardHeader>          <CardContent>            <p className="text-muted-foreground mb-4">              Analise e estruture documentos Markdown com processamento avançado            </p>            <Link to="/documents">              <Button className="w-full">                Documentos                <ArrowRight className="ml-2 h-4 w-4" />              </Button>            </Link>          </CardContent>        </Card>         <Card>          <CardHeader className="pb-2">            <Image className="h-8 w-8 text-primary mb-2" />            <CardTitle>Processamento de Mídia</CardTitle>          </CardHeader>          <CardContent>            <p className="text-muted-foreground mb-4">              Extraia conhecimento de imagens, áudio e vídeo com IA            </p>            <Link to="/media">              <Button className="w-full">                Mídia                <ArrowRight className="ml-2 h-4 w-4" />              </Button>            </Link>          </CardContent>        </Card>         <Card>          <CardHeader className="pb-2">            <Layers className="h-8 w-8 text-primary mb-2" />            <CardTitle>Pipelines de LLM</CardTitle>          </CardHeader>          <CardContent>            <p className="text-muted-foreground mb-4">              Configure e execute pipelines com múltiplos modelos de linguagem            </p>            <Link to="/llm-manager">              <Button className="w-full">                Gerenciar LLMs                <ArrowRight className="ml-2 h-4 w-4" />              </Button>            </Link>          </CardContent>        </Card>         <Card>          <CardHeader className="pb-2">            <Zap className="h-8 w-8 text-primary mb-2" />            <CardTitle>Agentes Inteligentes</CardTitle>          </CardHeader>          <CardContent>            <p className="text-muted-foreground mb-4">              Configure agentes para automação de tarefas e assistência            </p>            <Link to="/agents">              <Button className="w-full">                Agentes                <ArrowRight className="ml-2 h-4 w-4" />              </Button>            </Link>          </CardContent>        </Card>      </div>       <div className="mb-8">        <h2 className="text-2xl font-bold mb-4">Comece a usar</h2>        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">          <Card>            <CardContent className="pt-6">              <h3 className="text-lg font-semibold mb-2">1. Configure suas conexões</h3>              <p className="text-muted-foreground mb-4">                Conecte-se aos serviços de IA e armazenamento necessários              </p>              <Link to="/connections">                <Button variant="outline" className="w-full">                  Configurar Conexões                </Button>              </Link>            </CardContent>          </Card>           <Card>            <CardContent className="pt-6">              <h3 className="text-lg font-semibold mb-2">2. Configure seus LLMs</h3>              <p className="text-muted-foreground mb-4">                Defina os modelos de linguagem que serão utilizados              </p>              <Link to="/llm-manager">                <Button variant="outline" className="w-full">                  Gerenciar LLMs                </Button>              </Link>            </CardContent>          </Card>           <Card>            <CardContent className="pt-6">              <h3 className="text-lg font-semibold mb-2">3. Crie seu primeiro pipeline</h3>              <p className="text-muted-foreground mb-4">                Configure um fluxo de processamento para seus documentos              </p>              <Link to="/llm-manager?tab=pipelines">                <Button variant="outline" className="w-full">                  Criar Pipeline                </Button>              </Link>            </CardContent>          </Card>        </div>      </div>    </div>  ); }`

### src/components/layout/Layout.tsx

`import { Outlet } from "react-router-dom"; import { Sidebar } from "../ui/sidebar"; import MainMenu from "./MainMenu"; import { UserMenu } from "./UserMenu"; import { Breadcrumb } from "./Breadcrumb"; import { SearchBar } from "./SearchBar"; import { Logo } from "./Logo"; import { ThemeToggle } from "./ThemeToggle"; import { StatusInfo } from "./StatusInfo"; export function Layout() {   return (    <div className="grid min-h-screen w-full md:grid-cols-[240px_1fr] lg:grid-cols-[280px_1fr]">      <Sidebar className="dark:border-r">        <div className="flex h-full flex-col">          <div className="flex h-14 items-center border-b px-4 lg:h-[60px] lg:px-6">            <Logo />          </div>          <MainMenu />          <div className="mt-auto px-4 py-2 border-t">            <StatusInfo />          </div>        </div>      </Sidebar>      <div className="flex flex-col">        <header className="flex h-14 items-center gap-4 border-b bg-muted/40 px-4 lg:h-[60px] lg:px-6">          <Breadcrumb />          <div className="ml-auto flex items-center gap-4">            <SearchBar />            <ThemeToggle />            <UserMenu />          </div>        </header>        <main className="flex-1 overflow-y-auto">          <Outlet />        </main>      </div>    </div>  ); }`

### src/components/layout/MainMenu.tsx

``import React from "react"; import { NavLink } from "react-router-dom"; import {    Home,  Database,  FileText,  Image,  Layers,  BarChart3,  Settings,  Zap,  Folder } from "lucide-react"; const menuItems = [   { path: "/", label: "Início", icon: <Home className="h-5 w-5" /> },  { path: "/dashboard", label: "Dashboard", icon: <BarChart3 className="h-5 w-5" /> },  { path: "/documents", label: "Documentos", icon: <FileText className="h-5 w-5" /> },  { path: "/markdown-editor", label: "Editor Markdown", icon: <FileText className="h-5 w-5" /> },  { path: "/media", label: "Processador de Mídia", icon: <Image className="h-5 w-5" /> },  { path: "/llm-manager", label: "Gerenciador de LLMs", icon: <Layers className="h-5 w-5" /> },  { path: "/agents", label: "Agentes", icon: <Zap className="h-5 w-5" /> },  { path: "/connections", label: "Conexões", icon: <Database className="h-5 w-5" /> },  { path: "/metrics", label: "Métricas", icon: <BarChart3 className="h-5 w-5" /> },  { path: "/settings", label: "Configurações", icon: <Settings className="h-5 w-5" /> }, ]; export default function MainMenu() {   return (    <nav className="flex-1 overflow-y-auto px-2 py-4">      <ul className="space-y-1">        {menuItems.map((item) => (          <li key={item.path}>            <NavLink              to={item.path}              className={({ isActive }) =>                `flex items-center rounded-md px-3 py-2 transition-colors hover:bg-accent hover:text-accent-foreground ${                  isActive ? "bg-accent text-accent-foreground" : "text-muted-foreground"                }`              }              end={item.path === "/"}            >              {item.icon}              <span className="ml-3">{item.label}</span>            </NavLink>          </li>        ))}      </ul>    </nav>  ); }``

### src/components/llm/pipelines/PipelineStep.tsx

``import React from "react"; import { LLMProvider, PipelineStep as PipelineStepType } from "@/types/llm"; import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "../../ui/select"; import { Label } from "../../ui/label"; import { Textarea } from "../../ui/textarea"; import { Button } from "../../ui/button"; import { Draggable } from "react-beautiful-dnd"; import { MoveVertical, Trash2 } from "lucide-react"; interface PipelineStepProps {   step: PipelineStepType;  index: number;  providers: LLMProvider[];  onUpdateStep: (stepId: string, updates: Partial<PipelineStepType>) => void;  onRemoveStep: (stepId: string) => void; } export function PipelineStep({    step,  index,  providers,  onUpdateStep,  onRemoveStep  }: PipelineStepProps) {   return (    <Draggable key={step.id} draggableId={step.id} index={index}>      {(provided) => (        <div          ref={provided.innerRef}          {...provided.draggableProps}          className="border rounded-md p-4"        >          <div className="flex justify-between items-center mb-2">            <div className="flex space-x-2 items-center">              <div {...provided.dragHandleProps}>                <MoveVertical className="h-5 w-5 text-muted-foreground cursor-move" />              </div>              <h4 className="font-medium">Passo {index + 1}</h4>            </div>            <Button              variant="ghost"              size="icon"              onClick={() => onRemoveStep(step.id)}            >              <Trash2 className="h-4 w-4" />            </Button>          </div>           <div className="space-y-3">            <div className="grid grid-cols-2 gap-2">              <div className="space-y-1">                <Label htmlFor={`provider-${step.id}`}>Provedor</Label>                <Select                  value={step.providerId}                  onValueChange={(value) => onUpdateStep(step.id, { providerId: value })}                >                  <SelectTrigger id={`provider-${step.id}`}>                    <SelectValue placeholder="Selecione um provedor" />                  </SelectTrigger>                  <SelectContent>                    {providers.map((provider) => (                      <SelectItem key={provider.id} value={provider.id}>                        {provider.name}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              </div>                             <div className="space-y-1">                <Label htmlFor={`role-${step.id}`}>Função</Label>                <Select                  value={step.role}                  onValueChange={(value) =>                    onUpdateStep(step.id, {                      role: value as "input" | "processor" | "output"                    })                  }                >                  <SelectTrigger id={`role-${step.id}`}>                    <SelectValue placeholder="Função do passo" />                  </SelectTrigger>                  <SelectContent>                    <SelectItem value="input">Entrada</SelectItem>                    <SelectItem value="processor">Processador</SelectItem>                    <SelectItem value="output">Saída</SelectItem>                  </SelectContent>                </Select>              </div>            </div>             <div className="space-y-1">              <Label htmlFor={`system-prompt-${step.id}`}>Prompt do Sistema</Label>              <Textarea                id={`system-prompt-${step.id}`}                value={step.systemPrompt || ""}                onChange={(e) =>                  onUpdateStep(step.id, { systemPrompt: e.target.value })                }                placeholder="Instruções para o LLM neste passo..."                rows={3}              />            </div>          </div>        </div>      )}    </Draggable>  ); }``

### src/services/media/MediaProcessor.ts

`import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { ImageProcessor } from './ImageProcessor'; import { AudioProcessor } from './AudioProcessor'; import { VideoProcessor } from './VideoProcessor'; /**  * Classe principal para processamento de arquivos de mídia * Orquestra os processadores específicos para cada tipo de mídia */ export class MediaProcessor {   private cacheService: CacheService<MediaProcessingResult>;  private monitoringService: MonitoringService;  private imageProcessor: ImageProcessor;  private audioProcessor: AudioProcessor;  private videoProcessor: VideoProcessor;     constructor() {    this.cacheService = new CacheService<MediaProcessingResult>();    this.monitoringService = new MonitoringService();         // Inicializar processadores específicos    this.imageProcessor = new ImageProcessor(this.cacheService, this.monitoringService);    this.audioProcessor = new AudioProcessor(this.cacheService, this.monitoringService);    this.videoProcessor = new VideoProcessor(this.cacheService, this.monitoringService);  }     /**   * Processa um arquivo de imagem   * @param file Arquivo de imagem   * @returns Resultado do processamento   */  async processImage(file: File): Promise<MediaProcessingResult> {    return this.imageProcessor.process(file);  }     /**   * Processa um arquivo de áudio   * @param file Arquivo de áudio   * @returns Resultado do processamento   */  async processAudio(file: File): Promise<MediaProcessingResult> {    return this.audioProcessor.process(file);  }     /**   * Processa um arquivo de vídeo   * @param file Arquivo de vídeo   * @returns Resultado do processamento   */  async processVideo(file: File): Promise<MediaProcessingResult> {    return this.videoProcessor.process(file);  } }`


### src/components/llm/pipelines/PipelineStepsList.tsx

``import React from "react"; import { useLLM } from "@/hooks/useLLM"; import { LLMPipeline, LLMProvider, PipelineStep } from "@/types/llm"; import { Button } from "../../ui/button"; import { Alert, AlertDescription } from "../../ui/alert"; import { Plus } from "lucide-react"; import { DragDropContext, Droppable } from "react-beautiful-dnd"; import { v4 as uuidv4 } from "uuid"; import { toast } from "sonner"; import { PipelineStep as PipelineStepComponent } from "./PipelineStep"; interface PipelineStepsListProps {   selectedPipeline: LLMPipeline;  setSelectedPipeline: (pipeline: LLMPipeline) => void;  providers: LLMProvider[]; } export function PipelineStepsList({    selectedPipeline,  setSelectedPipeline,  providers  }: PipelineStepsListProps) {   const { updatePipeline } = useLLM();   const handleAddStep = () => {    const newStep: PipelineStep = {      id: `step-${uuidv4()}`,      providerId: providers.length > 0 ? providers[0].id : "",      role: "processor",      order: selectedPipeline.steps.length,      systemPrompt: ""    };     const updatedSteps = [...selectedPipeline.steps, newStep];    const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };         updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo adicionado ao pipeline");  };   const handleUpdateStep = (stepId: string, updates: Partial<PipelineStep>) => {    const updatedSteps = selectedPipeline.steps.map((step) =>      step.id === stepId ? { ...step, ...updates } : step    );     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   const handleRemoveStep = (stepId: string) => {    const updatedSteps = selectedPipeline.steps      .filter((step) => step.id !== stepId)      .map((step, index) => ({ ...step, order: index }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo removido do pipeline");  };   const handleDragEnd = (result) => {    if (!result.destination) return;     const steps = Array.from(selectedPipeline.steps);    const [reorderedItem] = steps.splice(result.source.index, 1);    steps.splice(result.destination.index, 0, reorderedItem);     const updatedSteps = steps.map((step, index) => ({      ...step,      order: index    }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   return (    <div className="space-y-4">      <div className="flex justify-between items-center">        <h3 className="text-lg font-medium">Passos do Pipeline</h3>        <Button onClick={handleAddStep}>          <Plus className="mr-2 h-4 w-4" /> Adicionar Passo        </Button>      </div>       {selectedPipeline.steps.length === 0 ? (        <Alert>          <AlertDescription>            Este pipeline não possui passos. Adicione passos para definir o fluxo de processamento.          </AlertDescription>        </Alert>      ) : (        <DragDropContext onDragEnd={handleDragEnd}>          <Droppable droppableId="pipeline-steps">            {(provided) => (              <div                {...provided.droppableProps}                ref={provided.innerRef}                className="space-y-4"              >                {selectedPipeline.steps                  .sort((a, b) => a.order - b.order)                  .map((step, index) => (                    <PipelineStepComponent                      key={step.id}                      step={step}                      index={index}                      providers={providers}                      onUpdateStep={handleUpdateStep}                      onRemoveStep={handleRemoveStep}                    />                  ))}                {provided.placeholder}              </div>            )}          </Droppable>        </DragDropContext>      )}    </div>  ); }``

### src/components/llm/pipelines/PipelineTester.tsx

`import React, { useState } from "react"; import { useLLM } from "@/hooks/useLLM"; import { LLMPipeline } from "@/types/llm"; import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"; import { Textarea } from "@/components/ui/textarea"; import { Button } from "@/components/ui/button"; import { Loader2 } from "lucide-react"; import { toast } from "sonner"; interface PipelineTesterProps {   pipeline: LLMPipeline; } export function PipelineTester({ pipeline }: PipelineTesterProps) {   const [input, setInput] = useState("");  const [output, setOutput] = useState("");  const { processThroughPipeline, isPipelineProcessing } = useLLM();   const handleProcess = async () => {    if (!input.trim()) {      toast.error("Por favor, insira um texto para processar");      return;    }     if (pipeline.steps.length === 0) {      toast.error("Este pipeline não possui passos definidos");      return;    }     try {      const result = await processThroughPipeline(pipeline.id, input);      setOutput(result);      toast.success("Processamento concluído com sucesso");    } catch (error) {      toast.error("Erro no processamento", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   return (    <Card>      <CardHeader>        <CardTitle>Testar Pipeline</CardTitle>      </CardHeader>      <CardContent className="space-y-4">        <div className="space-y-2">          <h4 className="text-sm font-medium">Entrada</h4>          <Textarea            placeholder="Digite o texto de entrada para o pipeline..."            value={input}            onChange={(e) => setInput(e.target.value)}            rows={5}          />        </div>         <Button          onClick={handleProcess}          disabled={isPipelineProcessing || !input.trim()}          className="w-full"        >          {isPipelineProcessing ? (            <>              <Loader2 className="mr-2 h-4 w-4 animate-spin" />              Processando...            </>          ) : (            "Processar"          )}        </Button>         <div className="space-y-2">          <h4 className="text-sm font-medium">Saída</h4>          <div className="rounded-md border border-border p-4 min-h-[120px] bg-muted/30">            {output ? (              <pre className="whitespace-pre-wrap break-words text-sm">                {output}              </pre>            ) : (              <p className="text-muted-foreground text-center my-8">                A saída do processamento aparecerá aqui              </p>            )}          </div>        </div>      </CardContent>    </Card>  ); }`

### src/components/llm/pipelines/PipelinesList.tsx

``import React from "react"; import { LLMPipeline } from "@/types/llm"; import { useLLM } from "@/hooks/useLLM"; import {   Card,  CardContent,  CardDescription,  CardHeader,  CardTitle } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import {   Check,  Clock,  Plus,  Trash2,  MoreVertical } from "lucide-react"; import {   DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuTrigger } from "@/components/ui/dropdown-menu"; import { toast } from "sonner"; import {   Dialog,  DialogContent,  DialogDescription,  DialogFooter,  DialogHeader,  DialogTitle } from "@/components/ui/dialog"; import { Input } from "@/components/ui/input"; import { Textarea } from "@/components/ui/textarea"; import { format } from "date-fns"; import { v4 as uuidv4 } from "uuid"; interface PipelinesListProps {   pipelines: LLMPipeline[];  selectedPipelineId: string | null;  onSelectPipeline: (pipelineId: string) => void;  onPipelinesChange: () => void; } export function PipelinesList({   pipelines,  selectedPipelineId,  onSelectPipeline,  onPipelinesChange }: PipelinesListProps) {   const { createPipeline, deletePipeline } = useLLM();  const [isCreateDialogOpen, setIsCreateDialogOpen] = React.useState(false);  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = React.useState(false);  const [pipelineToDelete, setPipelineToDelete] = React.useState<string | null>(null);  const [newPipelineName, setNewPipelineName] = React.useState("");  const [newPipelineDescription, setNewPipelineDescription] = React.useState("");   const handleCreatePipeline = () => {    if (!newPipelineName.trim()) {      toast.error("O nome do pipeline é obrigatório");      return;    }     try {      const pipelineId = uuidv4();      createPipeline({        id: pipelineId,        name: newPipelineName,        description: newPipelineDescription,        steps: []      });             setNewPipelineName("");      setNewPipelineDescription("");      setIsCreateDialogOpen(false);      toast.success("Pipeline criado com sucesso");      onPipelinesChange();      onSelectPipeline(pipelineId);    } catch (error) {      toast.error("Erro ao criar pipeline", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   const handleDeleteClick = (pipelineId: string) => {    setPipelineToDelete(pipelineId);    setIsDeleteDialogOpen(true);  };   const handleDeleteConfirm = () => {    if (!pipelineToDelete) return;     try {      deletePipeline(pipelineToDelete);      setIsDeleteDialogOpen(false);      setPipelineToDelete(null);      toast.success("Pipeline excluído com sucesso");      onPipelinesChange();             // Se o pipeline excluído era o selecionado, limpe a seleção      if (selectedPipelineId === pipelineToDelete) {        onSelectPipeline("");      }    } catch (error) {      toast.error("Erro ao excluir pipeline", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   return (    <>      <div className="flex justify-between items-center mb-4">        <h2 className="text-xl font-semibold">Pipelines</h2>        <Button onClick={() => setIsCreateDialogOpen(true)}>          <Plus className="mr-2 h-4 w-4" /> Novo Pipeline        </Button>      </div>       <div className="space-y-4">        {pipelines.length === 0 ? (          <Card>            <CardContent className="py-8 text-center">              <p className="text-muted-foreground">                Nenhum pipeline encontrado. Crie um novo pipeline para começar.              </p>              <Button                variant="outline"                className="mt-4"                onClick={() => setIsCreateDialogOpen(true)}              >                <Plus className="mr-2 h-4 w-4" /> Criar Pipeline              </Button>            </CardContent>          </Card>        ) : (          pipelines.map((pipeline) => (            <Card              key={pipeline.id}              className={`cursor-pointer transition-colors ${                selectedPipelineId === pipeline.id                  ? "border-primary"                  : "hover:border-primary/50"              }`}              onClick={() => onSelectPipeline(pipeline.id)}            >              <CardHeader className="flex flex-row items-start justify-between p-4">                <div>                  <CardTitle className="text-base">{pipeline.name}</CardTitle>                  {pipeline.description && (                    <CardDescription>{pipeline.description}</CardDescription>                  )}                </div>                <DropdownMenu>                  <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>                    <Button variant="ghost" size="icon">                      <MoreVertical className="h-4 w-4" />                    </Button>                  </DropdownMenuTrigger>                  <DropdownMenuContent align="end">                    <DropdownMenuItem                      className="text-destructive"                      onClick={(e) => {                        e.stopPropagation();                        handleDeleteClick(pipeline.id);                      }}                    >                      <Trash2 className="mr-2 h-4 w-4" />                      Excluir Pipeline                    </DropdownMenuItem>                  </DropdownMenuContent>                </DropdownMenu>              </CardHeader>              <CardContent className="p-4 pt-0">                <div className="flex items-center text-xs text-muted-foreground">                  <div className="flex items-center mr-4">                    <Check className="mr-1 h-3 w-3" />                    <span>{pipeline.steps.length} passos</span>                  </div>                  {pipeline.updatedAt && (                    <div className="flex items-center">                      <Clock className="mr-1 h-3 w-3" />                      <span>                        Atualizado em{" "}                        {format(new Date(pipeline.updatedAt), "dd/MM/yyyy")}                      </span>                    </div>                  )}                </div>              </CardContent>            </Card>          ))        )}      </div>       <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Criar Novo Pipeline</DialogTitle>            <DialogDescription>              Defina as informações básicas do pipeline. Você poderá adicionar passos depois.            </DialogDescription>          </DialogHeader>          <div className="space-y-4 py-2">            <div className="space-y-2">              <label htmlFor="pipeline-name" className="text-sm font-medium">                Nome              </label>              <Input                id="pipeline-name"                placeholder="Nome do pipeline"                value={newPipelineName}                onChange={(e) => setNewPipelineName(e.target.value)}              />            </div>            <div className="space-y-2">              <label htmlFor="pipeline-description" className="text-sm font-medium">                Descrição (opcional)              </label>              <Textarea                id="pipeline-description"                placeholder="Descrição do pipeline"                value={newPipelineDescription}                onChange={(e) => setNewPipelineDescription(e.target.value)}              />            </div>          </div>          <DialogFooter>            <Button variant="outline" onClick={() => setIsCreateDialogOpen(false)}>              Cancelar            </Button>            <Button onClick={handleCreatePipeline}>Criar Pipeline</Button>          </DialogFooter>        </DialogContent>      </Dialog>       <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Excluir Pipeline</DialogTitle>            <DialogDescription>              Tem certeza que deseja excluir este pipeline? Esta ação não pode ser desfeita.            </DialogDescription>          </DialogHeader>          <DialogFooter>            <Button variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>              Cancelar            </Button>            <Button variant="destructive" onClick={handleDeleteConfirm}>              Excluir            </Button>          </DialogFooter>        </DialogContent>      </Dialog>    </>  ); }``

### src/hooks/llm/usePipelines.ts

``import { useCallback, useState } from 'react'; import { LLMPipeline, PipelineStep } from '../../types/llm'; import { llmServiceInstance } from './llmServiceInstance'; import { v4 as uuidv4 } from 'uuid'; export const usePipelines = () => {   const [isProcessing, setIsProcessing] = useState(false);  const [processingError, setProcessingError] = useState<string | null>(null);   const createPipeline = useCallback((    name: string,    description: string,    steps: Omit<PipelineStep, 'id'>[]  ): string => {    const pipelineId = uuidv4();         // Criar IDs para cada passo    const stepsWithIds: PipelineStep[] = steps.map(step => ({      ...step,      id: uuidv4()    }));         return llmServiceInstance.createPipeline({      id: pipelineId,      name,      description,      steps: stepsWithIds    });  }, []);   const updatePipeline = useCallback((    pipelineId: string,    updates: Partial<Omit<LLMPipeline, 'id' | 'createdAt' | 'updatedAt'>>  ): void => {    llmServiceInstance.updatePipeline(pipelineId, updates);  }, []);   const deletePipeline = useCallback((pipelineId: string): void => {    llmServiceInstance.deletePipeline(pipelineId);  }, []);   const getPipeline = useCallback((pipelineId: string): LLMPipeline | undefined => {    return llmServiceInstance.getPipeline(pipelineId);  }, []);   const listPipelines = useCallback((): LLMPipeline[] => {    return llmServiceInstance.listPipelines();  }, []);   const processThroughPipeline = useCallback(async (    pipelineId: string,    input: string  ): Promise<string> => {    setIsProcessing(true);    setProcessingError(null);         try {      const result = await llmServiceInstance.processThroughPipeline(pipelineId, input);      return result;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setProcessingError(errorMessage);      throw error;    } finally {      setIsProcessing(false);    }  }, []);   const addStepToPipeline = useCallback((    pipelineId: string,    step: Omit<PipelineStep, 'id'>  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const newStep: PipelineStep = {      ...step,      id: uuidv4()    };         const updatedSteps = [...pipeline.steps, newStep];    llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   const removeStepFromPipeline = useCallback((    pipelineId: string,    stepId: string  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const updatedSteps = pipeline.steps.filter(step => step.id !== stepId);    llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   const updateStepInPipeline = useCallback((    pipelineId: string,    stepId: string,    updates: Partial<Omit<PipelineStep, 'id'>>  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const updatedSteps = pipeline.steps.map(step =>      step.id === stepId ? { ...step, ...updates } : step    );         llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   return {    createPipeline,    updatePipeline,    deletePipeline,    getPipeline,    listPipelines,    processThroughPipeline,    addStepToPipeline,    removeStepFromPipeline,    updateStepInPipeline,    isProcessing,    processingError  }; };``

### src/pages/LLMManagerPage.tsx

`import React, { useState, useEffect } from "react"; import { useLLM } from "@/hooks/useLLM"; import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; import { LLMConfig } from "@/components/llm/LLMConfig"; import { LLMMonitoring } from "@/components/llm/LLMMonitoring"; import { LLMPipelinesManager } from "@/components/llm/LLMPipelinesManager"; import { useSearchParams } from "react-router-dom"; import { LLMProvider } from "@/types/llm"; export default function LLMManagerPage() {   const { listProviders } = useLLM();  const [providers, setProviders] = useState<LLMProvider[]>([]);  const [searchParams, setSearchParams] = useSearchParams();  const activeTab = searchParams.get("tab") || "config";   useEffect(() => {    // Carregar provedores ao montar o componente    setProviders(listProviders());  }, [listProviders]);   const handleTabChange = (value: string) => {    setSearchParams({ tab: value });  };   const handleProvidersChange = () => {    // Atualizar a lista de provedores quando mudanças ocorrerem    setProviders(listProviders());  };   return (    <div className="container py-8">      <header className="mb-8">        <h1 className="text-3xl font-bold">Gerenciador de LLMs</h1>        <p className="text-muted-foreground">          Configure provedores de LLM, monitore o uso e gerencie pipelines de processamento.        </p>      </header>       <Tabs value={activeTab} onValueChange={handleTabChange} className="space-y-4">        <TabsList>          <TabsTrigger value="config">Configuração</TabsTrigger>          <TabsTrigger value="monitoring">Monitoramento</TabsTrigger>          <TabsTrigger value="pipelines">Pipelines</TabsTrigger>        </TabsList>         <TabsContent value="config">          <LLMConfig providers={providers} onProvidersChange={handleProvidersChange} />        </TabsContent>         <TabsContent value="monitoring">          <LLMMonitoring providers={providers} />        </TabsContent>         <TabsContent value="pipelines">          <LLMPipelinesManager providers={providers} />        </TabsContent>      </Tabs>    </div>  ); }`

### src/components/document/DocumentInputCard.tsx

`import React, { useState } from "react"; import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { Textarea } from "@/components/ui/textarea"; import { Input } from "@/components/ui/input"; import { FileText, Upload } from "lucide-react"; interface DocumentInputCardProps {   onProcess: (document: { title: string; content: string }) => void;  isProcessing: boolean; } export function DocumentInputCard({ onProcess, isProcessing }: DocumentInputCardProps) {   const [title, setTitle] = useState("");  const [content, setContent] = useState("");  const [file, setFile] = useState<File | null>(null);   const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {    const selectedFile = e.target.files?.[0];    if (!selectedFile) return;     setFile(selectedFile);         if (selectedFile.name && !title) {      // Usar o nome do arquivo como título, removendo a extensão      const fileNameWithoutExtension = selectedFile.name.replace(/\.[^/.]+$/, "");      setTitle(fileNameWithoutExtension);    }     // Ler o conteúdo do arquivo se for um arquivo de texto    if (selectedFile.type.includes("text") || selectedFile.type.includes("markdown")) {      const reader = new FileReader();      reader.onload = (e) => {        const fileContent = e.target?.result as string;        setContent(fileContent);      };      reader.readAsText(selectedFile);    }  };   const handleSubmit = (e: React.FormEvent) => {    e.preventDefault();         if (!title.trim()) {      alert("Por favor, insira um título para o documento");      return;    }     if (!content.trim()) {      alert("Por favor, insira ou carregue conteúdo para o documento");      return;    }     onProcess({ title, content });  };   return (    <Card>      <CardHeader>        <CardTitle className="flex items-center">          <FileText className="mr-2 h-5 w-5" />          Documento de Entrada        </CardTitle>      </CardHeader>      <form onSubmit={handleSubmit}>        <CardContent className="space-y-4">          <div className="space-y-2">            <label htmlFor="title" className="text-sm font-medium">              Título            </label>            <Input              id="title"              placeholder="Título do documento"              value={title}              onChange={(e) => setTitle(e.target.value)}            />          </div>           <div className="space-y-2">            <label htmlFor="content" className="text-sm font-medium">              Conteúdo            </label>            <Textarea              id="content"              placeholder="Conteúdo do documento (Markdown suportado)"              value={content}              onChange={(e) => setContent(e.target.value)}              rows={12}              className="font-mono"            />          </div>           <div className="flex items-center justify-center border-2 border-dashed border-muted-foreground/25 rounded-md p-4">            <label htmlFor="file-upload" className="cursor-pointer flex flex-col items-center">              <Upload className="h-6 w-6 text-muted-foreground mb-2" />              <span className="text-sm text-muted-foreground mb-1">                Clique para carregar um arquivo              </span>              <span className="text-xs text-muted-foreground">                {file ? file.name : "Arquivos .md, .txt suportados"}              </span>              <input                id="file-upload"                type="file"                className="hidden"                accept=".md,.txt,.markdown,.text"                onChange={handleFileChange}              />            </label>          </div>        </CardContent>         <CardFooter>          <Button            type="submit"            className="w-full"            disabled={isProcessing || !title.trim() || !content.trim()}          >            {isProcessing ? "Processando..." : "Processar Documento"}          </Button>        </CardFooter>      </form>    </Card>  ); }`

### src/components/document/DocumentProcessorPanel.tsx

`import React, { useState } from "react"; import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; import { AnalysisTab } from "./AnalysisTab"; import { StructureTab } from "./StructureTab"; import { ValidationTab } from "./ValidationTab"; import { SuggestionsTab } from "./SuggestionsTab"; import { ProcessingProgress } from "./ProcessingProgress"; import { EmptyProcessorState } from "./EmptyProcessorState"; import { ProcessedDocument } from "@/types/document"; interface DocumentProcessorPanelProps {   document: ProcessedDocument | null;  isProcessing: boolean;  progress: number; // 0-100 } export function DocumentProcessorPanel({   document,  isProcessing,  progress }: DocumentProcessorPanelProps) {   const [activeTab, setActiveTab] = useState("analysis");   if (isProcessing) {    return <ProcessingProgress progress={progress} />;  }   if (!document) {    return <EmptyProcessorState />;  }   return (    <div className="space-y-4">      <div>        <h2 className="text-2xl font-bold">{document.title}</h2>        {document.summary && (          <p className="text-muted-foreground mt-1">{document.summary}</p>        )}      </div>       <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">        <TabsList>          <TabsTrigger value="analysis">Análise</TabsTrigger>          <TabsTrigger value="structure">Estrutura</TabsTrigger>          <TabsTrigger value="validation">Validação</TabsTrigger>          <TabsTrigger value="suggestions">Sugestões</TabsTrigger>        </TabsList>         <TabsContent value="analysis">          <AnalysisTab document={document} />        </TabsContent>         <TabsContent value="structure">          <StructureTab document={document} />        </TabsContent>         <TabsContent value="validation">          <ValidationTab document={document} />        </TabsContent>         <TabsContent value="suggestions">          <SuggestionsTab document={document} />        </TabsContent>      </Tabs>    </div>  ); }`

### src/types/llm.ts

`export interface LLMProvider {   id: string;  name: string;  type: string;  apiKey?: string;  endpoint?: string;  models: string[];  capabilities: {    textCompletion: boolean;    chatCompletion: boolean;    embedding: boolean;    imageGeneration: boolean;    audioTranscription: boolean;  };  parameters?: {    defaultTemperature: number;    defaultMaxTokens: number;    defaultTopP: number;  };  usage?: {    requestCount: number;    tokensUsed: number;    lastUsed: string;  }; } export interface LLMConfig {   defaultProvider: string;  providers: Record<string, LLMProvider>;  settings: {    maxConcurrentRequests: number;    retryAttempts: number;    timeout: number;  }; } export interface ChatMessage {   role: 'system' | 'user' | 'assistant';  content: string; } export interface LLMResponse {   message: ChatMessage;  usage: {    promptTokens: number;    completionTokens: number;    totalTokens: number;  };  model: string;  provider: string; } export interface CompletionOptions {   model?: string;  temperature?: number;  maxTokens?: number;  topP?: number;  frequencyPenalty?: number;  presencePenalty?: number; } export interface ChatResponse {   message: string;  usage: {    promptTokens: number;    completionTokens: number;    totalTokens: number;  }; } export interface LLMStats {   requestCount: number;  successRate: number;  averageLatency: number;  costPerRequest: number;  tokensUsed: {    prompt: number;    completion: number;    total: number;  };  requestsPerDay: Record<string, number>; } export interface LLMUsageMetrics {   providerId: string;  period: 'day' | 'week' | 'month' | 'all';  requestCount: number;  tokensUsed: number;  cost: number;  successRate: number;  averageLatency: number;  requestsTimeline: {    timestamp: string;    count: number;  }[]; } export interface PipelineStep {   id: string;  providerId: string;  role: "input" | "processor" | "output";  order: number;  systemPrompt?: string;  model?: string;  options?: CompletionOptions; } export interface LLMPipeline {   id: string;  name: string;  description?: string;  steps: PipelineStep[];  createdAt: string;  updatedAt: string; } export interface LLMServiceConfig {   defaultProvider: string;  providers: Record<string, LLMProvider>;  settings: {    maxConcurrentRequests: number;    retryAttempts: number;    timeout: number;  }; }`



### src/services/llm/LLMService.ts

``import { ChatMessage, LLMConfig, LLMProvider, LLMResponse } from '@/types/llm'; import { MonitoringService } from '../monitoring/MonitoringService'; export class LLMService {   private providers: Map<string, LLMProvider>;  private monitoring: MonitoringService;   constructor(config: LLMConfig) {    this.providers = new Map();    this.monitoring = new MonitoringService();    this.initializeProviders(config);  }   private initializeProviders(config: LLMConfig) {    const { providers = {} } = config;    Object.entries(providers).forEach(([id, provider]) => {      this.providers.set(id, {        id,        ...provider      });    });  }   async generateChat(    messages: ChatMessage[],    options: {      model: string;      temperature?: number;      maxTokens?: number;      provider?: string;    }  ): Promise<LLMResponse> {    const startTime = Date.now();         try {      const provider = this.getProvider(options.provider);             // Registrar início da requisição      this.monitoring.logRequest({        providerId: provider.id,        model: options.model,        inputTokens: this.countTokens(messages)      });       // Fazer a chamada à API do provedor      const response = await this.makeProviderRequest(provider, messages, options);             const endTime = Date.now();      const processingTime = endTime - startTime;       // Registrar sucesso      this.monitoring.logSuccess({        providerId: provider.id,        model: options.model,        processingTime,        outputTokens: this.countTokens([response.message])      });       return response;    } catch (error) {      // Registrar erro      this.monitoring.logError({        providerId: options.provider || 'default',        model: options.model,        error: error instanceof Error ? error.message : 'Unknown error'      });       throw error;    }  }   private getProvider(providerId?: string): LLMProvider {    if (providerId && this.providers.has(providerId)) {      return this.providers.get(providerId)!;    }         // Retornar provedor padrão ou lançar erro se não houver nenhum    const defaultProvider = this.providers.values().next().value;    if (!defaultProvider) {      throw new Error('No LLM providers configured');    }         return defaultProvider;  }   private async makeProviderRequest(    provider: LLMProvider,    messages: ChatMessage[],    options: {      model: string;      temperature?: number;      maxTokens?: number;    }  ): Promise<LLMResponse> {    const { model, temperature = 0.7, maxTokens } = options;     const response = await fetch(`${provider.endpoint}/v1/chat/completions`, {      method: 'POST',      headers: {        'Content-Type': 'application/json',        'Authorization': `Bearer ${provider.apiKey}`      },      body: JSON.stringify({        model,        messages,        temperature,        max_tokens: maxTokens,        n: 1,        stream: false      })    });     if (!response.ok) {      const error = await response.json();      throw new Error(error.error?.message || 'LLM request failed');    }     const data = await response.json();     return {      message: data.choices[0].message,      usage: data.usage,      model: data.model,      provider: provider.id    };  }   private countTokens(messages: ChatMessage[]): number {    // Implementação simplificada de contagem de tokens    // Em produção, usar uma biblioteca específica como tiktoken    return messages.reduce((total, msg) => {      return total + (msg.content.length / 4); // Aproximadamente 4 caracteres por token    }, 0);  }   // Métodos para gerenciamento de provedores  addProvider(provider: LLMProvider): void {    this.providers.set(provider.id, provider);  }   removeProvider(providerId: string): void {    this.providers.delete(providerId);  }   updateProvider(providerId: string, updates: Partial<LLMProvider>): void {    const provider = this.providers.get(providerId);    if (provider) {      this.providers.set(providerId, { ...provider, ...updates });    }  }   getProviders(): LLMProvider[] {    return Array.from(this.providers.values());  } }``

### src/services/monitoring/MonitoringService.ts

`interface MonitoringMetrics {   requestCount: number;  successCount: number;  errorCount: number;  totalProcessingTime: number;  totalTokensUsed: number; } interface RequestLog {   providerId: string;  model: string;  inputTokens: number;  timestamp: string; } interface SuccessLog extends RequestLog {   processingTime: number;  outputTokens: number; } interface ErrorLog extends RequestLog {   error: string; } export class MonitoringService {   private metrics: Map<string, MonitoringMetrics>;  private logs: Array<RequestLog | SuccessLog | ErrorLog>;  private maxLogs: number;   constructor(maxLogs: number = 1000) {    this.metrics = new Map();    this.logs = [];    this.maxLogs = maxLogs;  }   logRequest(data: Omit<RequestLog, 'timestamp'>): void {    const log: RequestLog = {      ...data,      timestamp: new Date().toISOString()    };     this.logs.push(log);    this.trimLogs();     // Atualizar métricas    const metrics = this.getMetrics(data.providerId);    metrics.requestCount++;    this.metrics.set(data.providerId, metrics);  }   logSuccess(data: Omit<SuccessLog, 'timestamp'>): void {    const log: SuccessLog = {      ...data,      timestamp: new Date().toISOString()    };     this.logs.push(log);    this.trimLogs();     // Atualizar métricas    const metrics = this.getMetrics(data.providerId);    metrics.successCount++;    metrics.totalProcessingTime += data.processingTime;    metrics.totalTokensUsed += data.inputTokens + data.outputTokens;    this.metrics.set(data.providerId, metrics);  }   logError(data: Omit<ErrorLog, 'timestamp'>): void {    const log: ErrorLog = {      ...data,      timestamp: new Date().toISOString()    };     this.logs.push(log);    this.trimLogs();     // Atualizar métricas    const metrics = this.getMetrics(data.providerId);    metrics.errorCount++;    this.metrics.set(data.providerId, metrics);  }   private getMetrics(providerId: string): MonitoringMetrics {    return this.metrics.get(providerId) || {      requestCount: 0,      successCount: 0,      errorCount: 0,      totalProcessingTime: 0,      totalTokensUsed: 0    };  }   private trimLogs(): void {    if (this.logs.length > this.maxLogs) {      this.logs = this.logs.slice(-this.maxLogs);    }  }   getProviderMetrics(providerId: string): MonitoringMetrics {    return this.getMetrics(providerId);  }   getAllMetrics(): Map<string, MonitoringMetrics> {    return new Map(this.metrics);  }   getLogs(options?: {    providerId?: string;    startTime?: string;    endTime?: string;    type?: 'request' | 'success' | 'error';  }): Array<RequestLog | SuccessLog | ErrorLog> {    let filteredLogs = this.logs;     if (options?.providerId) {      filteredLogs = filteredLogs.filter(log => log.providerId === options.providerId);    }     if (options?.startTime) {      filteredLogs = filteredLogs.filter(log => log.timestamp >= options.startTime!);    }     if (options?.endTime) {      filteredLogs = filteredLogs.filter(log => log.timestamp <= options.endTime!);    }     if (options?.type) {      filteredLogs = filteredLogs.filter(log => {        switch (options.type) {          case 'request':            return !('processingTime' in log) && !('error' in log);          case 'success':            return 'processingTime' in log;          case 'error':            return 'error' in log;        }      });    }     return filteredLogs;  }   clearMetrics(providerId?: string): void {    if (providerId) {      this.metrics.delete(providerId);    } else {      this.metrics.clear();    }  }   clearLogs(): void {    this.logs = [];  } }`

### src/components/llm/monitoring/MetricsCards.tsx

`import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { Brain, Clock, Target, AlertTriangle } from 'lucide-react'; interface MetricsCardsProps {   metrics: {    requestCount: number;    successCount: number;    errorCount: number;    totalProcessingTime: number;    totalTokensUsed: number;  }; } export function MetricsCards({ metrics }: MetricsCardsProps) {   const avgProcessingTime = metrics.successCount > 0    ? metrics.totalProcessingTime / metrics.successCount    : 0;   const successRate = metrics.requestCount > 0    ? (metrics.successCount / metrics.requestCount) * 100    : 0;   return (    <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-4">      <Card>        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">          <CardTitle className="text-sm font-medium">Total de Requisições</CardTitle>          <Brain className="h-4 w-4 text-muted-foreground" />        </CardHeader>        <CardContent>          <div className="text-2xl font-bold">{metrics.requestCount}</div>          <p className="text-xs text-muted-foreground">            {metrics.totalTokensUsed.toLocaleString()} tokens utilizados          </p>        </CardContent>      </Card>       <Card>        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">          <CardTitle className="text-sm font-medium">Taxa de Sucesso</CardTitle>          <Target className="h-4 w-4 text-muted-foreground" />        </CardHeader>        <CardContent>          <div className="text-2xl font-bold">{successRate.toFixed(1)}%</div>          <p className="text-xs text-muted-foreground">            {metrics.successCount} sucessos em {metrics.requestCount} requisições          </p>        </CardContent>      </Card>       <Card>        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">          <CardTitle className="text-sm font-medium">Tempo Médio</CardTitle>          <Clock className="h-4 w-4 text-muted-foreground" />        </CardHeader>        <CardContent>          <div className="text-2xl font-bold">{avgProcessingTime.toFixed(2)}ms</div>          <p className="text-xs text-muted-foreground">            Tempo total: {metrics.totalProcessingTime.toFixed(2)}ms          </p>        </CardContent>      </Card>       <Card>        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">          <CardTitle className="text-sm font-medium">Erros</CardTitle>          <AlertTriangle className="h-4 w-4 text-muted-foreground" />        </CardHeader>        <CardContent>          <div className="text-2xl font-bold">{metrics.errorCount}</div>          <p className="text-xs text-muted-foreground">            {((metrics.errorCount / metrics.requestCount) * 100).toFixed(1)}% de erro          </p>        </CardContent>      </Card>    </div>  ); }`

### src/components/llm/monitoring/PerformanceChart.tsx

``import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { Line, LineChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts'; interface PerformanceData {   timestamp: string;  processingTime: number;  tokensUsed: number; } interface PerformanceChartProps {   data: PerformanceData[]; } export function PerformanceChart({ data }: PerformanceChartProps) {   return (    <Card className="col-span-4">      <CardHeader>        <CardTitle>Desempenho ao Longo do Tempo</CardTitle>      </CardHeader>      <CardContent>        <div className="h-[300px]">          <ResponsiveContainer width="100%" height="100%">            <LineChart data={data}>              <XAxis                dataKey="timestamp"                tickFormatter={(value) => new Date(value).toLocaleTimeString()}                stroke="#888888"                fontSize={12}              />              <YAxis                yAxisId="time"                orientation="left"                stroke="#888888"                fontSize={12}                tickFormatter={(value) => `${value}ms`}              />              <YAxis                yAxisId="tokens"                orientation="right"                stroke="#888888"                fontSize={12}                tickFormatter={(value) => `${value}`}              />              <Tooltip                contentStyle={{ background: 'hsl(var(--background))', borderRadius: '8px', border: '1px solid hsl(var(--border))' }}                labelStyle={{ color: 'hsl(var(--foreground))' }}              />              <Line                type="monotone"                dataKey="processingTime"                stroke="hsl(var(--primary))"                yAxisId="time"                strokeWidth={2}                dot={false}              />              <Line                type="monotone"                dataKey="tokensUsed"                stroke="hsl(var(--secondary))"                yAxisId="tokens"                strokeWidth={2}                dot={false}              />            </LineChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }``

### src/components/llm/pipelines/PipelineStepsList.tsx

``import React from "react"; import { useLLM } from "@/hooks/useLLM"; import { LLMPipeline, LLMProvider, PipelineStep } from "@/types/llm"; import { Button } from "../../ui/button"; import { Alert, AlertDescription } from "../../ui/alert"; import { Plus } from "lucide-react"; import { DragDropContext, Droppable } from "react-beautiful-dnd"; import { v4 as uuidv4 } from "uuid"; import { toast } from "sonner"; import { PipelineStep as PipelineStepComponent } from "./PipelineStep"; interface PipelineStepsListProps {   selectedPipeline: LLMPipeline;  setSelectedPipeline: (pipeline: LLMPipeline) => void;  providers: LLMProvider[]; } export function PipelineStepsList({    selectedPipeline,  setSelectedPipeline,  providers  }: PipelineStepsListProps) {   const { updatePipeline } = useLLM();   const handleAddStep = () => {    const newStep: PipelineStep = {      id: `step-${uuidv4()}`,      providerId: providers.length > 0 ? providers[0].id : "",      role: "processor",      order: selectedPipeline.steps.length,      systemPrompt: ""    };     const updatedSteps = [...selectedPipeline.steps, newStep];    const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };         updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo adicionado ao pipeline");  };   const handleUpdateStep = (stepId: string, updates: Partial<PipelineStep>) => {    const updatedSteps = selectedPipeline.steps.map((step) =>      step.id === stepId ? { ...step, ...updates } : step    );     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   const handleRemoveStep = (stepId: string) => {    const updatedSteps = selectedPipeline.steps      .filter((step) => step.id !== stepId)      .map((step, index) => ({ ...step, order: index }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo removido do pipeline");  };   const handleDragEnd = (result) => {    if (!result.destination) return;     const steps = Array.from(selectedPipeline.steps);    const [reorderedItem] = steps.splice(result.source.index, 1);    steps.splice(result.destination.index, 0, reorderedItem);     const updatedSteps = steps.map((step, index) => ({      ...step,      order: index    }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   return (    <div className="space-y-4">      <div className="flex justify-between items-center">        <h3 className="text-lg font-medium">Passos do Pipeline</h3>        <Button onClick={handleAddStep}>          <Plus className="mr-2 h-4 w-4" /> Adicionar Passo        </Button>      </div>       {selectedPipeline.steps.length === 0 ? (        <Alert>          <AlertDescription>            Este pipeline não possui passos. Adicione passos para definir o fluxo de processamento.          </AlertDescription>        </Alert>      ) : (        <DragDropContext onDragEnd={handleDragEnd}>          <Droppable droppableId="pipeline-steps">            {(provided) => (              <div                {...provided.droppableProps}                ref={provided.innerRef}                className="space-y-4"              >                {selectedPipeline.steps                  .sort((a, b) => a.order - b.order)                  .map((step, index) => (                    <PipelineStepComponent                      key={step.id}                      step={step}                      index={index}                      providers={providers}                      onUpdateStep={handleUpdateStep}                      onRemoveStep={handleRemoveStep}                    />                  ))}                {provided.placeholder}              </div>            )}          </Droppable>        </DragDropContext>      )}    </div>  ); }``

### src/components/llm/pipelines/PipelineTester.tsx

`import React, { useState } from "react"; import { useLLM } from "@/hooks/useLLM"; import { LLMPipeline } from "@/types/llm"; import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"; import { Textarea } from "@/components/ui/textarea"; import { Button } from "@/components/ui/button"; import { Loader2 } from "lucide-react"; import { toast } from "sonner"; interface PipelineTesterProps {   pipeline: LLMPipeline; } export function PipelineTester({ pipeline }: PipelineTesterProps) {   const [input, setInput] = useState("");  const [output, setOutput] = useState("");  const { processThroughPipeline, isPipelineProcessing } = useLLM();   const handleProcess = async () => {    if (!input.trim()) {      toast.error("Por favor, insira um texto para processar");      return;    }     if (pipeline.steps.length === 0) {      toast.error("Este pipeline não possui passos definidos");      return;    }     try {      const result = await processThroughPipeline(pipeline.id, input);      setOutput(result);      toast.success("Processamento concluído com sucesso");    } catch (error) {      toast.error("Erro no processamento", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   return (    <Card>      <CardHeader>        <CardTitle>Testar Pipeline</CardTitle>      </CardHeader>      <CardContent className="space-y-4">        <div className="space-y-2">          <h4 className="text-sm font-medium">Entrada</h4>          <Textarea            placeholder="Digite o texto de entrada para o pipeline..."            value={input}            onChange={(e) => setInput(e.target.value)}            rows={5}          />        </div>         <Button          onClick={handleProcess}          disabled={isPipelineProcessing || !input.trim()}          className="w-full"        >          {isPipelineProcessing ? (            <>              <Loader2 className="mr-2 h-4 w-4 animate-spin" />              Processando...            </>          ) : (            "Processar"          )}        </Button>         <div className="space-y-2">          <h4 className="text-sm font-medium">Saída</h4>          <div className="rounded-md border border-border p-4 min-h-[120px] bg-muted/30">            {output ? (              <pre className="whitespace-pre-wrap break-words text-sm">                {output}              </pre>            ) : (              <p className="text-muted-foreground text-center my-8">                A saída do processamento aparecerá aqui              </p>            )}          </div>        </div>      </CardContent>    </Card>  ); }`

### src/components/llm/pipelines/PipelinesList.tsx

``import React from "react"; import { LLMPipeline } from "@/types/llm"; import { useLLM } from "@/hooks/useLLM"; import {   Card,  CardContent,  CardDescription,  CardHeader,  CardTitle } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import {   Check,  Clock,  Plus,  Trash2,  MoreVertical } from "lucide-react"; import {   DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuTrigger } from "@/components/ui/dropdown-menu"; import { toast } from "sonner"; import {   Dialog,  DialogContent,  DialogDescription,  DialogFooter,  DialogHeader,  DialogTitle } from "@/components/ui/dialog"; import { Input } from "@/components/ui/input"; import { Textarea } from "@/components/ui/textarea"; import { format } from "date-fns"; import { v4 as uuidv4 } from "uuid"; interface PipelinesListProps {   pipelines: LLMPipeline[];  selectedPipelineId: string | null;  onSelectPipeline: (pipelineId: string) => void;  onPipelinesChange: () => void; } export function PipelinesList({   pipelines,  selectedPipelineId,  onSelectPipeline,  onPipelinesChange }: PipelinesListProps) {   const { createPipeline, deletePipeline } = useLLM();  const [isCreateDialogOpen, setIsCreateDialogOpen] = React.useState(false);  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = React.useState(false);  const [pipelineToDelete, setPipelineToDelete] = React.useState<string | null>(null);  const [newPipelineName, setNewPipelineName] = React.useState("");  const [newPipelineDescription, setNewPipelineDescription] = React.useState("");   const handleCreatePipeline = () => {    if (!newPipelineName.trim()) {      toast.error("O nome do pipeline é obrigatório");      return;    }     try {      const pipelineId = uuidv4();      createPipeline({        id: pipelineId,        name: newPipelineName,        description: newPipelineDescription,        steps: []      });             setNewPipelineName("");      setNewPipelineDescription("");      setIsCreateDialogOpen(false);      toast.success("Pipeline criado com sucesso");      onPipelinesChange();      onSelectPipeline(pipelineId);    } catch (error) {      toast.error("Erro ao criar pipeline", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   const handleDeleteClick = (pipelineId: string) => {    setPipelineToDelete(pipelineId);    setIsDeleteDialogOpen(true);  };   const handleDeleteConfirm = () => {    if (!pipelineToDelete) return;     try {      deletePipeline(pipelineToDelete);      setIsDeleteDialogOpen(false);      setPipelineToDelete(null);      toast.success("Pipeline excluído com sucesso");      onPipelinesChange();             // Se o pipeline excluído era o selecionado, limpe a seleção      if (selectedPipelineId === pipelineToDelete) {        onSelectPipeline("");      }    } catch (error) {      toast.error("Erro ao excluir pipeline", {        description: error instanceof Error ? error.message : "Erro desconhecido"      });    }  };   return (    <>      <div className="flex justify-between items-center mb-4">        <h2 className="text-xl font-semibold">Pipelines</h2>        <Button onClick={() => setIsCreateDialogOpen(true)}>          <Plus className="mr-2 h-4 w-4" /> Novo Pipeline        </Button>      </div>       <div className="space-y-4">        {pipelines.length === 0 ? (          <Card>            <CardContent className="py-8 text-center">              <p className="text-muted-foreground">                Nenhum pipeline encontrado. Crie um novo pipeline para começar.              </p>              <Button                variant="outline"                className="mt-4"                onClick={() => setIsCreateDialogOpen(true)}              >                <Plus className="mr-2 h-4 w-4" /> Criar Pipeline              </Button>            </CardContent>          </Card>        ) : (          pipelines.map((pipeline) => (            <Card              key={pipeline.id}              className={`cursor-pointer transition-colors ${                selectedPipelineId === pipeline.id                  ? "border-primary"                  : "hover:border-primary/50"              }`}              onClick={() => onSelectPipeline(pipeline.id)}            >              <CardHeader className="flex flex-row items-start justify-between p-4">                <div>                  <CardTitle className="text-base">{pipeline.name}</CardTitle>                  {pipeline.description && (                    <CardDescription>{pipeline.description}</CardDescription>                  )}                </div>                <DropdownMenu>                  <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>                    <Button variant="ghost" size="icon">                      <MoreVertical className="h-4 w-4" />                    </Button>                  </DropdownMenuTrigger>                  <DropdownMenuContent align="end">                    <DropdownMenuItem                      className="text-destructive"                      onClick={(e) => {                        e.stopPropagation();                        handleDeleteClick(pipeline.id);                      }}                    >                      <Trash2 className="mr-2 h-4 w-4" />                      Excluir Pipeline                    </DropdownMenuItem>                  </DropdownMenuContent>                </DropdownMenu>              </CardHeader>              <CardContent className="p-4 pt-0">                <div className="flex items-center text-xs text-muted-foreground">                  <div className="flex items-center mr-4">                    <Check className="mr-1 h-3 w-3" />                    <span>{pipeline.steps.length} passos</span>                  </div>                  {pipeline.updatedAt && (                    <div className="flex items-center">                      <Clock className="mr-1 h-3 w-3" />                      <span>                        Atualizado em{" "}                        {format(new Date(pipeline.updatedAt), "dd/MM/yyyy")}                      </span>                    </div>                  )}                </div>              </CardContent>            </Card>          ))        )}      </div>       <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Criar Novo Pipeline</DialogTitle>            <DialogDescription>              Defina as informações básicas do pipeline. Você poderá adicionar passos depois.            </DialogDescription>          </DialogHeader>          <div className="space-y-4 py-2">            <div className="space-y-2">              <label htmlFor="pipeline-name" className="text-sm font-medium">                Nome              </label>              <Input                id="pipeline-name"                placeholder="Nome do pipeline"                value={newPipelineName}                onChange={(e) => setNewPipelineName(e.target.value)}              />            </div>            <div className="space-y-2">              <label htmlFor="pipeline-description" className="text-sm font-medium">                Descrição (opcional)              </label>              <Textarea                id="pipeline-description"                placeholder="Descrição do pipeline"                value={newPipelineDescription}                onChange={(e) => setNewPipelineDescription(e.target.value)}              />            </div>          </div>          <DialogFooter>            <Button variant="outline" onClick={() => setIsCreateDialogOpen(false)}>              Cancelar            </Button>            <Button onClick={handleCreatePipeline}>Criar Pipeline</Button>          </DialogFooter>        </DialogContent>      </Dialog>       <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Excluir Pipeline</DialogTitle>            <DialogDescription>              Tem certeza que deseja excluir este pipeline? Esta ação não pode ser desfeita.            </DialogDescription>          </DialogHeader>          <DialogFooter>            <Button variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>              Cancelar            </Button>            <Button variant="destructive" onClick={handleDeleteConfirm}>              Excluir            </Button>          </DialogFooter>        </DialogContent>      </Dialog>    </>  ); }``

### src/hooks/llm/usePipelines.ts

``import { useCallback, useState } from 'react'; import { LLMPipeline, PipelineStep } from '../../types/llm'; import { llmServiceInstance } from './llmServiceInstance'; import { v4 as uuidv4 } from 'uuid'; export const usePipelines = () => {   const [isProcessing, setIsProcessing] = useState(false);  const [processingError, setProcessingError] = useState<string | null>(null);   const createPipeline = useCallback((    name: string,    description: string,    steps: Omit<PipelineStep, 'id'>[]  ): string => {    const pipelineId = uuidv4();         // Criar IDs para cada passo    const stepsWithIds: PipelineStep[] = steps.map(step => ({      ...step,      id: uuidv4()    }));         return llmServiceInstance.createPipeline({      id: pipelineId,      name,      description,      steps: stepsWithIds    });  }, []);   const updatePipeline = useCallback((    pipelineId: string,    updates: Partial<Omit<LLMPipeline, 'id' | 'createdAt' | 'updatedAt'>>  ): void => {    llmServiceInstance.updatePipeline(pipelineId, updates);  }, []);   const deletePipeline = useCallback((pipelineId: string): void => {    llmServiceInstance.deletePipeline(pipelineId);  }, []);   const getPipeline = useCallback((pipelineId: string): LLMPipeline | undefined => {    return llmServiceInstance.getPipeline(pipelineId);  }, []);   const listPipelines = useCallback((): LLMPipeline[] => {    return llmServiceInstance.listPipelines();  }, []);   const processThroughPipeline = useCallback(async (    pipelineId: string,    input: string  ): Promise<string> => {    setIsProcessing(true);    setProcessingError(null);         try {      const result = await llmServiceInstance.processThroughPipeline(pipelineId, input);      return result;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setProcessingError(errorMessage);      throw error;    } finally {      setIsProcessing(false);    }  }, []);   const addStepToPipeline = useCallback((    pipelineId: string,    step: Omit<PipelineStep, 'id'>  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const newStep: PipelineStep = {      ...step,      id: uuidv4()    };         const updatedSteps = [...pipeline.steps, newStep];    llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   const removeStepFromPipeline = useCallback((    pipelineId: string,    stepId: string  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const updatedSteps = pipeline.steps.filter(step => step.id !== stepId);    llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   const updateStepInPipeline = useCallback((    pipelineId: string,    stepId: string,    updates: Partial<Omit<PipelineStep, 'id'>>  ): void => {    const pipeline = llmServiceInstance.getPipeline(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline ${pipelineId} não encontrado`);    }         const updatedSteps = pipeline.steps.map(step =>      step.id === stepId ? { ...step, ...updates } : step    );         llmServiceInstance.updatePipeline(pipelineId, { steps: updatedSteps });  }, []);   return {    createPipeline,    updatePipeline,    deletePipeline,    getPipeline,    listPipelines,    processThroughPipeline,    addStepToPipeline,    removeStepFromPipeline,    updateStepInPipeline,    isProcessing,    processingError  }; };``

### src/pages/LLMManagerPage.tsx

`import React, { useState, useEffect } from "react"; import { useLLM } from "@/hooks/useLLM"; import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; import { LLMConfig } from "@/components/llm/LLMConfig"; import { LLMMonitoring } from "@/components/llm/LLMMonitoring"; import { LLMPipelinesManager } from "@/components/llm/LLMPipelinesManager"; import { useSearchParams } from "react-router-dom"; import { LLMProvider } from "@/types/llm"; export default function LLMManagerPage() {   const { listProviders } = useLLM();  const [providers, setProviders] = useState<LLMProvider[]>([]);  const [searchParams, setSearchParams] = useSearchParams();  const activeTab = searchParams.get("tab") || "config";   useEffect(() => {    // Carregar provedores ao montar o componente    setProviders(listProviders());  }, [listProviders]);   const handleTabChange = (value: string) => {    setSearchParams({ tab: value });  };   const handleProvidersChange = () => {    // Atualizar a lista de provedores quando mudanças ocorrerem    setProviders(listProviders());  };   return (    <div className="container py-8">      <header className="mb-8">        <h1 className="text-3xl font-bold">Gerenciador de LLMs</h1>        <p className="text-muted-foreground">          Configure provedores de LLM, monitore o uso e gerencie pipelines de processamento.        </p>      </header>       <Tabs value={activeTab} onValueChange={handleTabChange} className="space-y-4">        <TabsList>          <TabsTrigger value="config">Configuração</TabsTrigger>          <TabsTrigger value="monitoring">Monitoramento</TabsTrigger>          <TabsTrigger value="pipelines">Pipelines</TabsTrigger>        </TabsList>         <TabsContent value="config">          <LLMConfig providers={providers} onProvidersChange={handleProvidersChange} />        </TabsContent>         <TabsContent value="monitoring">          <LLMMonitoring providers={providers} />        </TabsContent>         <TabsContent value="pipelines">          <LLMPipelinesManager providers={providers} />        </TabsContent>      </Tabs>    </div>  ); }`

### src/components/document/DocumentInputCard.tsx

`import React, { useState } from "react"; import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { Textarea } from "@/components/ui/textarea"; import { Input } from "@/components/ui/input"; import { FileText, Upload } from "lucide-react"; interface DocumentInputCardProps {   onProcess: (document: { title: string; content: string }) => void;  isProcessing: boolean; } export function DocumentInputCard({ onProcess, isProcessing }: DocumentInputCardProps) {   const [title, setTitle] = useState("");  const [content, setContent] = useState("");  const [file, setFile] = useState<File | null>(null);   const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {    const selectedFile = e.target.files?.[0];    if (!selectedFile) return;     setFile(selectedFile);         if (selectedFile.name && !title) {      // Usar o nome do arquivo como título, removendo a extensão      const fileNameWithoutExtension = selectedFile.name.replace(/\.[^/.]+$/, "");      setTitle(fileNameWithoutExtension);    }     // Ler o conteúdo do arquivo se for um arquivo de texto    if (selectedFile.type.includes("text") || selectedFile.type.includes("markdown")) {      const reader = new FileReader();      reader.onload = (e) => {        const fileContent = e.target?.result as string;        setContent(fileContent);      };      reader.readAsText(selectedFile);    }  };   const handleSubmit = (e: React.FormEvent) => {    e.preventDefault();         if (!title.trim()) {      alert("Por favor, insira um título para o documento");      return;    }     if (!content.trim()) {      alert("Por favor, insira ou carregue conteúdo para o documento");      return;    }     onProcess({ title, content });  };   return (    <Card>      <CardHeader>        <CardTitle className="flex items-center">          <FileText className="mr-2 h-5 w-5" />          Documento de Entrada        </CardTitle>      </CardHeader>      <form onSubmit={handleSubmit}>        <CardContent className="space-y-4">          <div className="space-y-2">            <label htmlFor="title" className="text-sm font-medium">              Título            </label>            <Input              id="title"              placeholder="Título do documento"              value={title}              onChange={(e) => setTitle(e.target.value)}            />          </div>           <div className="space-y-2">            <label htmlFor="content" className="text-sm font-medium">              Conteúdo            </label>            <Textarea              id="content"              placeholder="Conteúdo do documento (Markdown suportado)"              value={content}              onChange={(e) => setContent(e.target.value)}              rows={12}              className="font-mono"            />          </div>           <div className="flex items-center justify-center border-2 border-dashed border-muted-foreground/25 rounded-md p-4">            <label htmlFor="file-upload" className="cursor-pointer flex flex-col items-center">              <Upload className="h-6 w-6 text-muted-foreground mb-2" />              <span className="text-sm text-muted-foreground mb-1">                Clique para carregar um arquivo              </span>              <span className="text-xs text-muted-foreground">                {file ? file.name : "Arquivos .md, .txt suportados"}              </span>              <input                id="file-upload"                type="file"                className="hidden"                accept=".md,.txt,.markdown,.text"                onChange={handleFileChange}              />            </label>          </div>        </CardContent>         <CardFooter>          <Button            type="submit"            className="w-full"            disabled={isProcessing || !title.trim() || !content.trim()}          >            {isProcessing ? "Processando..." : "Processar Documento"}          </Button>        </CardFooter>      </form>    </Card>  ); }`

### src/components/document/DocumentProcessorPanel.tsx

`import React, { useState } from "react"; import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; import { AnalysisTab } from "./AnalysisTab"; import { StructureTab } from "./StructureTab"; import { ValidationTab } from "./ValidationTab"; import { SuggestionsTab } from "./SuggestionsTab"; import { ProcessingProgress } from "./ProcessingProgress"; import { EmptyProcessorState } from "./EmptyProcessorState"; import { ProcessedDocument } from "@/types/document"; interface DocumentProcessorPanelProps {   document: ProcessedDocument | null;  isProcessing: boolean;  progress: number; // 0-100 } export function DocumentProcessorPanel({   document,  isProcessing,  progress }: DocumentProcessorPanelProps) {   const [activeTab, setActiveTab] = useState("analysis");   if (isProcessing) {    return <ProcessingProgress progress={progress} />;  }   if (!document) {    return <EmptyProcessorState />;  }   return (    <div className="space-y-4">      <div>        <h2 className="text-2xl font-bold">{document.title}</h2>        {document.summary && (          <p className="text-muted-foreground mt-1">{document.summary}</p>        )}      </div>       <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">        <TabsList>          <TabsTrigger value="analysis">Análise</TabsTrigger>          <TabsTrigger value="structure">Estrutura</TabsTrigger>          <TabsTrigger value="validation">Validação</TabsTrigger>          <TabsTrigger value="suggestions">Sugestões</TabsTrigger>        </TabsList>         <TabsContent value="analysis">          <AnalysisTab document={document} />        </TabsContent>         <TabsContent value="structure">          <StructureTab document={document} />        </TabsContent>         <TabsContent value="validation">          <ValidationTab document={document} />        </TabsContent>         <TabsContent value="suggestions">          <SuggestionsTab document={document} />        </TabsContent>      </Tabs>    </div>  ); }`

### src/types/llm.ts

`export interface LLMProvider {   id: string;  name: string;  type: string;  apiKey?: string;  endpoint?: string;  models: string[];  capabilities: {    textCompletion: boolean;    chatCompletion: boolean;    embedding: boolean;    imageGeneration: boolean;    audioTranscription: boolean;  };  parameters?: {    defaultTemperature: number;    defaultMaxTokens: number;    defaultTopP: number;  };  usage?: {    requestCount: number;    tokensUsed: number;    lastUsed: string;  }; } export interface LLMConfig {   defaultProvider: string;  providers: Record<string, LLMProvider>;  settings: {    maxConcurrentRequests: number;    retryAttempts: number;    timeout: number;  }; } export interface ChatMessage {   role: 'system' | 'user' | 'assistant';  content: string; } export interface LLMResponse {   message: ChatMessage;  usage: {    promptTokens: number;    completionTokens: number;    totalTokens: number;  };  model: string;  provider: string; } export interface CompletionOptions {   model?: string;  temperature?: number;  maxTokens?: number;  topP?: number;  frequencyPenalty?: number;  presencePenalty?: number; } export interface ChatResponse {   message: string;  usage: {    promptTokens: number;    completionTokens: number;    totalTokens: number;  }; } export interface LLMStats {   requestCount: number;  successRate: number;  averageLatency: number;  costPerRequest: number;  tokensUsed: {    prompt: number;    completion: number;    total: number;  };  requestsPerDay: Record<string, number>; } export interface LLMUsageMetrics {   providerId: string;  period: 'day' | 'week' | 'month' | 'all';  requestCount: number;  tokensUsed: number;  cost: number;  successRate: number;  averageLatency: number;  requestsTimeline: {    timestamp: string;    count: number;  }[]; } export interface PipelineStep {   id: string;  providerId: string;  role: "input" | "processor" | "output";  order: number;  systemPrompt?: string;  model?: string;  options?: CompletionOptions; } export interface LLMPipeline {   id: string;  name: string;  description?: string;  steps: PipelineStep[];  createdAt: string;  updatedAt: string; } export interface LLMServiceConfig {   defaultProvider: string;  providers: Record<string, LLMProvider>;  settings: {    maxConcurrentRequests: number;    retryAttempts: number;    timeout: number;  }; }`

Vou continuar descrevendo mais módulos na próxima resposta, pois ainda temos vários componentes importantes a serem detalhados. Informe-me quando desejar que eu continue com mais módulos.

CONTINUE DE ONDE PAROU AGORA E DESCREVA ABSOLUTAMENTE TODOS OS MODULOS COMO FICARAM OS CODIGOS FINAIS DA Estrutura Completa da Aplicação Estrutura de Diretórios e Arquivos COMECE DE ONDE PAROU E PROSSIGA, NÃO OMITA E NEM RESUMA ESCREVA NA INTEGRA, QUANDO CHEGAR AO FIM SE FALTAREM MODULOS ME AVIZE QUE POÇO PARA CONTINUAR EM UMA NOVA CONVERSA DE ONDE PAROU



### src/components/file-explorer/FileExplorer.tsx

``import React, { useState } from 'react'; import { Folder, File, ChevronRight, ChevronDown, Plus, MoreHorizontal, Trash, PenLine, Copy } from 'lucide-react'; import {   DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; import { Button } from '@/components/ui/button'; import { toast } from 'sonner'; import { ScrollArea } from '@/components/ui/scroll-area'; import { cn } from '@/lib/utils'; export interface FileNode {   id: string;  name: string;  type: 'file' | 'folder';  content?: string;  children?: FileNode[];  createdAt: string;  modifiedAt: string;  tags?: string[];  parent?: string; } interface FileExplorerProps {   files: FileNode[];  onFileSelect: (file: FileNode) => void;  onFileCreate: (type: 'file' | 'folder', parentId?: string) => void;  onFileDelete: (fileId: string) => void;  onFileRename: (fileId: string, newName: string) => void;  selectedFileId?: string; } export const FileExplorer: React.FC<FileExplorerProps> = ({   files,  onFileSelect,  onFileCreate,  onFileDelete,  onFileRename,  selectedFileId }) => {   const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());  const [renamingId, setRenamingId] = useState<string | null>(null);  const [newName, setNewName] = useState<string>('');   const toggleFolder = (folderId: string) => {    const newExpandedFolders = new Set(expandedFolders);    if (newExpandedFolders.has(folderId)) {      newExpandedFolders.delete(folderId);    } else {      newExpandedFolders.add(folderId);    }    setExpandedFolders(newExpandedFolders);  };   const startRenaming = (file: FileNode, e: React.MouseEvent) => {    e.stopPropagation();    setRenamingId(file.id);    setNewName(file.name);  };   const handleRename = (fileId: string) => {    if (newName.trim()) {      onFileRename(fileId, newName);      toast.success(`Arquivo renomeado para ${newName}`);    }    setRenamingId(null);  };   const handleDelete = (fileId: string, e: React.MouseEvent) => {    e.stopPropagation();    onFileDelete(fileId);    toast.success("Arquivo excluído com sucesso");  };   const renderFileTree = (nodes: FileNode[], level = 0) => {    return nodes.map((node) => {      const isExpanded = expandedFolders.has(node.id);      const isSelected = selectedFileId === node.id;             return (        <div key={node.id} className="select-none">          <div            className={cn(              "flex items-center py-1 px-2 hover:bg-muted/50 rounded cursor-pointer",              isSelected && "bg-muted",              level > 0 && `ml-${level * 4}`            )}            onClick={() => node.type === 'folder'              ? toggleFolder(node.id)              : onFileSelect(node)            }          >            {node.type === 'folder' && (              <Button variant="ghost" size="icon" className="h-4 w-4 p-0 mr-1">                {isExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}              </Button>            )}                         {node.type === 'folder'              ? <Folder className="h-4 w-4 mr-2 text-blue-500" />              : <File className="h-4 w-4 mr-2 text-gray-500" />            }                         {renamingId === node.id ? (              <input                type="text"                value={newName}                onChange={(e) => setNewName(e.target.value)}                onBlur={() => handleRename(node.id)}                onKeyDown={(e) => e.key === 'Enter' && handleRename(node.id)}                className="bg-background border rounded px-1 py-0 text-sm w-full focus:outline-none focus:ring-1 focus:ring-primary"                autoFocus                onClick={(e) => e.stopPropagation()}              />            ) : (              <span className="text-sm flex-grow truncate">{node.name}</span>            )}                         <DropdownMenu>              <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>                <Button variant="ghost" size="icon" className="h-6 w-6 p-0 opacity-0 group-hover:opacity-100 hover:opacity-100">                  <MoreHorizontal className="h-4 w-4" />                </Button>              </DropdownMenuTrigger>              <DropdownMenuContent align="end">                <DropdownMenuItem onClick={(e) => startRenaming(node, e)}>                  <PenLine className="h-4 w-4 mr-2" />                  Renomear                </DropdownMenuItem>                <DropdownMenuItem onClick={(e) => handleDelete(node.id, e)}>                  <Trash className="h-4 w-4 mr-2" />                  Excluir                </DropdownMenuItem>                {node.type === 'folder' && (                  <DropdownMenuItem onClick={(e) => {                    e.stopPropagation();                    onFileCreate('file', node.id);                  }}>                    <Plus className="h-4 w-4 mr-2" />                    Novo Arquivo                  </DropdownMenuItem>                )}              </DropdownMenuContent>            </DropdownMenu>          </div>                     {node.type === 'folder' && isExpanded && node.children && (            <div className="pl-4">              {renderFileTree(node.children, level + 1)}            </div>          )}        </div>      );    });  };   return (    <div className="h-full border-r">      <div className="p-4 border-b flex justify-between items-center">        <h2 className="text-lg font-semibold">Arquivos</h2>        <div className="flex space-x-1">          <Button            variant="outline"            size="sm"            onClick={() => onFileCreate('file')}            className="h-8 px-2"          >            <Plus className="h-4 w-4 mr-1" />            Arquivo          </Button>          <Button            variant="outline"            size="sm"            onClick={() => onFileCreate('folder')}            className="h-8 px-2"          >            <Folder className="h-4 w-4 mr-1" />            Pasta          </Button>        </div>      </div>      <ScrollArea className="h-[calc(100vh-10rem)]">        <div className="p-2">          {renderFileTree(files)}        </div>      </ScrollArea>    </div>  ); };``

### src/components/markdown-editor/MarkdownEditor.tsx

`import React, { useState, useEffect } from 'react'; import Editor from '@monaco-editor/react'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'; import { Button } from '@/components/ui/button'; import { Separator } from '@/components/ui/separator'; import { Badge } from '@/components/ui/badge'; import { Input } from '@/components/ui/input'; import { ScrollArea } from '@/components/ui/scroll-area'; import { FileNode } from '../file-explorer/FileExplorer'; import { Eye, Code, Save, History, Tag, Plus, X } from 'lucide-react'; import ReactMarkdown from 'react-markdown'; import remarkGfm from 'remark-gfm'; import rehypeRaw from 'rehype-raw'; import rehypeHighlight from 'rehype-highlight'; import { toast } from 'sonner'; import {   DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; import { format } from 'date-fns'; import 'highlight.js/styles/github-dark.css'; interface MarkdownEditorProps {   file: FileNode | null;  onSave: (content: string, tags?: string[]) => void;  onVersionSelect: (versionId: string) => void;  versions: Array<{ id: string; date: string; content: string }>; } export function MarkdownEditor({ file, onSave, onVersionSelect, versions }: MarkdownEditorProps) {   const [content, setContent] = useState('');  const [tags, setTags] = useState<string[]>([]);  const [newTag, setNewTag] = useState('');  const [view, setView] = useState<'edit' | 'preview'>('edit');  const [isDirty, setIsDirty] = useState(false);   useEffect(() => {    if (file) {      setContent(file.content || '');      setTags(file.tags || []);      setIsDirty(false);    } else {      setContent('');      setTags([]);      setIsDirty(false);    }  }, [file]);   const handleSave = () => {    if (!file) return;         onSave(content, tags);    setIsDirty(false);    toast.success('Arquivo salvo com sucesso');  };   const handleEditorChange = (value: string | undefined) => {    if (value !== undefined) {      setContent(value);      setIsDirty(true);    }  };   const handleAddTag = () => {    if (newTag.trim() && !tags.includes(newTag.trim())) {      const updatedTags = [...tags, newTag.trim()];      setTags(updatedTags);      setNewTag('');      setIsDirty(true);    }  };   const handleRemoveTag = (tagToRemove: string) => {    const updatedTags = tags.filter(tag => tag !== tagToRemove);    setTags(updatedTags);    setIsDirty(true);  };   const handleKeyDown = (e: React.KeyboardEvent) => {    if (e.key === 'Enter') {      e.preventDefault();      handleAddTag();    }  };   if (!file) {    return (      <div className="flex items-center justify-center h-full">        <div className="text-center">          <h3 className="text-lg font-medium mb-2">Nenhum arquivo selecionado</h3>          <p className="text-muted-foreground">Selecione um arquivo para visualizar e editar</p>        </div>      </div>    );  }   return (    <div className="h-full flex flex-col">      <div className="border-b py-2 px-4 flex justify-between items-center">        <div>          <h3 className="font-medium text-lg">{file.name}</h3>          <p className="text-xs text-muted-foreground">            Modificado em {format(new Date(file.modifiedAt), 'dd/MM/yyyy HH:mm')}          </p>        </div>        <div className="flex gap-2">          <Tabs value={view} onValueChange={(v) => setView(v as 'edit' | 'preview')}>            <TabsList>              <TabsTrigger value="edit" className="flex items-center">                <Code className="h-4 w-4 mr-1" />                Editar              </TabsTrigger>              <TabsTrigger value="preview" className="flex items-center">                <Eye className="h-4 w-4 mr-1" />                Visualizar              </TabsTrigger>            </TabsList>          </Tabs>          <Button            variant="default"            size="sm"            onClick={handleSave}            disabled={!isDirty}          >            <Save className="h-4 w-4 mr-1" />            Salvar          </Button>          <DropdownMenu>            <DropdownMenuTrigger asChild>              <Button variant="outline" size="sm">                <History className="h-4 w-4 mr-1" />                Versões              </Button>            </DropdownMenuTrigger>            <DropdownMenuContent align="end">              {versions.length > 0 ? (                versions.map((version) => (                  <DropdownMenuItem                    key={version.id}                    onClick={() => onVersionSelect(version.id)}                  >                    {format(new Date(version.date), 'dd/MM/yyyy HH:mm')}                  </DropdownMenuItem>                ))              ) : (                <DropdownMenuItem disabled>Nenhuma versão disponível</DropdownMenuItem>              )}            </DropdownMenuContent>          </DropdownMenu>        </div>      </div>       <div className="p-4 border-b">        <div className="flex items-center">          <Tag className="h-4 w-4 mr-2" />          <h4 className="text-sm font-medium mr-2">Tags:</h4>          <div className="flex flex-wrap gap-1 flex-grow">            {tags.map((tag) => (              <Badge key={tag} variant="secondary" className="flex items-center gap-1">                {tag}                <Button                  variant="ghost"                  size="icon"                  className="h-4 w-4 p-0 text-muted-foreground hover:text-foreground"                  onClick={() => handleRemoveTag(tag)}                >                  <X className="h-3 w-3" />                </Button>              </Badge>            ))}            <div className="flex items-center">              <Input                value={newTag}                onChange={(e) => setNewTag(e.target.value)}                onKeyDown={handleKeyDown}                placeholder="Adicionar tag..."                className="h-7 px-2 text-sm max-w-[150px]"              />              <Button                variant="ghost"                size="icon"                className="h-7 w-7"                onClick={handleAddTag}                disabled={!newTag.trim()}              >                <Plus className="h-4 w-4" />              </Button>            </div>          </div>        </div>      </div>       <div className="flex-grow overflow-hidden">        <Tabs value={view} className="h-full">          <TabsContent value="edit" className="h-full m-0 p-0">            <Editor              height="100%"              defaultLanguage="markdown"              value={content}              onChange={handleEditorChange}              options={{                minimap: { enabled: false },                wordWrap: 'on',                lineNumbers: 'on',                fontSize: 14,                fontFamily: 'monospace'              }}              theme="vs-dark"            />          </TabsContent>          <TabsContent value="preview" className="h-full m-0 p-4 overflow-hidden">            <Card className="h-full border">              <CardHeader className="py-3">                <CardTitle className="text-xl">{file.name.replace(/\.md$/, '')}</CardTitle>              </CardHeader>              <Separator />              <CardContent className="p-4">                <ScrollArea className="h-[calc(100vh-15rem)]">                  <div className="prose dark:prose-invert max-w-none">                    <ReactMarkdown                      remarkPlugins={[remarkGfm]}                      rehypePlugins={[rehypeRaw, rehypeHighlight]}                    >                      {content}                    </ReactMarkdown>                  </div>                </ScrollArea>              </CardContent>            </Card>          </TabsContent>        </Tabs>      </div>    </div>  ); }`

### src/services/media/AudioProcessor.ts

`import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class AudioProcessor extends BaseMediaProcessor {   constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    super('audio', cacheService, monitoringService);  }     /**   * Processa um arquivo de áudio   * @param file Arquivo de áudio   * @returns Resultado do processamento   */  async process(file: File): Promise<MediaProcessingResult> {    this.logProcessingStart(file);         try {      // Verificar cache      const cachedResult = await this.checkCache(file);      if (cachedResult) return cachedResult;             // Preparar o arquivo (convertê-lo para um formato manipulável)      const audioData = await this.prepareAudioFile(file);             // Simular transcrição (em produção, usaríamos uma API como OpenAI Whisper)      const transcription = await this.simulateTranscription(audioData);             // Analisar o conteúdo da transcrição      const analysis = await this.analyzeContent(transcription);             // Criar resultado      const result: MediaProcessingResult = {        id: this.generateId(file),        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'audio',        content: transcription,        analysis: {          ...analysis,        },        metadata: {          name: file.name,          size: file.size,          type: file.type,          duration: this.calculateDuration(audioData),          language: this.detectLanguage(transcription)        }      };             // Salvar em cache      await this.saveToCache(file, result);             this.logProcessingEnd(file, result);      return result;    } catch (error) {      this.logProcessingError(file, error);      throw error;    }  }     private async prepareAudioFile(file: File): Promise<ArrayBuffer> {    // Na implementação real, converteria o arquivo para um formato manipulável    // e calcularia propriedades como duração, taxa de amostragem, etc.    return new Promise((resolve) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as ArrayBuffer);      reader.readAsArrayBuffer(file);    });  }     private async simulateTranscription(audioData: ArrayBuffer): Promise<string> {    // Em produção, usaríamos uma API de transcrição de áudio    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 1000));         const transcriptions = [      "Neste áudio, discutimos a arquitetura do sistema de processamento de conhecimento. " +      "Os principais componentes incluem processadores de conteúdo, gerenciamento de LLMs, " +      "armazenamento e cache, monitoramento e logging, além do sistema de triagem e templates.",             "Esta gravação contém um resumo das funcionalidades do pipeline de processamento. " +      "Cada documento passa por múltiplas etapas de processamento, executadas por diferentes LLMs, " +      "seguindo um fluxo configurável e extensível.",             "A reunião abordou a integração de diferentes tipos de mídia no sistema, " +      "incluindo documentos, imagens, áudio e vídeo. Cada tipo de mídia requer " +      "processadores específicos para extrair conhecimento estruturado."    ];         return transcriptions[Math.floor(Math.random() * transcriptions.length)];  }     private calculateDuration(audioData: ArrayBuffer): number {    // Em produção, extrairíamos a duração real do arquivo de áudio    // Simulação para fins de demonstração    return (audioData.byteLength / 1024) / 10; // Duração simulada em segundos  }     private detectLanguage(text: string): string {    // Em produção, usaríamos um detector de idioma real    // Simulação para fins de demonstração    return "pt-BR";  }     private async analyzeContent(transcription: string): Promise<{    sentiment: string;    confidence: number;    speakers: string[];    summary: string;  }> {    // Em produção, usaríamos um serviço de análise de sentimento e conteúdo    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 500));         return {      sentiment: Math.random() > 0.5 ? "positive" : "neutral",      confidence: 0.85 + (Math.random() * 0.15),      speakers: ["Speaker 1", "Speaker 2"],      summary: transcription.length > 100        ? transcription.substring(0, 100) + "..."        : transcription    };  } }`

### src/services/media/ImageProcessor.ts

``import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class ImageProcessor extends BaseMediaProcessor {   constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    super('image', cacheService, monitoringService);  }     /**   * Processa um arquivo de imagem   * @param file Arquivo de imagem   * @returns Resultado do processamento   */  async process(file: File): Promise<MediaProcessingResult> {    this.logProcessingStart(file);         try {      // Verificar cache      const cachedResult = await this.checkCache(file);      if (cachedResult) return cachedResult;             // Preparar o arquivo (convertê-lo para um formato manipulável)      const imageData = await this.prepareImageFile(file);             // Extrair metadados da imagem      const metadata = await this.extractImageMetadata(file, imageData);             // Analisar o conteúdo da imagem      const analysis = await this.analyzeImage(imageData);             // Criar resultado      const result: MediaProcessingResult = {        id: this.generateId(file),        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'image',        content: imageData.url,        analysis: {          ...analysis,        },        metadata      };             // Salvar em cache      await this.saveToCache(file, result);             this.logProcessingEnd(file, result);      return result;    } catch (error) {      this.logProcessingError(file, error);      throw error;    }  }     private async prepareImageFile(file: File): Promise<{ url: string, width: number, height: number }> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = (e) => {        const img = new Image();        img.onload = () => {          resolve({            url: e.target?.result as string,            width: img.width,            height: img.height          });        };        img.onerror = () => reject(new Error('Erro ao carregar imagem'));        img.src = e.target?.result as string;      };      reader.onerror = () => reject(new Error('Erro ao ler arquivo'));      reader.readAsDataURL(file);    });  }     private async extractImageMetadata(    file: File,    imageData: { url: string, width: number, height: number }  ): Promise<{    name: string;    size: number;    type: string;    dimensions: {      width: number;      height: number;    };    format: string;  }> {    // Extrair formato da imagem do mimetype    const format = file.type.split('/')[1]?.toUpperCase() || 'UNKNOWN';         return {      name: file.name,      size: file.size,      type: file.type,      dimensions: {        width: imageData.width,        height: imageData.height      },      format    };  }     private async analyzeImage(imageData: { url: string }): Promise<{    description: string;    objects: string[];    tags: string[];    colors: { color: string, percentage: number }[];  }> {    // Em produção, usaríamos um serviço de análise de imagem (como Vision API)    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 1000));         const possibleObjects = [      'pessoa', 'cadeira', 'mesa', 'computador', 'notebook',      'telefone', 'livro', 'planta', 'quadro', 'carro'    ];         const possibleTags = [      'trabalho', 'escritório', 'tecnologia', 'natureza',      'cidade', 'reunião', 'estudo', 'lazer'    ];         const possibleColors = [      { color: 'azul', hex: '#1E90FF' },      { color: 'verde', hex: '#2E8B57' },      { color: 'vermelho', hex: '#B22222' },      { color: 'amarelo', hex: '#FFD700' },      { color: 'preto', hex: '#000000' },      { color: 'branco', hex: '#FFFFFF' },      { color: 'cinza', hex: '#808080' }    ];         // Selecionar aleatoriamente alguns objetos e tags    const numObjects = Math.floor(Math.random() * 5) + 1;    const objects = shuffleAndTake(possibleObjects, numObjects);         const numTags = Math.floor(Math.random() * 4) + 1;    const tags = shuffleAndTake(possibleTags, numTags);         // Selecionar algumas cores e atribuir porcentagens    const numColors = Math.floor(Math.random() * 3) + 1;    const selectedColors = shuffleAndTake(possibleColors, numColors);    let remainingPercentage = 100;         const colors = selectedColors.map((color, index, array) => {      let percentage;      if (index === array.length - 1) {        percentage = remainingPercentage;      } else {        percentage = Math.floor(Math.random() * remainingPercentage);        remainingPercentage -= percentage;      }      return { color: color.color, percentage };    });         // Gerar descrição baseada nos objetos e tags    const description = `Imagem contendo ${objects.join(', ')}. A cena parece estar relacionada a ${tags.join(', ')}.`;         return {      description,      objects,      tags,      colors    };  } } // Função auxiliar para embaralhar array e pegar n elementos function shuffleAndTake<T>(array: T[], n: number): T[] {   const shuffled = [...array].sort(() => 0.5 - Math.random());  return shuffled.slice(0, n); }``

### src/services/media/VideoProcessor.ts

``import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class VideoProcessor extends BaseMediaProcessor {   constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    super('video', cacheService, monitoringService);  }     /**   * Processa um arquivo de vídeo   * @param file Arquivo de vídeo   * @returns Resultado do processamento   */  async process(file: File): Promise<MediaProcessingResult> {    this.logProcessingStart(file);         try {      // Verificar cache      const cachedResult = await this.checkCache(file);      if (cachedResult) return cachedResult;             // Preparar o arquivo (convertê-lo para um formato manipulável)      const videoData = await this.prepareVideoFile(file);             // Extrair frames representativos      const frames = await this.extractKeyFrames(videoData);             // Simular transcrição do áudio      const audioTranscription = await this.simulateAudioTranscription();             // Analisar o conteúdo do vídeo      const analysis = await this.analyzeContent(frames, audioTranscription);             // Criar resultado      const result: MediaProcessingResult = {        id: this.generateId(file),        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'video',        content: audioTranscription, // Conteúdo principal é a transcrição        analysis: {          ...analysis,          transcript: audioTranscription        },        metadata: {          name: file.name,          size: file.size,          type: file.type,          duration: videoData.duration,          resolution: `${videoData.width}x${videoData.height}`,          format: file.type.split('/')[1]        },        frames: frames.map(frame => ({          url: frame.url,          timestamp: frame.timestamp,          description: frame.description        }))      };             // Salvar em cache      await this.saveToCache(file, result);             this.logProcessingEnd(file, result);      return result;    } catch (error) {      this.logProcessingError(file, error);      throw error;    }  }     private async prepareVideoFile(file: File): Promise<{    url: string;    duration: number;    width: number;    height: number;  }> {    // Em produção, extrairíamos metadados reais do vídeo    // Simulação para fins de demonstração    return new Promise((resolve) => {      const url = URL.createObjectURL(file);      // Simular metadados baseados no tamanho do arquivo      const duration = (file.size / (1024 * 1024)) * 10; // ~10 segundos por MB             resolve({        url,        duration,        width: 1920,        height: 1080      });    });  }     private async extractKeyFrames(videoData: {    url: string;    duration: number  }): Promise<Array<{    url: string;    timestamp: number;    description: string;  }>> {    // Em produção, extrairíamos frames reais do vídeo    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 1000));         const numFrames = Math.min(5, Math.ceil(videoData.duration / 10));    const frames = [];         const frameDescriptions = [      "Pessoa explicando conceitos em um quadro branco",      "Vista de uma sala de reuniões com participantes discutindo",      "Demonstração de software em uma tela de computador",      "Apresentação de slides com diagramas de arquitetura",      "Entrevista com especialista em sistema de processamento"    ];         for (let i = 0; i < numFrames; i++) {      const timestamp = (i + 1) * (videoData.duration / (numFrames + 1));             frames.push({        url: `https://placekitten.com/800/450?image=${i}`, // Placeholder para simulação        timestamp,        description: frameDescriptions[i % frameDescriptions.length]      });    }         return frames;  }     private async simulateAudioTranscription(): Promise<string> {    // Em produção, usaríamos uma API de transcrição de áudio    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 800));         const transcriptions = [      "Neste vídeo, apresentamos o sistema de processamento de conhecimento. " +      "O sistema é composto por diversos módulos que trabalham em conjunto para extrair, " +      "processar e estruturar informações de diferentes tipos de mídia.",             "Demonstração do pipeline de processamento. Observe como o documento passa " +      "por diferentes estágios de análise, cada um executado por um LLM especializado " +      "com instruções específicas para sua função no pipeline.",             "Tutorial sobre como configurar um funil de triagem para processar documentos. " +      "Primeiro, defina os provedores de LLM que serão utilizados. Em seguida, " +      "configure os passos do pipeline, especificando o papel de cada LLM no processo."    ];         return transcriptions[Math.floor(Math.random() * transcriptions.length)];  }     private async analyzeContent(    frames: Array<{ url: string; timestamp: number; description: string }>,    transcript: string  ): Promise<{    summary: string;    objects: string[];    actions: string[];    scenes: { time: string; description: string }[];  }> {    // Em produção, usaríamos um serviço de análise de vídeo    // Simulação para fins de demonstração    await new Promise(resolve => setTimeout(resolve, 1200));         // Extrair palavras-chave do transcript para gerar objetos detectados    const words = transcript.split(/\s+/);    const nouns = words.filter(word =>      word.length > 4 && Math.random() > 0.8    ).map(word => word.replace(/[.,;:?!]/g, ''));         const uniqueNouns = [...new Set(nouns)].slice(0, 5);         // Ações detectadas (verbos simulados)    const actions = [      "explicando", "demonstrando", "apontando", "discutindo", "apresentando"    ].slice(0, Math.floor(Math.random() * 3) + 2);         // Descrição de cenas baseada nos frames    const scenes = frames.map(frame => ({      time: this.formatTime(frame.timestamp),      description: frame.description    }));         // Gerar resumo    const summary = transcript.length > 150      ? transcript.substring(0, 150) + "..."      : transcript;         return {      summary,      objects: uniqueNouns,      actions,      scenes    };  }     private formatTime(seconds: number): string {    const mins = Math.floor(seconds / 60);    const secs = Math.floor(seconds % 60);    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;  } }``

Continuarei descrevendo mais módulos na próxima mensagem, pois ainda temos vários componentes essenciais a serem detalhados. Informe-me quando desejar que eu prossiga com mais detalhes.

### src/services/media/BaseMediaProcessor.ts

``import { MediaProcessingResult } from '../../types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { v4 as uuidv4 } from 'uuid'; export abstract class BaseMediaProcessor {   protected mediaType: string;  protected cacheService?: CacheService<MediaProcessingResult>;  protected monitoringService?: MonitoringService;     constructor(    mediaType: string,    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    this.mediaType = mediaType;    this.cacheService = cacheService;    this.monitoringService = monitoringService;  }     /**   * Processa um arquivo de mídia   * @param file Arquivo a ser processado   */  abstract process(file: File): Promise<MediaProcessingResult>;     /**   * Verifica se existe um resultado em cache para o arquivo   */  protected async checkCache(file: File): Promise<MediaProcessingResult | null> {    if (!this.cacheService) {      return null;    }         const fileKey = this.generateCacheKey(file);    const cachedResult = await this.cacheService.get(fileKey);         if (cachedResult) {      this.monitoringService?.logEvent({        type: 'cache_hit',        mediaType: this.mediaType,        fileSize: file.size,        fileName: file.name      });    }         return cachedResult;  }     /**   * Salva um resultado no cache   */  protected async saveToCache(file: File, result: MediaProcessingResult): Promise<void> {    if (!this.cacheService) {      return;    }         const fileKey = this.generateCacheKey(file);    await this.cacheService.set(fileKey, result);  }     /**   * Gera uma chave de cache para o arquivo   */  protected generateCacheKey(file: File): string {    // Cria um identificador baseado no nome, tamanho e tipo do arquivo    return `${this.mediaType}_${file.name}_${file.size}_${file.type.replace('/', '_')}`;  }     /**   * Gera um ID único para o resultado do processamento   */  protected generateId(file: File): string {    return `${this.mediaType}_${uuidv4()}`;  }     /**   * Logs de início de processamento   */  protected logProcessingStart(file: File): void {    console.log(`Iniciando processamento de ${this.mediaType}: ${file.name} (${file.size} bytes)`);         this.monitoringService?.logEvent({      type: 'processing_start',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name    });  }     /**   * Logs de fim de processamento   */  protected logProcessingEnd(file: File, result: MediaProcessingResult): void {    console.log(`Processamento concluído para ${this.mediaType}: ${file.name}`);         this.monitoringService?.logEvent({      type: 'processing_complete',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name,      processingTime: new Date().getTime() - new Date(result.processedAt).getTime()    });  }     /**   * Logs de erro no processamento   */  protected logProcessingError(file: File, error: unknown): void {    console.error(`Erro no processamento de ${this.mediaType}: ${file.name}`, error);         this.monitoringService?.logEvent({      type: 'processing_error',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name,      error: error instanceof Error ? error.message : 'Erro desconhecido'    });  } }``

### src/services/media/MediaProcessor.ts

``import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { ImageProcessor } from './ImageProcessor'; import { AudioProcessor } from './AudioProcessor'; import { VideoProcessor } from './VideoProcessor'; import { MediaRecordService } from './MediaRecordService'; /**  * Serviço central para processamento de todos os tipos de mídia */ export class MediaProcessor {   private imageProcessor: ImageProcessor;  private audioProcessor: AudioProcessor;  private videoProcessor: VideoProcessor;  private recordService: MediaRecordService;  private cacheService?: CacheService<MediaProcessingResult>;  private monitoringService?: MonitoringService;     constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    this.cacheService = cacheService;    this.monitoringService = monitoringService;         // Inicializar processadores específicos    this.imageProcessor = new ImageProcessor(cacheService, monitoringService);    this.audioProcessor = new AudioProcessor(cacheService, monitoringService);    this.videoProcessor = new VideoProcessor(cacheService, monitoringService);    this.recordService = new MediaRecordService();  }     /**   * Processa um arquivo de mídia com base em seu tipo   * @param file Arquivo a ser processado   * @returns Resultado do processamento   */  async processFile(file: File): Promise<MediaProcessingResult> {    const fileType = this.detectFileType(file);         switch (fileType) {      case 'image':        return this.processImage(file);      case 'audio':        return this.processAudio(file);      case 'video':        return this.processVideo(file);      default:        throw new Error(`Tipo de arquivo não suportado: ${file.type}`);    }  }     /**   * Processa um arquivo de imagem   */  async processImage(file: File): Promise<MediaProcessingResult> {    return this.imageProcessor.process(file);  }     /**   * Processa um arquivo de áudio   */  async processAudio(file: File): Promise<MediaProcessingResult> {    return this.audioProcessor.process(file);  }     /**   * Processa um arquivo de vídeo   */  async processVideo(file: File): Promise<MediaProcessingResult> {    return this.videoProcessor.process(file);  }     /**   * Inicia a gravação de áudio   */  startAudioRecording(): Promise<{ stream: MediaStream }> {    return this.recordService.startAudioRecording();  }     /**   * Finaliza a gravação de áudio e retorna o arquivo   */  async stopAudioRecording(): Promise<{ file: File, url: string }> {    return this.recordService.stopAudioRecording();  }     /**   * Inicia a gravação de vídeo   */  startVideoRecording(): Promise<{ stream: MediaStream }> {    return this.recordService.startVideoRecording();  }     /**   * Finaliza a gravação de vídeo e retorna o arquivo   */  async stopVideoRecording(): Promise<{ file: File, url: string }> {    return this.recordService.stopVideoRecording();  }     /**   * Detecta o tipo de mídia com base no MIME type do arquivo   */  private detectFileType(file: File): 'image' | 'audio' | 'video' | 'unknown' {    const mimeType = file.type.toLowerCase();         if (mimeType.startsWith('image/')) {      return 'image';    } else if (mimeType.startsWith('audio/')) {      return 'audio';    } else if (mimeType.startsWith('video/')) {      return 'video';    } else {      // Tentar detectar pelo nome do arquivo se o MIME type não for conclusivo      const extension = file.name.split('.').pop()?.toLowerCase();             if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(extension || '')) {        return 'image';      } else if (['mp3', 'wav', 'ogg', 'aac', 'm4a'].includes(extension || '')) {        return 'audio';      } else if (['mp4', 'webm', 'ogv', 'mov', 'avi'].includes(extension || '')) {        return 'video';      }             return 'unknown';    }  }     /**   * Processa múltiplas mídias em paralelo   */  async processBatch(files: File[]): Promise<MediaProcessingResult[]> {    const promises = files.map(file => this.processFile(file));    return Promise.all(promises);  }     /**   * Cancela o processamento atual (se houver)   */  cancelProcessing(): void {    // Implementação depende de como os processadores lidam com cancelamento    this.recordService.cancelRecording();  } }``

### src/services/media/MediaRecordService.ts

``/**  * Serviço para gravação de áudio e vídeo através das APIs do navegador */ export class MediaRecordService {   private mediaRecorder: MediaRecorder | null = null;  private recordedChunks: Blob[] = [];  private mediaStream: MediaStream | null = null;     /**   * Inicia a gravação de áudio   * @returns Promise com o stream de mídia   */  async startAudioRecording(): Promise<{ stream: MediaStream }> {    try {      if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {        this.stopCurrentRecording();      }             const stream = await navigator.mediaDevices.getUserMedia({ audio: true });      this.setupRecording(stream);             return { stream };    } catch (error) {      console.error('Erro ao iniciar gravação de áudio:', error);      throw error;    }  }     /**   * Finaliza a gravação de áudio e retorna o arquivo   * @returns Promise com o arquivo de áudio e URL para reprodução   */  async stopAudioRecording(): Promise<{ file: File, url: string }> {    return this.stopCurrentRecording('audio');  }     /**   * Inicia a gravação de vídeo (com áudio)   * @returns Promise com o stream de mídia   */  async startVideoRecording(): Promise<{ stream: MediaStream }> {    try {      if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {        this.stopCurrentRecording();      }             const stream = await navigator.mediaDevices.getUserMedia({        audio: true,        video: {          width: { ideal: 1280 },          height: { ideal: 720 }        }      });      this.setupRecording(stream);             return { stream };    } catch (error) {      console.error('Erro ao iniciar gravação de vídeo:', error);      throw error;    }  }     /**   * Finaliza a gravação de vídeo e retorna o arquivo   * @returns Promise com o arquivo de vídeo e URL para reprodução   */  async stopVideoRecording(): Promise<{ file: File, url: string }> {    return this.stopCurrentRecording('video');  }     /**   * Cancela a gravação atual   */  cancelRecording(): void {    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {      this.mediaRecorder.stop();    }         this.cleanupResources();  }     /**   * Configura a gravação com um stream de mídia   */  private setupRecording(stream: MediaStream): void {    this.mediaStream = stream;    this.recordedChunks = [];         // Opções para o MediaRecorder - usar configurações de alta qualidade    const options = { mimeType: this.getSupportedMimeType() };         this.mediaRecorder = new MediaRecorder(stream, options);         this.mediaRecorder.ondataavailable = (event) => {      if (event.data.size > 0) {        this.recordedChunks.push(event.data);      }    };         this.mediaRecorder.start();  }     /**   * Finaliza a gravação atual e retorna o arquivo   */  private stopCurrentRecording(type: 'audio' | 'video' = 'audio'): Promise<{ file: File, url: string }> {    return new Promise((resolve, reject) => {      if (!this.mediaRecorder || this.mediaRecorder.state !== 'recording') {        reject(new Error('Nenhuma gravação em andamento'));        return;      }             this.mediaRecorder.onstop = () => {        try {          // Determinar o tipo MIME e extensão apropriados          const mimeType = this.mediaRecorder?.mimeType ||            (type === 'audio' ? 'audio/webm' : 'video/webm');                     const extension = mimeType.includes('mp4') ? 'mp4' : 'webm';                     // Criar o blob com todos os chunks gravados          const blob = new Blob(this.recordedChunks, { type: mimeType });          const url = URL.createObjectURL(blob);                     // Criar um nome de arquivo com timestamp          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');          const filename = `${type}-recording-${timestamp}.${extension}`;                     // Criar um objeto File          const file = new File([blob], filename, { type: mimeType });                     this.cleanupResources();          resolve({ file, url });        } catch (error) {          reject(error);        }      };             this.mediaRecorder.stop();    });  }     /**   * Limpa recursos utilizados na gravação   */  private cleanupResources(): void {    if (this.mediaStream) {      this.mediaStream.getTracks().forEach(track => track.stop());      this.mediaStream = null;    }         this.mediaRecorder = null;    this.recordedChunks = [];  }     /**   * Identifica um formato MIME suportado pelo navegador   */  private getSupportedMimeType(): string {    // Checar suporte para formatos comuns    const types = [      'video/webm;codecs=vp9,opus',      'video/webm;codecs=vp8,opus',      'video/webm',      'audio/webm;codecs=opus',      'audio/webm'    ];         for (const type of types) {      if (MediaRecorder.isTypeSupported(type)) {        return type;      }    }         // Fallback para formato padrão    return '';  } }``

### src/services/knowledge/KnowledgeService.ts

``import { ContentAnalyzer } from './analyzers/ContentAnalyzer'; import { KnowledgeExtractor } from './extractors/KnowledgeExtractor'; import { MetadataGenerator } from './generators/MetadataGenerator'; import { PromptGenerator } from './generators/PromptGenerator'; import { StructureGenerator } from './generators/StructureGenerator'; import { OutputValidator } from './validators/OutputValidator'; import { KnowledgeDocument } from '@/types/knowledge'; export class KnowledgeService {   private contentAnalyzer: ContentAnalyzer;  private knowledgeExtractor: KnowledgeExtractor;  private metadataGenerator: MetadataGenerator;  private promptGenerator: PromptGenerator;  private structureGenerator: StructureGenerator;  private outputValidator: OutputValidator;     constructor() {    this.contentAnalyzer = new ContentAnalyzer();    this.knowledgeExtractor = new KnowledgeExtractor();    this.metadataGenerator = new MetadataGenerator();    this.promptGenerator = new PromptGenerator();    this.structureGenerator = new StructureGenerator();    this.outputValidator = new OutputValidator();  }     /**   * Processa um documento para extrair conhecimento estruturado   * @param document Documento a ser processado   * @returns Documento com conhecimento estruturado   */  async processDocument(document: {    id: string;    title: string;    content: string;  }): Promise<KnowledgeDocument> {    console.log(`Processando documento: ${document.title}`);         // 1. Analisar conteúdo do documento    const analysis = await this.contentAnalyzer.analyze(document.content);         // 2. Extrair conhecimento do conteúdo    const knowledge = await this.knowledgeExtractor.extract(document.content, analysis);         // 3. Gerar estrutura do documento    const structure = await this.structureGenerator.generate(document.content, knowledge);         // 4. Gerar metadados    const metadata = await this.metadataGenerator.generate(document, knowledge, analysis);         // 5. Validar saída    const isValid = await this.outputValidator.validate(knowledge, structure);         if (!isValid) {      throw new Error('Falha na validação do conhecimento extraído');    }         // Criar documento final    const processedDocument: KnowledgeDocument = {      id: document.id,      title: document.title,      content: document.content,      analysis,      knowledge,      structure,      metadata,      processedAt: new Date().toISOString(),      valid: isValid    };         return processedDocument;  }     /**   * Gera prompts a partir de um documento processado   * @param document Documento processado   * @param options Opções de geração   * @returns Array de prompts gerados   */  async generatePrompts(    document: KnowledgeDocument,    options: { goal: string; context?: string; format?: string }  ): Promise<{    prompts: string[];    timeline: { id: string; description: string; prompt: string }[];  }> {    console.log(`Gerando prompts para documento: ${document.title}`);         return this.promptGenerator.generatePrompts(document, options);  }     /**   * Processa múltiplos documentos em batch   * @param documents Array de documentos   * @returns Array de documentos processados   */  async processBatch(documents: Array<{    id: string;    title: string;    content: string;  }>): Promise<KnowledgeDocument[]> {    const results = [];         for (const doc of documents) {      try {        const result = await this.processDocument(doc);        results.push(result);      } catch (error) {        console.error(`Erro ao processar documento ${doc.id}:`, error);        // Continuar com outros documentos mesmo em caso de erro      }    }         return results;  }     /**   * Atualiza um documento já processado   * @param document Documento a ser atualizado   * @returns Documento atualizado   */  async updateDocument(document: KnowledgeDocument): Promise<KnowledgeDocument> {    // Processar novamente se o conteúdo foi alterado    return this.processDocument({      id: document.id,      title: document.title,      content: document.content    });  }     /**   * Mescla conhecimento de múltiplos documentos   * @param documents Array de documentos processados   * @returns Conhecimento consolidado   */  async mergeKnowledge(documents: KnowledgeDocument[]): Promise<any> {    if (documents.length === 0) {      return {};    }         // Implementação básica: combinar conhecimento de todos os documentos    const combinedKnowledge = {      concepts: {} as Record<string, any>,      relationships: [] as any[],      references: [] as any[]    };         for (const doc of documents) {      // Mesclar conceitos      Object.entries(doc.knowledge.concepts || {}).forEach(([key, value]) => {        if (!combinedKnowledge.concepts[key]) {          combinedKnowledge.concepts[key] = value;        } else {          // Mesclar propriedades de conceitos existentes          combinedKnowledge.concepts[key] = {            ...combinedKnowledge.concepts[key],            ...value,            sources: [              ...(combinedKnowledge.concepts[key].sources || []),              ...(value.sources || [])            ]          };        }      });             // Adicionar relacionamentos      if (doc.knowledge.relationships) {        combinedKnowledge.relationships.push(...doc.knowledge.relationships);      }             // Adicionar referências      if (doc.knowledge.references) {        combinedKnowledge.references.push(...doc.knowledge.references);      }    }         return combinedKnowledge;  } }``

### src/services/knowledge/analyzers/ContentAnalyzer.ts

``import { LLMService } from '@/services/llm/LLMService'; import { ComplexityAnalyzer } from '../generators/analyzers/ComplexityAnalyzer'; export class ContentAnalyzer {   private llmService: LLMService;  private complexityAnalyzer: ComplexityAnalyzer;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });    this.complexityAnalyzer = new ComplexityAnalyzer();  }     /**   * Analisa o conteúdo de um documento   * @param content Conteúdo do documento   * @returns Resultado da análise   */  async analyze(content: string): Promise<{    summary: string;    topics: string[];    entities: Array<{ name: string; type: string; relevance: number }>;    sentiment: { positive: number; negative: number; neutral: number };    complexity: { score: number; readability: string };    language: string;    format: string;  }> {    // 1. Analisar complexidade do texto    const complexity = await this.complexityAnalyzer.analyze(content);         // 2. Extrair entidades e tópicos usando LLM    const entities = await this.extractEntities(content);    const topics = await this.extractTopics(content);         // 3. Gerar resumo do conteúdo    const summary = await this.generateSummary(content);         // 4. Analisar sentimento do texto    const sentiment = await this.analyzeSentiment(content);         // 5. Detectar idioma e formato    const language = this.detectLanguage(content);    const format = this.detectFormat(content);         return {      summary,      topics,      entities,      sentiment,      complexity,      language,      format    };  }     /**   * Extrai entidades do conteúdo usando LLM   */  private async extractEntities(content: string): Promise<Array<{    name: string;    type: string;    relevance: number  }>> {    const promptEntities = `    Analise o seguinte texto e extraia as entidades (pessoas, organizações, lugares, conceitos, etc.)    mencionadas. Para cada entidade, identifique o tipo e um score de relevância de 0 a 1.         Texto:    ${content.substring(0, 2000)}... (texto truncado)         Formato de resposta:    [      {"name": "nome da entidade", "type": "tipo", "relevance": score},      ...    ]    `;         try {      const response = await this.llmService.generateCompletion(promptEntities, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });             // Tentar extrair JSON da resposta      const jsonMatch = response.match(/\[\s*\{.*\}\s*\]/s);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de entidades inesperado');      return [];    } catch (error) {      console.error('Erro ao extrair entidades:', error);      return [];    }  }     /**   * Extrai tópicos principais do conteúdo   */  private async extractTopics(content: string): Promise<string[]> {    const promptTopics = `    Analise o seguinte texto e identifique os 5-10 tópicos principais que são abordados.    Retorne apenas os tópicos como uma lista de strings, sem numeração ou explicações adicionais.         Texto:    ${content.substring(0, 2000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(promptTopics, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 500      });             // Extrair lista de tópicos      const topics = response        .split('\n')        .map(line => line.replace(/^[-*•\s\d.]+/, '').trim())        .filter(Boolean);             return topics;    } catch (error) {      console.error('Erro ao extrair tópicos:', error);      return [];    }  }     /**   * Gera um resumo do conteúdo   */  private async generateSummary(content: string): Promise<string> {    const promptSummary = `    Crie um resumo conciso (máximo 200 palavras) do seguinte texto,    destacando os pontos principais e as informações mais relevantes:         ${content.substring(0, 3000)}... (texto truncado)    `;         try {      return await this.llmService.generateCompletion(promptSummary, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 300      });    } catch (error) {      console.error('Erro ao gerar resumo:', error);      return 'Não foi possível gerar um resumo para este conteúdo.';    }  }     /**   * Analisa o sentimento do texto   */  private async analyzeSentiment(content: string): Promise<{    positive: number;    negative: number;    neutral: number  }> {    const promptSentiment = `    Analise o sentimento do seguinte texto e forneça uma pontuação para:    - Positivo (0-1)    - Negativo (0-1)    - Neutro (0-1)    A soma deve ser aproximadamente 1.         Texto:    ${content.substring(0, 1500)}... (texto truncado)         Responda apenas com os números no formato: positive negative neutral    `;         try {      const response = await this.llmService.generateCompletion(promptSentiment, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.1,        maxTokens: 100      });             const match = response.match(/(\d+(\.\d+)?)\s+(\d+(\.\d+)?)\s+(\d+(\.\d+)?)/);      if (match) {        return {          positive: parseFloat(match[1]),          negative: parseFloat(match[3]),          neutral: parseFloat(match[5])        };      }             // Fallback para análise neutra      return { positive: 0.2, negative: 0.2, neutral: 0.6 };    } catch (error) {      console.error('Erro ao analisar sentimento:', error);      return { positive: 0.33, negative: 0.33, neutral: 0.34 };    }  }     /**   * Detecta o idioma do texto   */  private detectLanguage(content: string): string {    // Implementação simplificada - em produção, usar um detector de idioma mais robusto    const sample = content.substring(0, 200).toLowerCase();         // Detectar por palavras comuns    const languages: Record<string, string[]> = {      'pt-BR': ['de', 'e', 'que', 'o', 'a', 'para', 'com', 'um', 'uma', 'em'],      'en': ['the', 'and', 'of', 'to', 'a', 'in', 'that', 'is', 'for', 'it'],      'es': ['de', 'la', 'el', 'en', 'y', 'a', 'que', 'los', 'se', 'un']    };         const scores = Object.entries(languages).map(([lang, words]) => {      const score = words.reduce((count, word) => {        const regex = new RegExp(`\\b${word}\\b`, 'g');        const matches = sample.match(regex);        return count + (matches ? matches.length : 0);      }, 0);      return { lang, score };    });         // Ordenar por pontuação    scores.sort((a, b) => b.score - a.score);         return scores[0].score > 0 ? scores[0].lang : 'pt-BR'; // Default para português  }     /**   * Detecta o formato do conteúdo (Markdown, texto simples, etc.)   */  private detectFormat(content: string): string {    // Verificar presença de marcadores de Markdown    const markdownPatterns = [      /^#+ /m,                    // Títulos      /\[.+\]\(.+\)/,             // Links      /\*\*.+\*\*/,               // Negrito      /\*.+\*/,                   // Itálico      /```[\s\S]+?```/,           // Blocos de código      /^\s*[*-] /m,               // Listas      /^\s*\d+\. /m,              // Listas numeradas      /\|.+\|.+\|/,               // Tabelas      /!\[.+\]\(.+\)/             // Imagens    ];         const markdownScore = markdownPatterns.reduce((count, pattern) => {      return count + (pattern.test(content) ? 1 : 0);    }, 0);         if (markdownScore >= 2) {      return 'markdown';    }         // Verificar se pode ser HTML    if (/<[a-z][\s\S]*>/i.test(content)) {      return 'html';    }         // Default para texto simples    return 'text';  } }``

### src/hooks/useFileUpload.ts

``import { useState, useCallback } from 'react'; import { toast } from 'sonner'; interface UseFileUploadOptions {   maxSize: number;  multiple: boolean;  acceptedTypes?: string[];  onFileUpload: (file: File) => void; } export const useFileUpload = ({   maxSize,  multiple,  acceptedTypes = [],  onFileUpload }: UseFileUploadOptions) => {   const [files, setFiles] = useState<File[]>([]);  const [uploadProgress, setUploadProgress] = useState<number>(0);  const [isUploading, setIsUploading] = useState<boolean>(false);     // Verificar tipo de arquivo  const isAcceptedType = (file: File): boolean => {    if (acceptedTypes.length === 0) return true;         return acceptedTypes.some(type => {      if (type.includes('*')) {        // Para tipos como 'image/*'        const mainType = type.split('/')[0];        return file.type.startsWith(`${mainType}/`);      }      return file.type === type;    });  };     // Manipular queda de arquivos  const handleFileDrop = useCallback((acceptedFiles: File[]) => {    // Verificar tamanhos dos arquivos    const oversizedFiles = acceptedFiles.filter(file => file.size > maxSize * 1024 * 1024);    if (oversizedFiles.length > 0) {      toast.error(`Arquivo(s) muito grande(s)`, {        description: `O tamanho máximo permitido é ${maxSize}MB.`      });      return;    }         // Verificar tipos de arquivos    const invalidTypeFiles = acceptedFiles.filter(file => !isAcceptedType(file));    if (invalidTypeFiles.length > 0) {      toast.error(`Tipo(s) de arquivo não suportado(s)`, {        description: `Apenas ${acceptedTypes.join(', ')} são permitidos.`      });      return;    }         if (!multiple && acceptedFiles.length > 0) {      setFiles([acceptedFiles[0]]);      simulateUpload(acceptedFiles[0]);    } else {      setFiles(prev => [...prev, ...acceptedFiles]);      if (acceptedFiles.length > 0) {        simulateUpload(acceptedFiles[0]);      }    }  }, [maxSize, multiple, acceptedTypes, onFileUpload]);     // Simular progresso de upload  const simulateUpload = (file: File) => {    setIsUploading(true);    setUploadProgress(0);         const interval = setInterval(() => {      setUploadProgress(prev => {        if (prev >= 100) {          clearInterval(interval);          setIsUploading(false);          onFileUpload(file);          return 100;        }        return prev + 5;      });    }, 100);  };     // Remover um arquivo  const removeFile = (index: number) => {    setFiles(prev => prev.filter((_, i) => i !== index));  };     // Limpar todos os arquivos  const clearFiles = () => {    setFiles([]);    setUploadProgress(0);    setIsUploading(false);  };     // Processar todos os arquivos  const processFiles = () => {    files.forEach(file => onFileUpload(file));  };     return {    files,    uploadProgress,    isUploading,    handleFileDrop,    removeFile,    clearFiles,    processFiles  }; };``


### src/services/media/BaseMediaProcessor.ts

``import { MediaProcessingResult } from '../../types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { v4 as uuidv4 } from 'uuid'; export abstract class BaseMediaProcessor {   protected mediaType: string;  protected cacheService?: CacheService<MediaProcessingResult>;  protected monitoringService?: MonitoringService;     constructor(    mediaType: string,    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    this.mediaType = mediaType;    this.cacheService = cacheService;    this.monitoringService = monitoringService;  }     /**   * Processa um arquivo de mídia   * @param file Arquivo a ser processado   */  abstract process(file: File): Promise<MediaProcessingResult>;     /**   * Verifica se existe um resultado em cache para o arquivo   */  protected async checkCache(file: File): Promise<MediaProcessingResult | null> {    if (!this.cacheService) {      return null;    }         const fileKey = this.generateCacheKey(file);    const cachedResult = await this.cacheService.get(fileKey);         if (cachedResult) {      this.monitoringService?.logEvent({        type: 'cache_hit',        mediaType: this.mediaType,        fileSize: file.size,        fileName: file.name      });    }         return cachedResult;  }     /**   * Salva um resultado no cache   */  protected async saveToCache(file: File, result: MediaProcessingResult): Promise<void> {    if (!this.cacheService) {      return;    }         const fileKey = this.generateCacheKey(file);    await this.cacheService.set(fileKey, result);  }     /**   * Gera uma chave de cache para o arquivo   */  protected generateCacheKey(file: File): string {    // Cria um identificador baseado no nome, tamanho e tipo do arquivo    return `${this.mediaType}_${file.name}_${file.size}_${file.type.replace('/', '_')}`;  }     /**   * Gera um ID único para o resultado do processamento   */  protected generateId(file: File): string {    return `${this.mediaType}_${uuidv4()}`;  }     /**   * Logs de início de processamento   */  protected logProcessingStart(file: File): void {    console.log(`Iniciando processamento de ${this.mediaType}: ${file.name} (${file.size} bytes)`);         this.monitoringService?.logEvent({      type: 'processing_start',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name    });  }     /**   * Logs de fim de processamento   */  protected logProcessingEnd(file: File, result: MediaProcessingResult): void {    console.log(`Processamento concluído para ${this.mediaType}: ${file.name}`);         this.monitoringService?.logEvent({      type: 'processing_complete',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name,      processingTime: new Date().getTime() - new Date(result.processedAt).getTime()    });  }     /**   * Logs de erro no processamento   */  protected logProcessingError(file: File, error: unknown): void {    console.error(`Erro no processamento de ${this.mediaType}: ${file.name}`, error);         this.monitoringService?.logEvent({      type: 'processing_error',      mediaType: this.mediaType,      fileSize: file.size,      fileName: file.name,      error: error instanceof Error ? error.message : 'Erro desconhecido'    });  } }``

### src/services/media/MediaProcessor.ts

``import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult } from '../../types/media'; import { ImageProcessor } from './ImageProcessor'; import { AudioProcessor } from './AudioProcessor'; import { VideoProcessor } from './VideoProcessor'; import { MediaRecordService } from './MediaRecordService'; /**  * Serviço central para processamento de todos os tipos de mídia */ export class MediaProcessor {   private imageProcessor: ImageProcessor;  private audioProcessor: AudioProcessor;  private videoProcessor: VideoProcessor;  private recordService: MediaRecordService;  private cacheService?: CacheService<MediaProcessingResult>;  private monitoringService?: MonitoringService;     constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    this.cacheService = cacheService;    this.monitoringService = monitoringService;         // Inicializar processadores específicos    this.imageProcessor = new ImageProcessor(cacheService, monitoringService);    this.audioProcessor = new AudioProcessor(cacheService, monitoringService);    this.videoProcessor = new VideoProcessor(cacheService, monitoringService);    this.recordService = new MediaRecordService();  }     /**   * Processa um arquivo de mídia com base em seu tipo   * @param file Arquivo a ser processado   * @returns Resultado do processamento   */  async processFile(file: File): Promise<MediaProcessingResult> {    const fileType = this.detectFileType(file);         switch (fileType) {      case 'image':        return this.processImage(file);      case 'audio':        return this.processAudio(file);      case 'video':        return this.processVideo(file);      default:        throw new Error(`Tipo de arquivo não suportado: ${file.type}`);    }  }     /**   * Processa um arquivo de imagem   */  async processImage(file: File): Promise<MediaProcessingResult> {    return this.imageProcessor.process(file);  }     /**   * Processa um arquivo de áudio   */  async processAudio(file: File): Promise<MediaProcessingResult> {    return this.audioProcessor.process(file);  }     /**   * Processa um arquivo de vídeo   */  async processVideo(file: File): Promise<MediaProcessingResult> {    return this.videoProcessor.process(file);  }     /**   * Inicia a gravação de áudio   */  startAudioRecording(): Promise<{ stream: MediaStream }> {    return this.recordService.startAudioRecording();  }     /**   * Finaliza a gravação de áudio e retorna o arquivo   */  async stopAudioRecording(): Promise<{ file: File, url: string }> {    return this.recordService.stopAudioRecording();  }     /**   * Inicia a gravação de vídeo   */  startVideoRecording(): Promise<{ stream: MediaStream }> {    return this.recordService.startVideoRecording();  }     /**   * Finaliza a gravação de vídeo e retorna o arquivo   */  async stopVideoRecording(): Promise<{ file: File, url: string }> {    return this.recordService.stopVideoRecording();  }     /**   * Detecta o tipo de mídia com base no MIME type do arquivo   */  private detectFileType(file: File): 'image' | 'audio' | 'video' | 'unknown' {    const mimeType = file.type.toLowerCase();         if (mimeType.startsWith('image/')) {      return 'image';    } else if (mimeType.startsWith('audio/')) {      return 'audio';    } else if (mimeType.startsWith('video/')) {      return 'video';    } else {      // Tentar detectar pelo nome do arquivo se o MIME type não for conclusivo      const extension = file.name.split('.').pop()?.toLowerCase();             if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(extension || '')) {        return 'image';      } else if (['mp3', 'wav', 'ogg', 'aac', 'm4a'].includes(extension || '')) {        return 'audio';      } else if (['mp4', 'webm', 'ogv', 'mov', 'avi'].includes(extension || '')) {        return 'video';      }             return 'unknown';    }  }     /**   * Processa múltiplas mídias em paralelo   */  async processBatch(files: File[]): Promise<MediaProcessingResult[]> {    const promises = files.map(file => this.processFile(file));    return Promise.all(promises);  }     /**   * Cancela o processamento atual (se houver)   */  cancelProcessing(): void {    // Implementação depende de como os processadores lidam com cancelamento    this.recordService.cancelRecording();  } }``

### src/services/media/MediaRecordService.ts

``/**  * Serviço para gravação de áudio e vídeo através das APIs do navegador */ export class MediaRecordService {   private mediaRecorder: MediaRecorder | null = null;  private recordedChunks: Blob[] = [];  private mediaStream: MediaStream | null = null;     /**   * Inicia a gravação de áudio   * @returns Promise com o stream de mídia   */  async startAudioRecording(): Promise<{ stream: MediaStream }> {    try {      if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {        this.stopCurrentRecording();      }             const stream = await navigator.mediaDevices.getUserMedia({ audio: true });      this.setupRecording(stream);             return { stream };    } catch (error) {      console.error('Erro ao iniciar gravação de áudio:', error);      throw error;    }  }     /**   * Finaliza a gravação de áudio e retorna o arquivo   * @returns Promise com o arquivo de áudio e URL para reprodução   */  async stopAudioRecording(): Promise<{ file: File, url: string }> {    return this.stopCurrentRecording('audio');  }     /**   * Inicia a gravação de vídeo (com áudio)   * @returns Promise com o stream de mídia   */  async startVideoRecording(): Promise<{ stream: MediaStream }> {    try {      if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {        this.stopCurrentRecording();      }             const stream = await navigator.mediaDevices.getUserMedia({        audio: true,        video: {          width: { ideal: 1280 },          height: { ideal: 720 }        }      });      this.setupRecording(stream);             return { stream };    } catch (error) {      console.error('Erro ao iniciar gravação de vídeo:', error);      throw error;    }  }     /**   * Finaliza a gravação de vídeo e retorna o arquivo   * @returns Promise com o arquivo de vídeo e URL para reprodução   */  async stopVideoRecording(): Promise<{ file: File, url: string }> {    return this.stopCurrentRecording('video');  }     /**   * Cancela a gravação atual   */  cancelRecording(): void {    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {      this.mediaRecorder.stop();    }         this.cleanupResources();  }     /**   * Configura a gravação com um stream de mídia   */  private setupRecording(stream: MediaStream): void {    this.mediaStream = stream;    this.recordedChunks = [];         // Opções para o MediaRecorder - usar configurações de alta qualidade    const options = { mimeType: this.getSupportedMimeType() };         this.mediaRecorder = new MediaRecorder(stream, options);         this.mediaRecorder.ondataavailable = (event) => {      if (event.data.size > 0) {        this.recordedChunks.push(event.data);      }    };         this.mediaRecorder.start();  }     /**   * Finaliza a gravação atual e retorna o arquivo   */  private stopCurrentRecording(type: 'audio' | 'video' = 'audio'): Promise<{ file: File, url: string }> {    return new Promise((resolve, reject) => {      if (!this.mediaRecorder || this.mediaRecorder.state !== 'recording') {        reject(new Error('Nenhuma gravação em andamento'));        return;      }             this.mediaRecorder.onstop = () => {        try {          // Determinar o tipo MIME e extensão apropriados          const mimeType = this.mediaRecorder?.mimeType ||            (type === 'audio' ? 'audio/webm' : 'video/webm');                     const extension = mimeType.includes('mp4') ? 'mp4' : 'webm';                     // Criar o blob com todos os chunks gravados          const blob = new Blob(this.recordedChunks, { type: mimeType });          const url = URL.createObjectURL(blob);                     // Criar um nome de arquivo com timestamp          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');          const filename = `${type}-recording-${timestamp}.${extension}`;                     // Criar um objeto File          const file = new File([blob], filename, { type: mimeType });                     this.cleanupResources();          resolve({ file, url });        } catch (error) {          reject(error);        }      };             this.mediaRecorder.stop();    });  }     /**   * Limpa recursos utilizados na gravação   */  private cleanupResources(): void {    if (this.mediaStream) {      this.mediaStream.getTracks().forEach(track => track.stop());      this.mediaStream = null;    }         this.mediaRecorder = null;    this.recordedChunks = [];  }     /**   * Identifica um formato MIME suportado pelo navegador   */  private getSupportedMimeType(): string {    // Checar suporte para formatos comuns    const types = [      'video/webm;codecs=vp9,opus',      'video/webm;codecs=vp8,opus',      'video/webm',      'audio/webm;codecs=opus',      'audio/webm'    ];         for (const type of types) {      if (MediaRecorder.isTypeSupported(type)) {        return type;      }    }         // Fallback para formato padrão    return '';  } }``

### src/services/knowledge/KnowledgeService.ts

``import { ContentAnalyzer } from './analyzers/ContentAnalyzer'; import { KnowledgeExtractor } from './extractors/KnowledgeExtractor'; import { MetadataGenerator } from './generators/MetadataGenerator'; import { PromptGenerator } from './generators/PromptGenerator'; import { StructureGenerator } from './generators/StructureGenerator'; import { OutputValidator } from './validators/OutputValidator'; import { KnowledgeDocument } from '@/types/knowledge'; export class KnowledgeService {   private contentAnalyzer: ContentAnalyzer;  private knowledgeExtractor: KnowledgeExtractor;  private metadataGenerator: MetadataGenerator;  private promptGenerator: PromptGenerator;  private structureGenerator: StructureGenerator;  private outputValidator: OutputValidator;     constructor() {    this.contentAnalyzer = new ContentAnalyzer();    this.knowledgeExtractor = new KnowledgeExtractor();    this.metadataGenerator = new MetadataGenerator();    this.promptGenerator = new PromptGenerator();    this.structureGenerator = new StructureGenerator();    this.outputValidator = new OutputValidator();  }     /**   * Processa um documento para extrair conhecimento estruturado   * @param document Documento a ser processado   * @returns Documento com conhecimento estruturado   */  async processDocument(document: {    id: string;    title: string;    content: string;  }): Promise<KnowledgeDocument> {    console.log(`Processando documento: ${document.title}`);         // 1. Analisar conteúdo do documento    const analysis = await this.contentAnalyzer.analyze(document.content);         // 2. Extrair conhecimento do conteúdo    const knowledge = await this.knowledgeExtractor.extract(document.content, analysis);         // 3. Gerar estrutura do documento    const structure = await this.structureGenerator.generate(document.content, knowledge);         // 4. Gerar metadados    const metadata = await this.metadataGenerator.generate(document, knowledge, analysis);         // 5. Validar saída    const isValid = await this.outputValidator.validate(knowledge, structure);         if (!isValid) {      throw new Error('Falha na validação do conhecimento extraído');    }         // Criar documento final    const processedDocument: KnowledgeDocument = {      id: document.id,      title: document.title,      content: document.content,      analysis,      knowledge,      structure,      metadata,      processedAt: new Date().toISOString(),      valid: isValid    };         return processedDocument;  }     /**   * Gera prompts a partir de um documento processado   * @param document Documento processado   * @param options Opções de geração   * @returns Array de prompts gerados   */  async generatePrompts(    document: KnowledgeDocument,    options: { goal: string; context?: string; format?: string }  ): Promise<{    prompts: string[];    timeline: { id: string; description: string; prompt: string }[];  }> {    console.log(`Gerando prompts para documento: ${document.title}`);         return this.promptGenerator.generatePrompts(document, options);  }     /**   * Processa múltiplos documentos em batch   * @param documents Array de documentos   * @returns Array de documentos processados   */  async processBatch(documents: Array<{    id: string;    title: string;    content: string;  }>): Promise<KnowledgeDocument[]> {    const results = [];         for (const doc of documents) {      try {        const result = await this.processDocument(doc);        results.push(result);      } catch (error) {        console.error(`Erro ao processar documento ${doc.id}:`, error);        // Continuar com outros documentos mesmo em caso de erro      }    }         return results;  }     /**   * Atualiza um documento já processado   * @param document Documento a ser atualizado   * @returns Documento atualizado   */  async updateDocument(document: KnowledgeDocument): Promise<KnowledgeDocument> {    // Processar novamente se o conteúdo foi alterado    return this.processDocument({      id: document.id,      title: document.title,      content: document.content    });  }     /**   * Mescla conhecimento de múltiplos documentos   * @param documents Array de documentos processados   * @returns Conhecimento consolidado   */  async mergeKnowledge(documents: KnowledgeDocument[]): Promise<any> {    if (documents.length === 0) {      return {};    }         // Implementação básica: combinar conhecimento de todos os documentos    const combinedKnowledge = {      concepts: {} as Record<string, any>,      relationships: [] as any[],      references: [] as any[]    };         for (const doc of documents) {      // Mesclar conceitos      Object.entries(doc.knowledge.concepts || {}).forEach(([key, value]) => {        if (!combinedKnowledge.concepts[key]) {          combinedKnowledge.concepts[key] = value;        } else {          // Mesclar propriedades de conceitos existentes          combinedKnowledge.concepts[key] = {            ...combinedKnowledge.concepts[key],            ...value,            sources: [              ...(combinedKnowledge.concepts[key].sources || []),              ...(value.sources || [])            ]          };        }      });             // Adicionar relacionamentos      if (doc.knowledge.relationships) {        combinedKnowledge.relationships.push(...doc.knowledge.relationships);      }             // Adicionar referências      if (doc.knowledge.references) {        combinedKnowledge.references.push(...doc.knowledge.references);      }    }         return combinedKnowledge;  } }``

### src/services/knowledge/analyzers/ContentAnalyzer.ts

``import { LLMService } from '@/services/llm/LLMService'; import { ComplexityAnalyzer } from '../generators/analyzers/ComplexityAnalyzer'; export class ContentAnalyzer {   private llmService: LLMService;  private complexityAnalyzer: ComplexityAnalyzer;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });    this.complexityAnalyzer = new ComplexityAnalyzer();  }     /**   * Analisa o conteúdo de um documento   * @param content Conteúdo do documento   * @returns Resultado da análise   */  async analyze(content: string): Promise<{    summary: string;    topics: string[];    entities: Array<{ name: string; type: string; relevance: number }>;    sentiment: { positive: number; negative: number; neutral: number };    complexity: { score: number; readability: string };    language: string;    format: string;  }> {    // 1. Analisar complexidade do texto    const complexity = await this.complexityAnalyzer.analyze(content);         // 2. Extrair entidades e tópicos usando LLM    const entities = await this.extractEntities(content);    const topics = await this.extractTopics(content);         // 3. Gerar resumo do conteúdo    const summary = await this.generateSummary(content);         // 4. Analisar sentimento do texto    const sentiment = await this.analyzeSentiment(content);         // 5. Detectar idioma e formato    const language = this.detectLanguage(content);    const format = this.detectFormat(content);         return {      summary,      topics,      entities,      sentiment,      complexity,      language,      format    };  }     /**   * Extrai entidades do conteúdo usando LLM   */  private async extractEntities(content: string): Promise<Array<{    name: string;    type: string;    relevance: number  }>> {    const promptEntities = `    Analise o seguinte texto e extraia as entidades (pessoas, organizações, lugares, conceitos, etc.)    mencionadas. Para cada entidade, identifique o tipo e um score de relevância de 0 a 1.         Texto:    ${content.substring(0, 2000)}... (texto truncado)         Formato de resposta:    [      {"name": "nome da entidade", "type": "tipo", "relevance": score},      ...    ]    `;         try {      const response = await this.llmService.generateCompletion(promptEntities, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });             // Tentar extrair JSON da resposta      const jsonMatch = response.match(/\[\s*\{.*\}\s*\]/s);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de entidades inesperado');      return [];    } catch (error) {      console.error('Erro ao extrair entidades:', error);      return [];    }  }     /**   * Extrai tópicos principais do conteúdo   */  private async extractTopics(content: string): Promise<string[]> {    const promptTopics = `    Analise o seguinte texto e identifique os 5-10 tópicos principais que são abordados.    Retorne apenas os tópicos como uma lista de strings, sem numeração ou explicações adicionais.         Texto:    ${content.substring(0, 2000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(promptTopics, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 500      });             // Extrair lista de tópicos      const topics = response        .split('\n')        .map(line => line.replace(/^[-*•\s\d.]+/, '').trim())        .filter(Boolean);             return topics;    } catch (error) {      console.error('Erro ao extrair tópicos:', error);      return [];    }  }     /**   * Gera um resumo do conteúdo   */  private async generateSummary(content: string): Promise<string> {    const promptSummary = `    Crie um resumo conciso (máximo 200 palavras) do seguinte texto,    destacando os pontos principais e as informações mais relevantes:         ${content.substring(0, 3000)}... (texto truncado)    `;         try {      return await this.llmService.generateCompletion(promptSummary, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 300      });    } catch (error) {      console.error('Erro ao gerar resumo:', error);      return 'Não foi possível gerar um resumo para este conteúdo.';    }  }     /**   * Analisa o sentimento do texto   */  private async analyzeSentiment(content: string): Promise<{    positive: number;    negative: number;    neutral: number  }> {    const promptSentiment = `    Analise o sentimento do seguinte texto e forneça uma pontuação para:    - Positivo (0-1)    - Negativo (0-1)    - Neutro (0-1)    A soma deve ser aproximadamente 1.         Texto:    ${content.substring(0, 1500)}... (texto truncado)         Responda apenas com os números no formato: positive negative neutral    `;         try {      const response = await this.llmService.generateCompletion(promptSentiment, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.1,        maxTokens: 100      });             const match = response.match(/(\d+(\.\d+)?)\s+(\d+(\.\d+)?)\s+(\d+(\.\d+)?)/);      if (match) {        return {          positive: parseFloat(match[1]),          negative: parseFloat(match[3]),          neutral: parseFloat(match[5])        };      }             // Fallback para análise neutra      return { positive: 0.2, negative: 0.2, neutral: 0.6 };    } catch (error) {      console.error('Erro ao analisar sentimento:', error);      return { positive: 0.33, negative: 0.33, neutral: 0.34 };    }  }     /**   * Detecta o idioma do texto   */  private detectLanguage(content: string): string {    // Implementação simplificada - em produção, usar um detector de idioma mais robusto    const sample = content.substring(0, 200).toLowerCase();         // Detectar por palavras comuns    const languages: Record<string, string[]> = {      'pt-BR': ['de', 'e', 'que', 'o', 'a', 'para', 'com', 'um', 'uma', 'em'],      'en': ['the', 'and', 'of', 'to', 'a', 'in', 'that', 'is', 'for', 'it'],      'es': ['de', 'la', 'el', 'en', 'y', 'a', 'que', 'los', 'se', 'un']    };         const scores = Object.entries(languages).map(([lang, words]) => {      const score = words.reduce((count, word) => {        const regex = new RegExp(`\\b${word}\\b`, 'g');        const matches = sample.match(regex);        return count + (matches ? matches.length : 0);      }, 0);      return { lang, score };    });         // Ordenar por pontuação    scores.sort((a, b) => b.score - a.score);         return scores[0].score > 0 ? scores[0].lang : 'pt-BR'; // Default para português  }     /**   * Detecta o formato do conteúdo (Markdown, texto simples, etc.)   */  private detectFormat(content: string): string {    // Verificar presença de marcadores de Markdown    const markdownPatterns = [      /^#+ /m,                    // Títulos      /\[.+\]\(.+\)/,             // Links      /\*\*.+\*\*/,               // Negrito      /\*.+\*/,                   // Itálico      /```[\s\S]+?```/,           // Blocos de código      /^\s*[*-] /m,               // Listas      /^\s*\d+\. /m,              // Listas numeradas      /\|.+\|.+\|/,               // Tabelas      /!\[.+\]\(.+\)/             // Imagens    ];         const markdownScore = markdownPatterns.reduce((count, pattern) => {      return count + (pattern.test(content) ? 1 : 0);    }, 0);         if (markdownScore >= 2) {      return 'markdown';    }         // Verificar se pode ser HTML    if (/<[a-z][\s\S]*>/i.test(content)) {      return 'html';    }         // Default para texto simples    return 'text';  } }``

### src/hooks/useFileUpload.ts

``import { useState, useCallback } from 'react'; import { toast } from 'sonner'; interface UseFileUploadOptions {   maxSize: number;  multiple: boolean;  acceptedTypes?: string[];  onFileUpload: (file: File) => void; } export const useFileUpload = ({   maxSize,  multiple,  acceptedTypes = [],  onFileUpload }: UseFileUploadOptions) => {   const [files, setFiles] = useState<File[]>([]);  const [uploadProgress, setUploadProgress] = useState<number>(0);  const [isUploading, setIsUploading] = useState<boolean>(false);     // Verificar tipo de arquivo  const isAcceptedType = (file: File): boolean => {    if (acceptedTypes.length === 0) return true;         return acceptedTypes.some(type => {      if (type.includes('*')) {        // Para tipos como 'image/*'        const mainType = type.split('/')[0];        return file.type.startsWith(`${mainType}/`);      }      return file.type === type;    });  };     // Manipular queda de arquivos  const handleFileDrop = useCallback((acceptedFiles: File[]) => {    // Verificar tamanhos dos arquivos    const oversizedFiles = acceptedFiles.filter(file => file.size > maxSize * 1024 * 1024);    if (oversizedFiles.length > 0) {      toast.error(`Arquivo(s) muito grande(s)`, {        description: `O tamanho máximo permitido é ${maxSize}MB.`      });      return;    }         // Verificar tipos de arquivos    const invalidTypeFiles = acceptedFiles.filter(file => !isAcceptedType(file));    if (invalidTypeFiles.length > 0) {      toast.error(`Tipo(s) de arquivo não suportado(s)`, {        description: `Apenas ${acceptedTypes.join(', ')} são permitidos.`      });      return;    }         if (!multiple && acceptedFiles.length > 0) {      setFiles([acceptedFiles[0]]);      simulateUpload(acceptedFiles[0]);    } else {      setFiles(prev => [...prev, ...acceptedFiles]);      if (acceptedFiles.length > 0) {        simulateUpload(acceptedFiles[0]);      }    }  }, [maxSize, multiple, acceptedTypes, onFileUpload]);     // Simular progresso de upload  const simulateUpload = (file: File) => {    setIsUploading(true);    setUploadProgress(0);         const interval = setInterval(() => {      setUploadProgress(prev => {        if (prev >= 100) {          clearInterval(interval);          setIsUploading(false);          onFileUpload(file);          return 100;        }        return prev + 5;      });    }, 100);  };     // Remover um arquivo  const removeFile = (index: number) => {    setFiles(prev => prev.filter((_, i) => i !== index));  };     // Limpar todos os arquivos  const clearFiles = () => {    setFiles([]);    setUploadProgress(0);    setIsUploading(false);  };     // Processar todos os arquivos  const processFiles = () => {    files.forEach(file => onFileUpload(file));  };     return {    files,    uploadProgress,    isUploading,    handleFileDrop,    removeFile,    clearFiles,    processFiles  }; };``


### src/services/knowledge/extractors/KnowledgeExtractor.ts

``import { LLMService } from '@/services/llm/LLMService'; import { SummaryExtractor } from './SummaryExtractor'; export class KnowledgeExtractor {   private llmService: LLMService;  private summaryExtractor: SummaryExtractor;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });    this.summaryExtractor = new SummaryExtractor();  }     /**   * Extrai conhecimento estruturado de um documento   * @param content Conteúdo do documento   * @param analysis Análise prévia do conteúdo   * @returns Conhecimento estruturado   */  async extract(content: string, analysis: any): Promise<{    concepts: Record<string, any>;    relationships: Array<{      source: string;      target: string;      type: string;      description?: string;    }>;    references?: Array<{      id: string;      type: string;      description: string;      url?: string;    }>;  }> {    console.log('Extraindo conhecimento do documento');         // 1. Extrair conceitos principais    const concepts = await this.extractConcepts(content, analysis);         // 2. Identificar relacionamentos entre conceitos    const relationships = await this.extractRelationships(content, concepts);         // 3. Extrair referências citadas no documento    const references = await this.extractReferences(content);         return {      concepts,      relationships,      references    };  }     /**   * Extrai conceitos principais do documento   */  private async extractConcepts(    content: string,    analysis: any  ): Promise<Record<string, any>> {    const promptConcepts = `    Analise o seguinte texto e extraia os conceitos principais mencionados.    Para cada conceito, forneça uma definição, atributos relevantes e exemplos (se aplicável).         Use o seguinte formato JSON:    {      "conceitoA": {        "definition": "Definição do conceito",        "attributes": ["atributo1", "atributo2", ...],        "examples": ["exemplo1", "exemplo2", ...],        "importance": 0.X (número entre 0 e 1, representando a importância do conceito no documento)      },      ...    }         Considere os seguintes tópicos principais do documento: ${analysis.topics.join(', ')}         Texto:    ${content.substring(0, 3000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(promptConcepts, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1500      });             // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de conceitos inesperado');      return {};    } catch (error) {      console.error('Erro ao extrair conceitos:', error);      return {};    }  }     /**   * Identifica relacionamentos entre os conceitos   */  private async extractRelationships(    content: string,    concepts: Record<string, any>  ): Promise<Array<{    source: string;    target: string;    type: string;    description?: string;  }>> {    if (Object.keys(concepts).length < 2) {      return []; // Não há relacionamentos a extrair com menos de 2 conceitos    }         const conceptNames = Object.keys(concepts);    const promptRelationships = `    Analise o seguinte texto e identifique relacionamentos entre os seguintes conceitos:    ${conceptNames.join(', ')}         Para cada relacionamento, indique:    - Conceito de origem    - Conceito de destino    - Tipo de relacionamento (ex: "depende de", "contém", "é parte de", "é um tipo de", etc.)    - Breve descrição do relacionamento         Retorne no formato JSON:    [      {        "source": "conceitoA",        "target": "conceitoB",        "type": "tipo de relacionamento",        "description": "descrição do relacionamento"      },      ...    ]         Texto:    ${content.substring(0, 3000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(promptRelationships, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1200      });             // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de relacionamentos inesperado');      return [];    } catch (error) {      console.error('Erro ao extrair relacionamentos:', error);      return [];    }  }     /**   * Extrai referências citadas no documento   */  private async extractReferences(content: string): Promise<Array<{    id: string;    type: string;    description: string;    url?: string;  }>> {    // Verificar se há padrões de referências no texto    const hasReferences = /\[(.*?)\]|\(https?:\/\/.*?\)|(?:referências|bibliografia|fontes):/i.test(content);         if (!hasReferences) {      return []; // Sem referências detectadas    }         const promptReferences = `    Extraia todas as referências, citações, links e fontes mencionadas no texto.    Para cada referência, identifique:    - ID (número ou identificador único)    - Tipo (artigo, livro, website, pessoa, etc.)    - Descrição (título, autor, etc.)    - URL (se disponível)         Retorne no formato JSON:    [      {        "id": "ref1",        "type": "tipo de referência",        "description": "descrição da referência",        "url": "URL da referência (se houver)"      },      ...    ]         Texto:    ${content.substring(0, 3000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(promptReferences, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de referências inesperado');      return [];    } catch (error) {      console.error('Erro ao extrair referências:', error);      return [];    }  } }``

### src/services/knowledge/extractors/SummaryExtractor.ts

``import { LLMService } from '@/services/llm/LLMService'; export class SummaryExtractor {   private llmService: LLMService;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }     /**   * Extrair resumo de um documento   * @param content Conteúdo do documento   * @returns Resumo do documento   */  async extractSummary(content: string): Promise<{    brief: string;    comprehensive: string;    keyPoints: string[];  }> {    try {      // Gerar resumo breve      const brief = await this.generateBriefSummary(content);             // Gerar resumo detalhado      const comprehensive = await this.generateComprehensiveSummary(content);             // Extrair pontos-chave      const keyPoints = await this.extractKeyPoints(content);             return {        brief,        comprehensive,        keyPoints      };    } catch (error) {      console.error('Erro ao extrair resumo:', error);      return {        brief: 'Erro ao gerar resumo breve.',        comprehensive: 'Erro ao gerar resumo detalhado.',        keyPoints: ['Erro ao extrair pontos-chave.']      };    }  }     /**   * Gera um resumo breve (1-2 parágrafos)   */  private async generateBriefSummary(content: string): Promise<string> {    const prompt = `    Crie um resumo breve (1-2 parágrafos) do seguinte texto, destacando    apenas as informações mais importantes e os conceitos centrais:         ${content.substring(0, 3000)}... (texto truncado)    `;         return this.llmService.generateCompletion(prompt, {      model: 'openai:gpt-3.5-turbo',      temperature: 0.3,      maxTokens: 200    });  }     /**   * Gera um resumo mais detalhado (4-5 parágrafos)   */  private async generateComprehensiveSummary(content: string): Promise<string> {    const prompt = `    Crie um resumo detalhado (4-5 parágrafos) do seguinte texto, abordando    todos os pontos importantes, conceitos principais e suas relações:         ${content.substring(0, 4000)}... (texto truncado)    `;         return this.llmService.generateCompletion(prompt, {      model: 'openai:gpt-3.5-turbo',      temperature: 0.3,      maxTokens: 600    });  }     /**   * Extrai pontos-chave do documento   */  private async extractKeyPoints(content: string): Promise<string[]> {    const prompt = `    Extraia 5-8 pontos-chave do seguinte texto. Cada ponto-chave deve ser    uma afirmação concisa que capture uma ideia ou informação essencial:         ${content.substring(0, 3500)}... (texto truncado)         Formato da resposta: apenas os pontos-chave, um por linha, sem numeração ou marcadores.    `;         const response = await this.llmService.generateCompletion(prompt, {      model: 'openai:gpt-3.5-turbo',      temperature: 0.3,      maxTokens: 400    });         // Processar resposta para extrair pontos-chave    return response      .split('\n')      .map(line => line.replace(/^[•\-*\d.)\s]+/, '').trim())      .filter(line => line.length > 0);  } }``

### src/services/knowledge/generators/StructureGenerator.ts

``import { LLMService } from '@/services/llm/LLMService'; export class StructureGenerator {   private llmService: LLMService;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }     /**   * Gera uma estrutura hierárquica para o documento   * @param content Conteúdo do documento   * @param knowledge Conhecimento extraído   * @returns Estrutura hierárquica   */  async generate(content: string, knowledge: any): Promise<{    title: string;    sections: Array<{      title: string;      level: number;      content: string;      subsections?: Array<{        title: string;        level: number;        content: string;      }>;    }>;    hierarchy: any[];  }> {    try {      // 1. Extrair estrutura de seções      const sectionsStructure = await this.extractSections(content);             // 2. Gerar hierarquia      const hierarchy = this.buildHierarchy(sectionsStructure.sections);             // 3. Estrutura final      return {        ...sectionsStructure,        hierarchy      };    } catch (error) {      console.error('Erro ao gerar estrutura:', error);      return {        title: 'Erro na Geração de Estrutura',        sections: [],        hierarchy: []      };    }  }     /**   * Extrai as seções e subseções do documento   */  private async extractSections(content: string): Promise<{    title: string;    sections: Array<{      title: string;      level: number;      content: string;      subsections?: Array<{        title: string;        level: number;        content: string;      }>;    }>;  }> {    // Detectar se o documento é markdown    const isMarkdown = /^#+ /m.test(content);         if (isMarkdown) {      return this.extractMarkdownSections(content);    } else {      return this.extractTextSections(content);    }  }     /**   * Extrai seções de um documento Markdown   */  private async extractMarkdownSections(content: string): Promise<{    title: string;    sections: Array<{      title: string;      level: number;      content: string;      subsections?: Array<{        title: string;        level: number;        content: string;      }>;    }>;  }> {    // Extrair título principal (h1)    const titleMatch = content.match(/^# (.*?)$/m);    const title = titleMatch ? titleMatch[1] : 'Documento sem título';         // Extrair todas as seções com regex    const headingRegex = /^(#{1,6}) (.*?)$/gm;    const sections = [];    let lastIndex = 0;    let lastSection = null;    let lastLevel = 0;         let match;    while ((match = headingRegex.exec(content)) !== null) {      const level = match[1].length;      const sectionTitle = match[2];      const startIndex = match.index;             // Se não é a primeira seção, pegar o conteúdo da seção anterior      if (lastSection !== null) {        const sectionContent = content.substring(lastIndex, startIndex).trim();                 if (lastLevel === 1) {          // Seção principal          sections.push({            title: lastSection,            level: lastLevel,            content: sectionContent,            subsections: []          });        } else if (lastLevel > 1 && sections.length > 0) {          // Subseção          const parentSection = sections[sections.length - 1];          if (!parentSection.subsections) {            parentSection.subsections = [];          }          parentSection.subsections.push({            title: lastSection,            level: lastLevel,            content: sectionContent          });        }      }             lastSection = sectionTitle;      lastLevel = level;      lastIndex = startIndex + match[0].length;    }         // Adicionar a última seção    if (lastSection !== null) {      const sectionContent = content.substring(lastIndex).trim();             if (lastLevel === 1) {        sections.push({          title: lastSection,          level: lastLevel,          content: sectionContent,          subsections: []        });      } else if (lastLevel > 1 && sections.length > 0) {        const parentSection = sections[sections.length - 1];        if (!parentSection.subsections) {          parentSection.subsections = [];        }        parentSection.subsections.push({          title: lastSection,          level: lastLevel,          content: sectionContent        });      }    }         return { title, sections };  }     /**   * Extrai seções de um documento de texto simples usando LLM   */  private async extractTextSections(content: string): Promise<{    title: string;    sections: Array<{      title: string;      level: number;      content: string;      subsections?: Array<{        title: string;        level: number;        content: string;      }>;    }>;  }> {    const prompt = `    Analise o seguinte texto e estruture-o em seções lógicas.    Identifique um título principal para o documento, e divida-o em seções e subseções.         Para cada seção, forneça:    - Título da seção    - Nível da seção (1 para seções principais, 2 para subseções)    - Conteúdo da seção         Retorne no formato JSON:    {      "title": "Título principal do documento",      "sections": [        {          "title": "Título da seção",          "level": 1,          "content": "Conteúdo da seção",          "subsections": [            {              "title": "Título da subseção",              "level": 2,              "content": "Conteúdo da subseção"            }          ]        }      ]    }         Texto:    ${content.substring(0, 4000)}... (texto truncado)    `;         try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4',        temperature: 0.2,        maxTokens: 2000      });             // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             console.warn('Formato de resposta de seções inesperado');      return {        title: 'Estrutura não identificada',        sections: []      };    } catch (error) {      console.error('Erro ao extrair seções de texto:', error);      return {        title: 'Erro na extração de seções',        sections: []      };    }  }     /**   * Constrói uma hierarquia a partir das seções   */  private buildHierarchy(sections: Array<{    title: string;    level: number;    content: string;    subsections?: Array<{      title: string;      level: number;      content: string;    }>;  }>): any[] {    return sections.map(section => {      const node: any = {        id: this.generateNodeId(section.title),        name: section.title,        level: section.level,        size: section.content.length      };             if (section.subsections && section.subsections.length > 0) {        node.children = section.subsections.map(subsection => ({          id: this.generateNodeId(subsection.title),          name: subsection.title,          level: subsection.level,          size: subsection.content.length        }));      }             return node;    });  }     /**   * Gera um ID para nós da hierarquia   */  private generateNodeId(title: string): string {    return title      .toLowerCase()      .replace(/[^a-z0-9]+/g, '-')      .replace(/(^-|-$)/g, '');  } }``

### src/services/knowledge/generators/PromptGenerator.ts

``import { LLMService } from '@/services/llm/LLMService'; import { KnowledgeDocument } from '@/types/knowledge'; import { v4 as uuidv4 } from 'uuid'; export class PromptGenerator {   private llmService: LLMService;     constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }     /**   * Gera prompts a partir de um documento processado   * @param document Documento processado   * @param options Opções de geração   * @returns Array de prompts gerados   */  async generatePrompts(    document: KnowledgeDocument,    options: { goal: string; context?: string; format?: string }  ): Promise<{    prompts: string[];    timeline: { id: string; description: string; prompt: string }[];  }> {    try {      // 1. Gerar prompts iniciais      const initialPrompts = await this.generateInitialPrompts(document, options);             // 2. Refinar prompts      const refinedPrompts = await this.refinePrompts(initialPrompts, options);             // 3. Criar timeline      const timeline = this.createTimeline(refinedPrompts, document, options);             return {        prompts: refinedPrompts,        timeline      };    } catch (error) {      console.error('Erro ao gerar prompts:', error);      return {        prompts: ['Erro na geração de prompts.'],        timeline: [{          id: uuidv4(),          description: 'Erro na geração de timeline',          prompt: 'Ocorreu um erro ao gerar a timeline de prompts.'        }]      };    }  }     /**   * Gera prompts iniciais baseados no documento   */  private async generateInitialPrompts(    document: KnowledgeDocument,    options: { goal: string; context?: string; format?: string }  ): Promise<string[]> {    const { goal, context, format } = options;         const knowledgeJson = JSON.stringify({      concepts: document.knowledge.concepts,      relationships: document.knowledge.relationships    }, null, 2);         const prompt = `    Com base no documento e conhecimento estruturado abaixo, gere 3-5 prompts claros e detalhados    para ${goal}.         ${context ? `Contexto adicional: ${context}` : ''}         Título do documento: ${document.title}         Resumo: ${document.analysis.summary}         Principais conceitos e relacionamentos:    ${knowledgeJson}         ${format ? `Use o seguinte formato para os prompts: ${format}` : ''}         Para cada prompt:    1. Inclua contexto suficiente do documento    2. Seja específico sobre o que deve ser realizado    3. Inclua restrições ou requisitos relevantes    4. Estruture de forma clara com seções lógicas         Gere cada prompt separadamente, iniciando com "PROMPT X:" onde X é o número do prompt.    `;         const response = await this.llmService.generateCompletion(prompt, {      model: 'openai:gpt-4',      temperature: 0.7,      maxTokens: 2000    });         // Extrair prompts da resposta    const promptRegex = /PROMPT \d+:([\s\S]*?)(?=PROMPT \d+:|$)/g;    const prompts = [];         let match;    while ((match = promptRegex.exec(response)) !== null) {      prompts.push(match[1].trim());    }         return prompts.length > 0 ? prompts : [response];  }     /**   * Refina os prompts gerados   */  private async refinePrompts(    prompts: string[],    options: { goal: string; context?: string; format?: string }  ): Promise<string[]> {    if (prompts.length <= 1) {      return prompts;    }         const refinementPrompt = `    Revise e melhore os seguintes prompts para ${options.goal}.         ${prompts.map((p, i) => `PROMPT ${i+1}:\n${p}`).join('\n\n')}         Para cada prompt:    1. Verifique a clareza e precisão    2. Remova redundâncias    3. Assegure que inclui todas as informações necessárias    4. Melhore a estrutura para facilitar a compreensão         Retorne os prompts melhorados, iniciando cada um com "PROMPT REFINADO X:" onde X é o número do prompt.    `;         const response = await this.llmService.generateCompletion(refinementPrompt, {      model: 'openai:gpt-3.5-turbo',      temperature: 0.4,      maxTokens: 2000    });         // Extrair prompts refinados    const promptRegex = /PROMPT REFINADO \d+:([\s\S]*?)(?=PROMPT REFINADO \d+:|$)/g;    const refinedPrompts = [];         let match;    while ((match = promptRegex.exec(response)) !== null) {      refinedPrompts.push(match[1].trim());    }         return refinedPrompts.length > 0 ? refinedPrompts : prompts;  }     /**   * Cria uma timeline de prompts   */  private createTimeline(    prompts: string[],    document: KnowledgeDocument,    options: { goal: string; context?: string; format?: string }  ): { id: string; description: string; prompt: string }[] {    // Gerar descrições para cada prompt    return prompts.map((prompt, index) => {      // Extrair um título/descrição curta do início do prompt      const firstLine = prompt.split('\n')[0].trim();      const description = firstLine.length <= 50        ? firstLine        : firstLine.substring(0, 47) + '...';             return {        id: uuidv4(),        description: description || `Prompt ${index + 1}`,        prompt      };    });  } }``

### src/services/knowledge/generators/MetadataGenerator.ts

`import { metadataUtils } from './utils/metadataUtils'; export class MetadataGenerator {   /**   * Gera metadados para um documento processado   * @param document Documento original   * @param knowledge Conhecimento extraído   * @param analysis Análise do conteúdo   * @returns Metadados do documento   */  async generate(    document: { id: string; title: string; content: string },    knowledge: any,    analysis: any  ): Promise<{    tags: string[];    categories: string[];    readingTime: number;    complexity: string;    keywords: string[];    readability: {      score: number;      grade: string;      level: 'easy' | 'medium' | 'hard';    };    contentType: string;    languageCode: string;    createdAt: string;    updatedAt: string;    version: string;  }> {    // 1. Gerar tags baseadas em conceitos e tópicos    const tags = this.generateTags(knowledge, analysis);         // 2. Categorizar o documento    const categories = this.categorizeDocument(knowledge, analysis);         // 3. Calcular tempo de leitura    const readingTime = this.calculateReadingTime(document.content);         // 4. Determinar nível de complexidade    const complexity = this.determineComplexity(analysis.complexity?.score || 0.5);         // 5. Extrair palavras-chave    const keywords = this.extractKeywords(knowledge, analysis);         // 6. Calcular legibilidade    const readability = {      score: analysis.complexity?.score || 0.5,      grade: metadataUtils.readabilityGrade(analysis.complexity?.score || 0.5),      level: metadataUtils.readabilityLevel(analysis.complexity?.score || 0.5)    };         // 7. Determinar tipo de conteúdo    const contentType = analysis.format || 'text';         // 8. Obter código de idioma    const languageCode = analysis.language || 'pt-BR';         return {      tags,      categories,      readingTime,      complexity,      keywords,      readability,      contentType,      languageCode,      createdAt: new Date().toISOString(),      updatedAt: new Date().toISOString(),      version: '1.0'    };  }     /**   * Gera tags para o documento   */  private generateTags(knowledge: any, analysis: any): string[] {    // Combinar conceitos e tópicos    const conceptNames = Object.keys(knowledge.concepts || {});    const topics = analysis.topics || [];         // Filtrar e limitar o número de tags    const allTags = [...new Set([...conceptNames, ...topics])];         return allTags      .filter(tag => tag.length > 0)      .slice(0, 10)      .map(tag => tag.toLowerCase());  }     /**   * Categoriza o documento   */  private categorizeDocument(knowledge: any, analysis: any): string[] {    // Em produção, usaríamos um classificador mais sofisticado    // Simulação baseada em tópicos e conceitos         const topics = analysis.topics || [];    const concepts = Object.keys(knowledge.concepts || {});         // Mapeamento simples de categorias    const categoryKeywords: Record<string, string[]> = {      'desenvolvimento': ['código', 'programação', 'software', 'desenvolvimento', 'api'],      'arquitetura': ['arquitetura', 'sistema', 'design', 'estrutura', 'componente'],      'processamento': ['processamento', 'dados', 'análise', 'extração', 'transformação'],      'ia': ['ia', 'inteligência artificial', 'ml', 'machine learning', 'llm'],      'documentação': ['documentação', 'documento', 'markdown', 'texto', 'conteúdo']    };         // Identificar categorias baseadas em palavras-chave    const matchedCategories = Object.entries(categoryKeywords)      .filter(([_, keywords]) =>        keywords.some(keyword =>          topics.some(topic => topic.toLowerCase().includes(keyword)) ||          concepts.some(concept => concept.toLowerCase().includes(keyword))        )      )      .map(([category]) => category);         // Garantir pelo menos uma categoria    if (matchedCategories.length === 0) {      return ['geral'];    }         return matchedCategories;  }     /**   * Calcula o tempo estimado de leitura   */  private calculateReadingTime(content: string): number {    // Média de 200 palavras por minuto para leitura    const wordCount = content.split(/\s+/).length;    return Math.ceil(wordCount / 200);  }     /**   * Determina o nível de complexidade   */  private determineComplexity(complexityScore: number): string {    if (complexityScore < 0.3) {      return 'simples';    } else if (complexityScore < 0.7) {      return 'médio';    } else {      return 'complexo';    }  }     /**   * Extrai palavras-chave   */  private extractKeywords(knowledge: any, analysis: any): string[] {    // Usar conceitos com maior importância    const concepts = Object.entries(knowledge.concepts || {})      .sort((a, b) => (b[1].importance || 0) - (a[1].importance || 0))      .map(([concept]) => concept);         // Adicionar entidades relevantes    const entities = (analysis.entities || [])      .filter((entity: any) => (entity.relevance || 0) > 0.5)      .map((entity: any) => entity.name);         // Combinar e remover duplicatas    const combined = [...new Set([...concepts, ...entities])];         // Limitar o número de palavras-chave    return combined.slice(0, 8);  } }`

### src/services/knowledge/generators/utils/metadataUtils.ts

`export const metadataUtils = {   /**   * Determina o grau de leitura com base no score de complexidade   * @param complexityScore Score de complexidade entre 0 e 1   * @returns Nível de leitura em formato de grade escolar   */  readabilityGrade: (complexityScore: number): string => {    // Mapeamento de score de complexidade para nível escolar aproximado    if (complexityScore < 0.2) return 'Básico (4-5 anos)';    if (complexityScore < 0.3) return 'Elementar (6-7 anos)';    if (complexityScore < 0.4) return 'Intermediário (8-9 anos)';    if (complexityScore < 0.5) return 'Médio (10-11 anos)';    if (complexityScore < 0.6) return 'Ensino Fundamental (12-13 anos)';    if (complexityScore < 0.7) return 'Ensino Médio (14-15 anos)';    if (complexityScore < 0.8) return 'Ensino Médio Avançado (16-17 anos)';    if (complexityScore < 0.9) return 'Universitário';    return 'Técnico Especializado';  },     /**   * Determina o nível de legibilidade com base no score de complexidade   * @param complexityScore Score de complexidade entre 0 e 1   * @returns Nível de legibilidade (fácil, médio, difícil)   */  readabilityLevel: (complexityScore: number): 'easy' | 'medium' | 'hard' => {    if (complexityScore < 0.4) return 'easy';    if (complexityScore < 0.7) return 'medium';    return 'hard';  },     /**   * Calcula o número de palavras em um texto   * @param text Texto a ser analisado   * @returns Contagem de palavras   */  wordCount: (text: string): number => {    return text.split(/\s+/).filter(Boolean).length;  },     /**   * Calcula a média de palavras por sentença   * @param text Texto a ser analisado   * @returns Média de palavras por sentença   */  averageWordsPerSentence: (text: string): number => {    const sentences = text.split(/[.!?]+/).filter(Boolean);    if (sentences.length === 0) return 0;         const totalWords = sentences.reduce((sum, sentence) => {      return sum + sentence.split(/\s+/).filter(Boolean).length;    }, 0);         return totalWords / sentences.length;  },     /**   * Calcula a média de caracteres por palavra   * @param text Texto a ser analisado   * @returns Média de caracteres por palavra   */  averageCharactersPerWord: (text: string): number => {    const words = text.split(/\s+/).filter(Boolean);    if (words.length === 0) return 0;         const totalChars = words.reduce((sum, word) => sum + word.length, 0);    return totalChars / words.length;  },     /**   * Calcula a densidade lexical (proporção de palavras de conteúdo)   * @param text Texto a ser analisado   * @returns Densidade lexical entre 0 e 1   */  lexicalDensity: (text: string): number => {    const words = text.toLowerCase().split(/\s+/).filter(Boolean);    if (words.length === 0) return 0;         // Palavras funcionais comuns em português    const functionalWords = new Set([      'a', 'ao', 'aos', 'as', 'com', 'da', 'das', 'de', 'do', 'dos', 'e',      'em', 'na', 'nas', 'no', 'nos', 'o', 'os', 'para', 'por', 'que', 'se',      'um', 'uma', 'é'    ]);         const contentWords = words.filter(word => !functionalWords.has(word));    return contentWords.length / words.length;  },     /**   * Formata um timestamp em formato legível   * @param timestamp Timestamp ISO   * @returns Data formatada   */  formatDate: (timestamp: string): string => {    try {      const date = new Date(timestamp);      return date.toLocaleDateString('pt-BR', {        day: '2-digit',        month: '2-digit',        year: 'numeric',        hour: '2-digit',        minute: '2-digit'      });    } catch (error) {      return timestamp;    }  } };`

### src/services/knowledge/generators/analyzers/ComplexityAnalyzer.ts

`export class ComplexityAnalyzer {   /**   * Analisa a complexidade de um texto   * @param text Texto a ser analisado   * @returns Score de complexidade e legibilidade   */  async analyze(text: string): Promise<{    score: number;    readability: string;    metrics: {      sentenceLength: number;      wordLength: number;      lexicalDensity: number;      longWordPercentage: number;    };  }> {    // Extrair métricas de complexidade    const metrics = this.extractComplexityMetrics(text);         // Calcular score geral de complexidade    const score = this.calculateComplexityScore(metrics);         // Determinar nível de legibilidade    const readability = this.determineLegibilityLevel(score);         return {      score,      readability,      metrics    };  }     /**   * Extrai métricas de complexidade do texto   */  private extractComplexityMetrics(text: string): {    sentenceLength: number;    wordLength: number;    lexicalDensity: number;    longWordPercentage: number;  } {    // Dividir o texto em sentenças    const sentences = text.split(/[.!?]+/).filter(Boolean);         // Calcular comprimento médio de sentenças    const sentenceLengths = sentences.map(s => {      return s.split(/\s+/).filter(Boolean).length;    });    const sentenceLength = this.average(sentenceLengths) || 0;         // Extrair todas as palavras    const words = text.split(/\s+/).filter(Boolean);         // Calcular comprimento médio de palavras    const wordLengths = words.map(w => w.length);    const wordLength = this.average(wordLengths) || 0;         // Calcular densidade lexical (proporção de palavras de conteúdo)    const lexicalDensity = this.calculateLexicalDensity(words);         // Calcular porcentagem de palavras longas (>6 caracteres)    const longWords = words.filter(w => w.length > 6);    const longWordPercentage = words.length > 0 ? longWords.length / words.length : 0;         return {      sentenceLength,      wordLength,      lexicalDensity,      longWordPercentage    };  }     /**   * Calcula a média de um array de números   */  private average(values: number[]): number {    if (values.length === 0) return 0;    return values.reduce((sum, val) => sum + val, 0) / values.length;  }     /**   * Calcula a densidade lexical de um texto   */  private calculateLexicalDensity(words: string[]): number {    if (words.length === 0) return 0;         // Lista de palavras funcionais comuns em português    const functionalWords = new Set([      'a', 'ao', 'aos', 'as', 'com', 'da', 'das', 'de', 'do', 'dos', 'e',      'em', 'na', 'nas', 'no', 'nos', 'o', 'os', 'para', 'por', 'que', 'se',      'um', 'uma', 'é'    ]);         // Contar palavras que não são funcionais    const contentWords = words.filter(word => !functionalWords.has(word.toLowerCase()));         return contentWords.length / words.length;  }     /**   * Calcula um score de complexidade com base nas métricas   */  private calculateComplexityScore(metrics: {    sentenceLength: number;    wordLength: number;    lexicalDensity: number;    longWordPercentage: number;  }): number {    // Pesos para cada métrica    const weights = {      sentenceLength: 0.25,      wordLength: 0.25,      lexicalDensity: 0.25,      longWordPercentage: 0.25    };         // Normalizar valores    const normalizedSentenceLength = this.normalize(metrics.sentenceLength, 5, 30);    const normalizedWordLength = this.normalize(metrics.wordLength, 3, 8);    const normalizedLexicalDensity = metrics.lexicalDensity;    const normalizedLongWordPercentage = metrics.longWordPercentage;         // Calcular score ponderado    const score =      weights.sentenceLength * normalizedSentenceLength +      weights.wordLength * normalizedWordLength +      weights.lexicalDensity * normalizedLexicalDensity +      weights.longWordPercentage * normalizedLongWordPercentage;         // Garantir que o score esteja entre 0 e 1    return Math.max(0, Math.min(1, score));  }     /**   * Normaliza um valor para uma escala de 0 a 1   */  private normalize(value: number, min: number, max: number): number {    if (value <= min) return 0;    if (value >= max) return 1;    return (value - min) / (max - min);  }     /**   * Determina o nível de legibilidade baseado no score   */  private determineLegibilityLevel(score: number): string {    if (score < 0.3) return 'Fácil';    if (score < 0.6) return 'Médio';    return 'Difícil';  } }`

### src/services/knowledge/validators/OutputValidator.ts

``export class OutputValidator {   /**   * Valida o conhecimento e estrutura extraídos   * @param knowledge Conhecimento extraído   * @param structure Estrutura gerada   * @returns Resultado da validação   */  async validate(knowledge: any, structure: any): Promise<boolean> {    try {      // 1. Validar conhecimento      const isKnowledgeValid = this.validateKnowledge(knowledge);             // 2. Validar estrutura      const isStructureValid = this.validateStructure(structure);             // 3. Validar coerência entre conhecimento e estrutura      const isCoherent = this.validateCoherence(knowledge, structure);             return isKnowledgeValid && isStructureValid && isCoherent;    } catch (error) {      console.error('Erro na validação:', error);      return false;    }  }     /**   * Valida o conhecimento extraído   */  private validateKnowledge(knowledge: any): boolean {    // Verificar se há conceitos    if (!knowledge.concepts || Object.keys(knowledge.concepts).length === 0) {      console.warn('Validação: Nenhum conceito encontrado');      return false;    }         // Verificar consistência nos conceitos    for (const [concept, data] of Object.entries(knowledge.concepts)) {      if (!concept || typeof concept !== 'string') {        console.warn('Validação: Conceito inválido');        return false;      }             // Verificar se o conceito tem definição      if (!data || typeof data !== 'object' || !data.definition) {        console.warn(`Validação: Conceito "${concept}" sem definição`);        return false;      }    }         // Verificar relacionamentos, se existirem    if (knowledge.relationships && knowledge.relationships.length > 0) {      for (const rel of knowledge.relationships) {        if (!rel.source || !rel.target || !rel.type) {          console.warn('Validação: Relacionamento incompleto');          return false;        }                 // Verificar se os conceitos referenciados existem        if (!knowledge.concepts[rel.source] || !knowledge.concepts[rel.target]) {          console.warn(`Validação: Relacionamento referencia conceito inexistente: ${rel.source} -> ${rel.target}`);          return false;        }      }    }         return true;  }     /**   * Valida a estrutura gerada   */  private validateStructure(structure: any): boolean {    // Verificar se há título    if (!structure.title) {      console.warn('Validação: Estrutura sem título');      return false;    }         // Verificar se há seções    if (!structure.sections || !Array.isArray(structure.sections) || structure.sections.length === 0) {      console.warn('Validação: Estrutura sem seções');      return false;    }         // Verificar consistência nas seções    for (const section of structure.sections) {      if (!section.title || !section.content) {        console.warn('Validação: Seção incompleta');        return false;      }             // Verificar subsecções, se existirem      if (section.subsections && Array.isArray(section.subsections)) {        for (const subsection of section.subsections) {          if (!subsection.title || !subsection.content) {            console.warn('Validação: Subseção incompleta');            return false;          }        }      }    }         return true;  }     /**   * Valida a coerência entre conhecimento e estrutura   */  private validateCoherence(knowledge: any, structure: any): boolean {    // Extrair termos importantes da estrutura    const structureTerms = this.extractTermsFromStructure(structure);         // Extrair conceitos importantes    const conceptTerms = Object.keys(knowledge.concepts || {});         // Verificar sobreposição    const overlap = this.calculateTermOverlap(structureTerms, conceptTerms);         // Deve haver pelo menos 30% de sobreposição para ser válido    return overlap >= 0.3;  }     /**   * Extrai termos importantes da estrutura   */  private extractTermsFromStructure(structure: any): string[] {    const terms: string[] = [];         // Adicionar título principal    if (structure.title) {      terms.push(...this.extractWordsFromTitle(structure.title));    }         // Adicionar títulos de seções    if (structure.sections && Array.isArray(structure.sections)) {      for (const section of structure.sections) {        if (section.title) {          terms.push(...this.extractWordsFromTitle(section.title));        }                 // Adicionar títulos de subseções        if (section.subsections && Array.isArray(section.subsections)) {          for (const subsection of section.subsections) {            if (subsection.title) {              terms.push(...this.extractWordsFromTitle(subsection.title));            }          }        }      }    }         return [...new Set(terms)];  }     /**   * Extrai palavras significativas de um título   */  private extractWordsFromTitle(title: string): string[] {    // Remover artigos e preposições comuns    const stopwords = ['a', 'o', 'as', 'os', 'de', 'da', 'do', 'das', 'dos', 'em', 'na', 'no', 'e', 'para'];         return title      .toLowerCase()      .split(/\s+/)      .filter(word => word.length > 2 && !stopwords.includes(word));  }     /**   * Calcula a sobreposição entre dois conjuntos de termos   */  private calculateTermOverlap(terms1: string[], terms2: string[]): number {    if (terms1.length === 0 || terms2.length === 0) {      return 0;    }         // Contar quantos termos do conjunto 1 aparecem no conjunto 2    let matchCount = 0;    for (const term1 of terms1) {      for (const term2 of terms2) {        if (term1.includes(term2) || term2.includes(term1)) {          matchCount++;          break;        }      }    }         // Calcular sobreposição como proporção do menor conjunto    return matchCount / Math.min(terms1.length, terms2.length);  } }``

### src/components/llm/pipelines/PipelineStep.tsx

``import React from "react"; import { LLMProvider, PipelineStep as PipelineStepType } from "@/types/llm"; import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "../../ui/select"; import { Label } from "../../ui/label"; import { Textarea } from "../../ui/textarea"; import { Button } from "../../ui/button"; import { Draggable } from "react-beautiful-dnd"; import { MoveVertical, Trash2 } from "lucide-react"; interface PipelineStepProps {   step: PipelineStepType;  index: number;  providers: LLMProvider[];  onUpdateStep: (stepId: string, updates: Partial<PipelineStepType>) => void;  onRemoveStep: (stepId: string) => void; } export function PipelineStep({    step,  index,  providers,  onUpdateStep,  onRemoveStep  }: PipelineStepProps) {   return (    <Draggable key={step.id} draggableId={step.id} index={index}>      {(provided) => (        <div          ref={provided.innerRef}          {...provided.draggableProps}          className="border rounded-md p-4"        >          <div className="flex justify-between items-center mb-2">            <div className="flex space-x-2 items-center">              <div {...provided.dragHandleProps}>                <MoveVertical className="h-5 w-5 text-muted-foreground cursor-move" />              </div>              <h4 className="font-medium">Passo {index + 1}</h4>            </div>            <Button              variant="ghost"              size="icon"              onClick={() => onRemoveStep(step.id)}            >              <Trash2 className="h-4 w-4" />            </Button>          </div>           <div className="space-y-3">            <div className="grid grid-cols-2 gap-2">              <div className="space-y-1">                <Label htmlFor={`provider-${step.id}`}>Provedor</Label>                <Select                  value={step.providerId}                  onValueChange={(value) => onUpdateStep(step.id, { providerId: value })}                >                  <SelectTrigger id={`provider-${step.id}`}>                    <SelectValue placeholder="Selecione um provedor" />                  </SelectTrigger>                  <SelectContent>                    {providers.map((provider) => (                      <SelectItem key={provider.id} value={provider.id}>                        {provider.name}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              </div>                             <div className="space-y-1">                <Label htmlFor={`role-${step.id}`}>Função</Label>                <Select                  value={step.role}                  onValueChange={(value) =>                    onUpdateStep(step.id, {                      role: value as "input" | "processor" | "output"                    })                  }                >                  <SelectTrigger id={`role-${step.id}`}>                    <SelectValue placeholder="Função do passo" />                  </SelectTrigger>                  <SelectContent>                    <SelectItem value="input">Entrada</SelectItem>                    <SelectItem value="processor">Processador</SelectItem>                    <SelectItem value="output">Saída</SelectItem>                  </SelectContent>                </Select>              </div>            </div>             <div className="space-y-1">              <Label htmlFor={`system-prompt-${step.id}`}>Prompt do Sistema</Label>              <Textarea                id={`system-prompt-${step.id}`}                value={step.systemPrompt || ""}                onChange={(e) =>                  onUpdateStep(step.id, { systemPrompt: e.target.value })                }                placeholder="Instruções para o LLM neste passo..."                rows={3}              />            </div>          </div>        </div>      )}    </Draggable>  ); }``

### src/components/llm/pipelines/PipelineStepsList.tsx

``import React from "react"; import { useLLM } from "@/hooks/useLLM"; import { LLMPipeline, LLMProvider, PipelineStep } from "@/types/llm"; import { Button } from "../../ui/button"; import { Alert, AlertDescription } from "../../ui/alert"; import { Plus } from "lucide-react"; import { DragDropContext, Droppable } from "react-beautiful-dnd"; import { v4 as uuidv4 } from "uuid"; import { toast } from "sonner"; import { PipelineStep as PipelineStepComponent } from "./PipelineStep"; interface PipelineStepsListProps {   selectedPipeline: LLMPipeline;  setSelectedPipeline: (pipeline: LLMPipeline) => void;  providers: LLMProvider[]; } export function PipelineStepsList({    selectedPipeline,  setSelectedPipeline,  providers  }: PipelineStepsListProps) {   const { updatePipeline } = useLLM();   const handleAddStep = () => {    const newStep: PipelineStep = {      id: `step-${uuidv4()}`,      providerId: providers.length > 0 ? providers[0].id : "",      role: "processor",      order: selectedPipeline.steps.length,      systemPrompt: ""    };     const updatedSteps = [...selectedPipeline.steps, newStep];    const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };         updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo adicionado ao pipeline");  };   const handleUpdateStep = (stepId: string, updates: Partial<PipelineStep>) => {    const updatedSteps = selectedPipeline.steps.map((step) =>      step.id === stepId ? { ...step, ...updates } : step    );     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   const handleRemoveStep = (stepId: string) => {    const updatedSteps = selectedPipeline.steps      .filter((step) => step.id !== stepId)      .map((step, index) => ({ ...step, order: index }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);    toast.success("Passo removido do pipeline");  };   const handleDragEnd = (result) => {    if (!result.destination) return;     const steps = Array.from(selectedPipeline.steps);    const [reorderedItem] = steps.splice(result.source.index, 1);    steps.splice(result.destination.index, 0, reorderedItem);     const updatedSteps = steps.map((step, index) => ({      ...step,      order: index    }));     const updatedPipeline = { ...selectedPipeline, steps: updatedSteps };    updatePipeline(selectedPipeline.id, { steps: updatedSteps });    setSelectedPipeline(updatedPipeline);  };   return (    <div className="space-y-4">      <div className="flex justify-between items-center">        <h3 className="text-lg font-medium">Passos do Pipeline</h3>        <Button onClick={handleAddStep}>          <Plus className="mr-2 h-4 w-4" /> Adicionar Passo        </Button>      </div>       {selectedPipeline.steps.length === 0 ? (        <Alert>          <AlertDescription>            Este pipeline não possui passos. Adicione passos para definir o fluxo de processamento.          </AlertDescription>        </Alert>      ) : (        <DragDropContext onDragEnd={handleDragEnd}>          <Droppable droppableId="pipeline-steps">            {(provided) => (              <div                {...provided.droppableProps}                ref={provided.innerRef}                className="space-y-4"              >                {selectedPipeline.steps                  .sort((a, b) => a.order - b.order)                  .map((step, index) => (                    <PipelineStepComponent                      key={step.id}                      step={step}                      index={index}                      providers={providers}                      onUpdateStep={handleUpdateStep}                      onRemoveStep={handleRemoveStep}                    />                  ))}                {provided.placeholder}              </div>            )}          </Droppable>        </DragDropContext>      )}    </div>  ); }``

### src/types/react-beautiful-dnd.d.ts

`declare module 'react-beautiful-dnd' {   import * as React from 'react';   // Draggable  export interface DraggableProvided {    draggableProps: React.HTMLAttributes<HTMLElement>;    dragHandleProps: React.HTMLAttributes<HTMLElement> | null;    innerRef: (element: HTMLElement | null) => void;  }   // Droppable  export interface DroppableProvided {    innerRef: (element: HTMLElement | null) => void;    droppableProps: React.HTMLAttributes<HTMLElement>;    placeholder?: React.ReactNode;  }   export interface DropResult {    draggableId: string;    type: string;    source: {      droppableId: string;      index: number;    };    destination?: {      droppableId: string;      index: number;    };    reason: 'DROP' | 'CANCEL';  }   export interface DraggableProps {    draggableId: string;    index: number;    children: (provided: DraggableProvided) => React.ReactNode;  }   export interface DroppableProps {    droppableId: string;    children: (provided: DroppableProvided) => React.ReactNode;  }   export declare class Draggable extends React.Component<DraggableProps> {}  export declare class Droppable extends React.Component<DroppableProps> {}  export declare class DragDropContext extends React.Component<{    onDragEnd: (result: DropResult) => void;  }> {} }`

### src/services/messaging/MessageBus.ts

``type MessageHandler = (payload: any) => void; interface Subscription {   id: string;  topic: string;  handler: MessageHandler; } /**  * Serviço de mensageria para comunicação entre componentes */ export class MessageBus {   private static instance: MessageBus;  private subscriptions: Subscription[] = [];     private constructor() {}     /**   * Obtém a instância única do MessageBus (Singleton)   */  public static getInstance(): MessageBus {    if (!MessageBus.instance) {      MessageBus.instance = new MessageBus();    }    return MessageBus.instance;  }     /**   * Assina um tópico para receber mensagens   * @param topic Tópico a ser assinado   * @param handler Função de callback para processamento das mensagens   * @returns ID da assinatura (para cancelamento posterior)   */  public subscribe(topic: string, handler: MessageHandler): string {    const id = this.generateId();    this.subscriptions.push({ id, topic, handler });    return id;  }     /**   * Cancela uma assinatura   * @param id ID da assinatura a ser cancelada   * @returns true se a assinatura foi encontrada e cancelada, false caso contrário   */  public unsubscribe(id: string): boolean {    const initialLength = this.subscriptions.length;    this.subscriptions = this.subscriptions.filter(sub => sub.id !== id);    return initialLength !== this.subscriptions.length;  }     /**   * Publica uma mensagem em um tópico   * @param topic Tópico onde a mensagem será publicada   * @param payload Conteúdo da mensagem   */  public publish(topic: string, payload: any): void {    const matchingSubscriptions = this.subscriptions.filter(sub =>      sub.topic === topic || sub.topic === '*'    );         for (const subscription of matchingSubscriptions) {      try {        subscription.handler(payload);      } catch (error) {        console.error(`Erro no handler de mensagem para o tópico ${topic}:`, error);      }    }  }     /**   * Limpa todas as assinaturas   */  public clearAllSubscriptions(): void {    this.subscriptions = [];  }     /**   * Obtém todas as assinaturas para um tópico específico   * @param topic Tópico a ser consultado   * @returns Array de IDs de assinaturas   */  public getSubscriptionsByTopic(topic: string): string[] {    return this.subscriptions      .filter(sub => sub.topic === topic)      .map(sub => sub.id);  }     /**   * Gera um ID único para uma assinatura   */  private generateId(): string {    return `sub_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;  } } // Exportar uma instância única para uso global export const messageBus = MessageBus.getInstance();``

### src/services/messaging/**tests**/MessageBus.test.ts

`import { MessageBus } from '../MessageBus'; describe('MessageBus', () => {   let messageBus: MessageBus;     beforeEach(() => {    // Limpar todas as assinaturas antes de cada teste    messageBus = MessageBus.getInstance();    messageBus.clearAllSubscriptions();  });     it('should be a singleton', () => {    const instance1 = MessageBus.getInstance();    const instance2 = MessageBus.getInstance();    expect(instance1).toBe(instance2);  });     it('should allow subscribing to topics', () => {    const handler = jest.fn();    const subscriptionId = messageBus.subscribe('test-topic', handler);         expect(subscriptionId).toBeDefined();    expect(typeof subscriptionId).toBe('string');         const subscriptions = messageBus.getSubscriptionsByTopic('test-topic');    expect(subscriptions.length).toBe(1);    expect(subscriptions[0]).toBe(subscriptionId);  });     it('should allow unsubscribing from topics', () => {    const handler = jest.fn();    const subscriptionId = messageBus.subscribe('test-topic', handler);         const result = messageBus.unsubscribe(subscriptionId);    expect(result).toBe(true);         const subscriptions = messageBus.getSubscriptionsByTopic('test-topic');    expect(subscriptions.length).toBe(0);  });     it('should handle unsubscribing non-existent subscription', () => {    const result = messageBus.unsubscribe('non-existent-id');    expect(result).toBe(false);  });     it('should deliver messages to subscribers', () => {    const handler = jest.fn();    messageBus.subscribe('test-topic', handler);         const payload = { data: 'test data' };    messageBus.publish('test-topic', payload);         expect(handler).toHaveBeenCalledTimes(1);    expect(handler).toHaveBeenCalledWith(payload);  });     it('should not deliver messages to unsubscribed handlers', () => {    const handler = jest.fn();    const subscriptionId = messageBus.subscribe('test-topic', handler);    messageBus.unsubscribe(subscriptionId);         messageBus.publish('test-topic', { data: 'test data' });    expect(handler).not.toHaveBeenCalled();  });     it('should support wildcard subscriptions', () => {    const wildcardHandler = jest.fn();    messageBus.subscribe('*', wildcardHandler);         const payload1 = { data: 'test1' };    const payload2 = { data: 'test2' };         messageBus.publish('topic1', payload1);    messageBus.publish('topic2', payload2);         expect(wildcardHandler).toHaveBeenCalledTimes(2);    expect(wildcardHandler).toHaveBeenNthCalledWith(1, payload1);    expect(wildcardHandler).toHaveBeenNthCalledWith(2, payload2);  });     it('should handle multiple subscribers to the same topic', () => {    const handler1 = jest.fn();    const handler2 = jest.fn();         messageBus.subscribe('shared-topic', handler1);    messageBus.subscribe('shared-topic', handler2);         const payload = { data: 'shared data' };    messageBus.publish('shared-topic', payload);         expect(handler1).toHaveBeenCalledWith(payload);    expect(handler2).toHaveBeenCalledWith(payload);  });     it('should continue delivering messages if one handler throws an error', () => {    console.error = jest.fn(); // Mock console.error         const errorHandler = jest.fn().mockImplementation(() => {      throw new Error('Handler error');    });         const normalHandler = jest.fn();         messageBus.subscribe('error-topic', errorHandler);    messageBus.subscribe('error-topic', normalHandler);         messageBus.publish('error-topic', { data: 'test' });         expect(errorHandler).toHaveBeenCalled();    expect(normalHandler).toHaveBeenCalled();    expect(console.error).toHaveBeenCalled();  });     it('should clear all subscriptions', () => {    const handler = jest.fn();    messageBus.subscribe('topic1', handler);    messageBus.subscribe('topic2', handler);         messageBus.clearAllSubscriptions();         expect(messageBus.getSubscriptionsByTopic('topic1').length).toBe(0);    expect(messageBus.getSubscriptionsByTopic('topic2').length).toBe(0);         messageBus.publish('topic1', { data: 'test' });    expect(handler).not.toHaveBeenCalled();  }); });`

### src/services/monitoring/MonitoringService.ts

``import { MessageBus } from '../messaging/MessageBus'; interface LogEvent {   type: string;  timestamp: number;  [key: string]: any; } interface MonitoringStats {   eventCounts: Record<string, number>;  totalEvents: number;  startTime: number;  lastEventTime: number | null; } export class MonitoringService {   private static instance: MonitoringService;  private events: LogEvent[] = [];  private messageBus: MessageBus;  private stats: MonitoringStats;  private metricsEnabled: boolean = true;  private consoleLoggingEnabled: boolean = true;     private constructor() {    this.messageBus = MessageBus.getInstance();    this.stats = {      eventCounts: {},      totalEvents: 0,      startTime: Date.now(),      lastEventTime: null    };  }     /**   * Obtém a instância única do MonitoringService (Singleton)   */  public static getInstance(): MonitoringService {    if (!MonitoringService.instance) {      MonitoringService.instance = new MonitoringService();    }    return MonitoringService.instance;  }     /**   * Registra um evento no sistema de monitoramento   * @param event Evento a ser registrado   */  public logEvent(event: Omit<LogEvent, 'timestamp'>): void {    const fullEvent: LogEvent = {      ...event,      timestamp: Date.now()    };         this.events.push(fullEvent);         // Atualizar estatísticas    this.updateStats(fullEvent);         // Publicar evento no MessageBus    this.messageBus.publish('monitoring.event', fullEvent);         // Registrar no console, se habilitado    if (this.consoleLoggingEnabled) {      const eventType = event.type || 'unknown';      console.log(`[${eventType}]`, event);    }  }     /**   * Limpa todos os eventos registrados   */  public clearEvents(): void {    this.events = [];    this.resetStats();  }     /**   * Obtém todos os eventos registrados   */  public getEvents(): LogEvent[] {    return [...this.events];  }     /**   * Filtra eventos por tipo   * @param type Tipo de evento a ser filtrado   */  public getEventsByType(type: string): LogEvent[] {    return this.events.filter(event => event.type === type);  }     /**   * Habilita ou desabilita o registro de métricas   */  public setMetricsEnabled(enabled: boolean): void {    this.metricsEnabled = enabled;  }     /**   * Habilita ou desabilita o registro de eventos no console   */  public setConsoleLoggingEnabled(enabled: boolean): void {    this.consoleLoggingEnabled = enabled;  }     /**   * Obtém as estatísticas atuais de monitoramento   */  public getStats(): MonitoringStats {    return { ...this.stats };  }     /**   * Atualiza as estatísticas com base em um novo evento   */  private updateStats(event: LogEvent): void {    if (!this.metricsEnabled) return;         const { type } = event;         // Incrementar contagem por tipo    if (!this.stats.eventCounts[type]) {      this.stats.eventCounts[type] = 0;    }    this.stats.eventCounts[type] += 1;         // Atualizar contagem total    this.stats.totalEvents += 1;         // Atualizar timestamp do último evento    this.stats.lastEventTime = event.timestamp;  }     /**   * Reinicia as estatísticas   */  private resetStats(): void {    this.stats = {      eventCounts: {},      totalEvents: 0,      startTime: Date.now(),      lastEventTime: null    };  }     /**   * Registra uma métrica com valor numérico   * @param name Nome da métrica   * @param value Valor da métrica   * @param tags Tags associadas à métrica   */  public recordMetric(name: string, value: number, tags: Record<string, string> = {}): void {    if (!this.metricsEnabled) return;         this.logEvent({      type: 'metric',      name,      value,      tags    });  }     /**   * Inicia um timer para medir duração   * @param name Nome do timer   * @returns Função para parar o timer e registrar a duração   */  public startTimer(name: string, tags: Record<string, string> = {}): () => void {    const startTime = Date.now();         return () => {      const duration = Date.now() - startTime;      this.recordMetric(`${name}_duration`, duration, tags);    };  } } // Exportar uma instância única para uso global export const monitoringService = MonitoringService.getInstance();``

### src/services/cache/CacheService.ts

`interface CacheOptions {   ttl?: number;  // Tempo de vida do cache em milissegundos  maxSize?: number;  // Número máximo de itens no cache } interface CacheItem<T> {   value: T;  expires: number | null;  // Timestamp de expiração ou null para não expirar  lastAccessed: number; } /**  * Serviço de cache genérico */ export class CacheService<T> {   private cache: Map<string, CacheItem<T>>;  private options: Required<CacheOptions>;     constructor(options: CacheOptions = {}) {    this.cache = new Map();    this.options = {      ttl: options.ttl || 30 * 60 * 1000,  // 30 minutos por padrão      maxSize: options.maxSize || 100  // 100 itens por padrão    };  }     /**   * Adiciona ou atualiza um item no cache   * @param key Chave do item   * @param value Valor a ser armazenado   * @param ttl Tempo de vida específico para este item (opcional)   */  async set(key: string, value: T, ttl?: number): Promise<void> {    const now = Date.now();    const expires = ttl ? now + ttl : this.options.ttl ? now + this.options.ttl : null;         // Verificar se precisamos liberar espaço    if (this.cache.size >= this.options.maxSize) {      this.evictLeastRecentlyUsed();    }         this.cache.set(key, {      value,      expires,      lastAccessed: now    });  }     /**   * Recupera um item do cache   * @param key Chave do item   * @returns Valor armazenado ou null se não encontrado ou expirado   */  async get(key: string): Promise<T | null> {    const item = this.cache.get(key);         if (!item) {      return null;    }         const now = Date.now();         // Verificar expiração    if (item.expires !== null && now > item.expires) {      this.cache.delete(key);      return null;    }         // Atualizar timestamp de último acesso    item.lastAccessed = now;         return item.value;  }     /**   * Remove um item do cache   * @param key Chave do item   * @returns true se o item foi removido, false se não existia   */  async delete(key: string): Promise<boolean> {    return this.cache.delete(key);  }     /**   * Limpa todo o cache   */  async clear(): Promise<void> {    this.cache.clear();  }     /**   * Verifica se uma chave existe no cache (e não está expirada)   * @param key Chave a verificar   */  async has(key: string): Promise<boolean> {    const item = this.cache.get(key);    if (!item) return false;         const now = Date.now();    if (item.expires !== null && now > item.expires) {      this.cache.delete(key);      return false;    }         return true;  }     /**   * Remove itens expirados do cache   * @returns Número de itens removidos   */  clearExpired(): number {    const now = Date.now();    let removedCount = 0;         for (const [key, item] of this.cache.entries()) {      if (item.expires !== null && now > item.expires) {        this.cache.delete(key);        removedCount++;      }    }         return removedCount;  }     /**   * Obtém o tamanho atual do cache   */  size(): number {    return this.cache.size;  }     /**   * Obtém informações sobre o estado do cache   */  stats(): {    size: number;    maxSize: number;    ttl: number;    oldestItem: number | null;    newestItem: number | null;  } {    let oldestAccess = Infinity;    let newestAccess = 0;         for (const item of this.cache.values()) {      if (item.lastAccessed < oldestAccess) {        oldestAccess = item.lastAccessed;      }      if (item.lastAccessed > newestAccess) {        newestAccess = item.lastAccessed;      }    }         return {      size: this.cache.size,      maxSize: this.options.maxSize,      ttl: this.options.ttl,      oldestItem: oldestAccess !== Infinity ? oldestAccess : null,      newestItem: newestAccess !== 0 ? newestAccess : null    };  }     /**   * Remove o item menos recentemente acessado   */  private evictLeastRecentlyUsed(): boolean {    let lruKey: string | null = null;    let lruTime = Infinity;         for (const [key, item] of this.cache.entries()) {      if (item.lastAccessed < lruTime) {        lruKey = key;        lruTime = item.lastAccessed;      }    }         if (lruKey) {      return this.cache.delete(lruKey);    }         return false;  } }`

### src/hooks/useMediaProcessor.ts

``import { useState } from 'react'; import { MediaProcessor } from '@/services/media/MediaProcessor'; import { MediaProcessingResult } from '@/types/media'; import { toast } from 'sonner'; import { CacheService } from '@/services/cache/CacheService'; import { MonitoringService } from '@/services/monitoring/MonitoringService'; // Criar instâncias únicas dos serviços const cacheService = new CacheService<MediaProcessingResult>({   ttl: 30 * 60 * 1000, // 30 minutos  maxSize: 50 }); const monitoringService = MonitoringService.getInstance(); const mediaProcessor = new MediaProcessor(cacheService, monitoringService); export function useMediaProcessor() {   const [loading, setLoading] = useState<boolean>(false);  const [error, setError] = useState<string | null>(null);  const [result, setResult] = useState<MediaProcessingResult | null>(null);  const [isRecording, setIsRecording] = useState<boolean>(false);  const [recordingStream, setRecordingStream] = useState<MediaStream | null>(null);     // Processar um arquivo de mídia  const processMedia = async (file: File): Promise<MediaProcessingResult | null> => {    if (!file) {      setError('Nenhum arquivo selecionado');      return null;    }         setLoading(true);    setError(null);         try {      monitoringService.logEvent({        type: 'media_processing_start',        fileType: file.type,        fileName: file.name,        fileSize: file.size      });             const startTime = performance.now();      const result = await mediaProcessor.processFile(file);      const processingTime = performance.now() - startTime;             monitoringService.logEvent({        type: 'media_processing_complete',        fileType: file.type,        fileName: file.name,        fileSize: file.size,        processingTime,        success: true      });             setResult(result);      setLoading(false);      toast.success(`Processamento concluído: ${file.name}`);      return result;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';             monitoringService.logEvent({        type: 'media_processing_error',        fileType: file.type,        fileName: file.name,        fileSize: file.size,        error: errorMessage      });             setError(errorMessage);      setLoading(false);      toast.error(`Erro ao processar arquivo: ${errorMessage}`);      return null;    }  };     // Processar um lote de arquivos  const processBatch = async (files: File[]): Promise<MediaProcessingResult[]> => {    if (files.length === 0) {      setError('Nenhum arquivo selecionado');      return [];    }         setLoading(true);    setError(null);         try {      monitoringService.logEvent({        type: 'media_batch_processing_start',        fileCount: files.length      });             const startTime = performance.now();      const results = await mediaProcessor.processBatch(files);      const processingTime = performance.now() - startTime;             monitoringService.logEvent({        type: 'media_batch_processing_complete',        fileCount: files.length,        processingTime,        success: true      });             setLoading(false);      toast.success(`Processamento em lote concluído: ${files.length} arquivos`);      return results;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';             monitoringService.logEvent({        type: 'media_batch_processing_error',        fileCount: files.length,        error: errorMessage      });             setError(errorMessage);      setLoading(false);      toast.error(`Erro ao processar lote: ${errorMessage}`);      return [];    }  };     // Iniciar gravação de áudio  const startAudioRecording = async (): Promise<boolean> => {    try {      const { stream } = await mediaProcessor.startAudioRecording();      setIsRecording(true);      setRecordingStream(stream);      return true;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setError(errorMessage);      toast.error(`Erro ao iniciar gravação: ${errorMessage}`);      return false;    }  };     // Parar gravação de áudio  const stopAudioRecording = async (): Promise<MediaProcessingResult | null> => {    if (!isRecording) {      setError('Nenhuma gravação em andamento');      return null;    }         try {      const { file } = await mediaProcessor.stopAudioRecording();      setIsRecording(false);      setRecordingStream(null);             // Processar o arquivo gravado      return processMedia(file);    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setError(errorMessage);      setIsRecording(false);      setRecordingStream(null);      toast.error(`Erro ao finalizar gravação: ${errorMessage}`);      return null;    }  };     // Iniciar gravação de vídeo  const startVideoRecording = async (): Promise<boolean> => {    try {      const { stream } = await mediaProcessor.startVideoRecording();      setIsRecording(true);      setRecordingStream(stream);      return true;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setError(errorMessage);      toast.error(`Erro ao iniciar gravação de vídeo: ${errorMessage}`);      return false;    }  };     // Parar gravação de vídeo  const stopVideoRecording = async (): Promise<MediaProcessingResult | null> => {    if (!isRecording) {      setError('Nenhuma gravação em andamento');      return null;    }         try {      const { file } = await mediaProcessor.stopVideoRecording();      setIsRecording(false);      setRecordingStream(null);             // Processar o arquivo gravado      return processMedia(file);    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';      setError(errorMessage);      setIsRecording(false);      setRecordingStream(null);      toast.error(`Erro ao finalizar gravação de vídeo: ${errorMessage}`);      return null;    }  };     // Cancelar gravação em andamento  const cancelRecording = (): void => {    if (isRecording) {      mediaProcessor.cancelRecording();      setIsRecording(false);      setRecordingStream(null);    }  };     return {    processMedia,    processBatch,    startAudioRecording,    stopAudioRecording,    startVideoRecording,    stopVideoRecording,    cancelRecording,    loading,    error,    result,    isRecording,    recordingStream  }; }``

### src/services/knowledge/analyzers/ContentAnalyzer.ts

``import { LLMService } from '@/services/llm/LLMService'; import { ComplexityAnalyzer } from './ComplexityAnalyzer'; export class ContentAnalyzer {   private llmService: LLMService;  private complexityAnalyzer: ComplexityAnalyzer;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });    this.complexityAnalyzer = new ComplexityAnalyzer();  }   /**   * Analisa o conteúdo de um documento   */  async analyze(content: string): Promise<{    topics: string[];    entities: Array<{      name: string;      type: string;      relevance: number;      mentions: number;    }>;    sentiment: {      label: 'positive' | 'negative' | 'neutral';      score: number;    };    complexity: {      score: number;      readability: string;      metrics: {        sentenceLength: number;        wordLength: number;        lexicalDensity: number;        longWordPercentage: number;      };    };    style: {      tone: string;      formality: number;      technicalLevel: number;    };    statistics: {      wordCount: number;      sentenceCount: number;      paragraphCount: number;      averageWordsPerSentence: number;      uniqueWords: number;    };  }> {    try {      // Analisar tópicos e entidades      const topicsAndEntities = await this.analyzeTopicsAndEntities(content);       // Analisar sentimento      const sentiment = await this.analyzeSentiment(content);       // Analisar complexidade      const complexity = await this.complexityAnalyzer.analyze(content);       // Analisar estilo      const style = await this.analyzeStyle(content);       // Calcular estatísticas      const statistics = this.calculateStatistics(content);       return {        ...topicsAndEntities,        sentiment,        complexity,        style,        statistics      };    } catch (error) {      console.error('Erro na análise de conteúdo:', error);      throw error;    }  }   /**   * Analisa tópicos e entidades no texto   */  private async analyzeTopicsAndEntities(content: string): Promise<{    topics: string[];    entities: Array<{      name: string;      type: string;      relevance: number;      mentions: number;    }>;  }> {    const prompt = `    Analise o seguinte texto e extraia:    1. Principais tópicos abordados    2. Entidades mencionadas (pessoas, organizações, tecnologias, etc.)     Para cada entidade, determine:    - Tipo (pessoa, organização, tecnologia, conceito, etc.)    - Relevância (0-1)    - Número de menções     Retorne no formato JSON:    {      "topics": ["tópico1", "tópico2", ...],      "entities": [        {          "name": "nome da entidade",          "type": "tipo da entidade",          "relevance": 0.X,          "mentions": N        },        ...      ]    }     Texto para análise:    ${content.substring(0, 3000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido');    } catch (error) {      console.error('Erro ao analisar tópicos e entidades:', error);      return {        topics: [],        entities: []      };    }  }   /**   * Analisa o sentimento do texto   */  private async analyzeSentiment(content: string): Promise<{    label: 'positive' | 'negative' | 'neutral';    score: number;  }> {    const prompt = `    Analise o sentimento do seguinte texto e determine:    1. Se é positivo, negativo ou neutro    2. Um score de -1 (muito negativo) a 1 (muito positivo)     Retorne apenas o JSON:    {      "label": "positive|negative|neutral",      "score": X.XX    }     Texto para análise:    ${content.substring(0, 2000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 100      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido');    } catch (error) {      console.error('Erro ao analisar sentimento:', error);      return {        label: 'neutral',        score: 0      };    }  }   /**   * Analisa o estilo do texto   */  private async analyzeStyle(content: string): Promise<{    tone: string;    formality: number;    technicalLevel: number;  }> {    const prompt = `    Analise o estilo de escrita do seguinte texto e determine:    1. Tom geral (formal, informal, técnico, casual, etc.)    2. Nível de formalidade (0-1)    3. Nível técnico (0-1)     Retorne apenas o JSON:    {      "tone": "descrição do tom",      "formality": X.XX,      "technicalLevel": X.XX    }     Texto para análise:    ${content.substring(0, 2000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 100      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido');    } catch (error) {      console.error('Erro ao analisar estilo:', error);      return {        tone: 'neutro',        formality: 0.5,        technicalLevel: 0.5      };    }  }   /**   * Calcula estatísticas do texto   */  private calculateStatistics(content: string): {    wordCount: number;    sentenceCount: number;    paragraphCount: number;    averageWordsPerSentence: number;    uniqueWords: number;  } {    // Dividir em parágrafos    const paragraphs = content.split(/\n\s*\n/).filter(Boolean);    const paragraphCount = paragraphs.length;     // Dividir em sentenças    const sentences = content.split(/[.!?]+/).filter(Boolean);    const sentenceCount = sentences.length;     // Dividir em palavras    const words = content.toLowerCase()      .replace(/[^\w\s]/g, '')      .split(/\s+/)      .filter(Boolean);    const wordCount = words.length;     // Calcular palavras únicas    const uniqueWords = new Set(words).size;     // Calcular média de palavras por sentença    const averageWordsPerSentence = sentenceCount > 0      ? wordCount / sentenceCount      : 0;     return {      wordCount,      sentenceCount,      paragraphCount,      averageWordsPerSentence,      uniqueWords    };  } }``

### src/services/markdown/MarkdownProcessor.ts

`import { marked } from 'marked'; import { remark } from 'remark'; import remarkGfm from 'remark-gfm'; import remarkFrontmatter from 'remark-frontmatter'; import rehypeRaw from 'rehype-raw'; import rehypeHighlight from 'rehype-highlight'; import { unified } from 'unified'; import yaml from 'js-yaml'; interface MarkdownMeta {   title?: string;  description?: string;  tags?: string[];  date?: string;  author?: string;  [key: string]: any; } interface ProcessedMarkdown {   content: string;  html: string;  meta: MarkdownMeta;  structure: {    headings: Array<{      level: number;      text: string;      id: string;    }>;    links: Array<{      text: string;      url: string;      title?: string;    }>;    images: Array<{      alt: string;      url: string;      title?: string;    }>;    codeBlocks: Array<{      language: string;      code: string;    }>;  }; } export class MarkdownProcessor {   /**   * Processa um documento Markdown   */  async process(markdown: string): Promise<ProcessedMarkdown> {    try {      // Extrair metadados do frontmatter      const meta = await this.extractMeta(markdown);       // Processar markdown para HTML      const html = await this.convertToHtml(markdown);       // Extrair estrutura do documento      const structure = await this.extractStructure(markdown);       return {        content: markdown,        html,        meta,        structure      };    } catch (error) {      console.error('Erro ao processar markdown:', error);      throw error;    }  }   /**   * Extrai metadados do frontmatter   */  private async extractMeta(markdown: string): Promise<MarkdownMeta> {    try {      const processor = unified()        .use(remarkFrontmatter)        .use(() => (tree) => {          let meta = {};          // @ts-ignore (tipos do remark)          if (tree.children[0]?.type === 'yaml') {            try {              // @ts-ignore (tipos do remark)              meta = yaml.load(tree.children[0].value) || {};            } catch (error) {              console.warn('Erro ao processar frontmatter YAML:', error);            }          }          return meta;        });       const result = await processor.process(markdown);      return result.data as MarkdownMeta;    } catch (error) {      console.warn('Erro ao extrair metadados:', error);      return {};    }  }   /**   * Converte Markdown para HTML   */  private async convertToHtml(markdown: string): Promise<string> {    const processor = unified()      .use(remarkGfm)      .use(remarkFrontmatter)      .use(rehypeRaw)      .use(rehypeHighlight)      .use(() => (tree) => {        // Remover frontmatter antes de converter para HTML        // @ts-ignore (tipos do remark)        if (tree.children[0]?.type === 'yaml') {          // @ts-ignore (tipos do remark)          tree.children.shift();        }        return tree;      });     const result = await processor.process(markdown);    return result.toString();  }   /**   * Extrai estrutura do documento   */  private async extractStructure(markdown: string): Promise<{    headings: Array<{      level: number;      text: string;      id: string;    }>;    links: Array<{      text: string;      url: string;      title?: string;    }>;    images: Array<{      alt: string;      url: string;      title?: string;    }>;    codeBlocks: Array<{      language: string;      code: string;    }>;  }> {    const tokens = marked.lexer(markdown);    const structure = {      headings: [] as Array<{        level: number;        text: string;        id: string;      }>,      links: [] as Array<{        text: string;        url: string;        title?: string;      }>,      images: [] as Array<{        alt: string;        url: string;        title?: string;      }>,      codeBlocks: [] as Array<{        language: string;        code: string;      }>    };     // Função auxiliar para extrair recursivamente tokens    const extractFromTokens = (tokens: marked.Token[]) => {      for (const token of tokens) {        switch (token.type) {          case 'heading':            structure.headings.push({              level: token.depth,              text: token.text,              id: this.generateHeadingId(token.text)            });            break;           case 'link':            structure.links.push({              text: token.text,              url: token.href,              title: token.title            });            break;           case 'image':            structure.images.push({              alt: token.text,              url: token.href,              title: token.title            });            break;           case 'code':            structure.codeBlocks.push({              language: token.lang || '',              code: token.text            });            break;           case 'list':            // Processar itens da lista recursivamente            token.items.forEach(item => {              if (item.tokens) {                extractFromTokens(item.tokens);              }            });            break;           case 'paragraph':          case 'blockquote':            // Processar tokens internos            if ('tokens' in token && token.tokens) {              extractFromTokens(token.tokens);            }            break;        }      }    };     // Processar todos os tokens    extractFromTokens(tokens);     return structure;  }   /**   * Gera um ID para um cabeçalho   */  private generateHeadingId(text: string): string {    return text      .toLowerCase()      .replace(/[^a-z0-9]+/g, '-')      .replace(/(^-|-$)/g, '');  }   /**   * Extrai links do documento   */  extractLinks(markdown: string): Array<{    text: string;    url: string;    title?: string;  }> {    const linkRegex = /\[([^\]]+)\]\(([^)]+)(?:\s+"([^"]+)")?\)/g;    const links = [];    let match;     while ((match = linkRegex.exec(markdown)) !== null) {      links.push({        text: match[1],        url: match[2],        title: match[3]      });    }     return links;  }   /**   * Extrai imagens do documento   */  extractImages(markdown: string): Array<{    alt: string;    url: string;    title?: string;  }> {    const imageRegex = /!\[([^\]]*)\]\(([^)]+)(?:\s+"([^"]+)")?\)/g;    const images = [];    let match;     while ((match = imageRegex.exec(markdown)) !== null) {      images.push({        alt: match[1],        url: match[2],        title: match[3]      });    }     return images;  }   /**   * Extrai blocos de código do documento   */  extractCodeBlocks(markdown: string): Array<{    language: string;    code: string;  }> {    const codeBlockRegex = /```(\w*)\n([\s\S]*?)```/g;    const codeBlocks = [];    let match;     while ((match = codeBlockRegex.exec(markdown)) !== null) {      codeBlocks.push({        language: match[1],        code: match[2].trim()      });    }     return codeBlocks;  } }`

### src/services/media/BaseMediaProcessor.ts

``import { MediaProcessingResult, ProcessingOptions } from '@/types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export abstract class BaseMediaProcessor {   protected cacheService: CacheService<MediaProcessingResult>;  protected monitoringService: MonitoringService;   constructor(    cacheService: CacheService<MediaProcessingResult>,    monitoringService: MonitoringService  ) {    this.cacheService = cacheService;    this.monitoringService = monitoringService;  }   /**   * Processa um arquivo de mídia   */  abstract processFile(file: File, options?: ProcessingOptions): Promise<MediaProcessingResult>;   /**   * Processa uma URL de mídia   */  abstract processUrl(url: string, options?: ProcessingOptions): Promise<MediaProcessingResult>;   /**   * Gera uma chave de cache para um arquivo ou URL   */  protected generateCacheKey(input: File | string): string {    if (input instanceof File) {      return `${input.name}-${input.size}-${input.lastModified}`;    }    return `url-${input}`;  }   /**   * Valida um arquivo de mídia   */  protected validateFile(file: File, allowedTypes: string[]): void {    if (!file) {      throw new Error('Nenhum arquivo fornecido');    }     if (!allowedTypes.some(type => file.type.startsWith(type))) {      throw new Error(        `Tipo de arquivo não suportado. Tipos permitidos: ${allowedTypes.join(', ')}`      );    }  }   /**   * Valida uma URL de mídia   */  protected validateUrl(url: string): void {    try {      new URL(url);    } catch {      throw new Error('URL inválida');    }  }   /**   * Converte um arquivo para Base64   */  protected async fileToBase64(file: File): Promise<string> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.readAsDataURL(file);      reader.onload = () => resolve(reader.result as string);      reader.onerror = error => reject(error);    });  }   /**   * Registra métricas de processamento   */  protected logProcessingMetrics(    input: File | string,    result: MediaProcessingResult,    processingTime: number  ): void {    const inputType = input instanceof File ? 'file' : 'url';    const inputSize = input instanceof File ? input.size : 0;     this.monitoringService.logEvent({      type: 'media_processing',      mediaType: result.mediaType,      inputType,      inputSize,      processingTime,      success: true    });  }   /**   * Registra erros de processamento   */  protected logProcessingError(    input: File | string,    error: Error  ): void {    const inputType = input instanceof File ? 'file' : 'url';    const inputSize = input instanceof File ? input.size : 0;     this.monitoringService.logEvent({      type: 'media_processing_error',      mediaType: inputType === 'file' ? input.type : 'unknown',      inputType,      inputSize,      error: error.message    });  } }``

### src/services/media/ImageProcessor.ts

``import { BaseMediaProcessor } from './BaseMediaProcessor'; import { MediaProcessingResult, ProcessingOptions } from '@/types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class ImageProcessor extends BaseMediaProcessor {   private allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];   constructor(    cacheService: CacheService<MediaProcessingResult>,    monitoringService: MonitoringService  ) {    super(cacheService, monitoringService);  }   /**   * Processa um arquivo de imagem   */  async processFile(file: File, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateFile(file, this.allowedTypes);       const cacheKey = this.generateCacheKey(file);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Converter arquivo para Base64      const base64 = await this.fileToBase64(file);             // Carregar imagem para análise      const image = await this.loadImage(base64);             // Extrair informações da imagem      const imageInfo = await this.analyzeImage(image);             // Aplicar processamentos adicionais se necessário      const processed = await this.applyProcessing(image, options);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'image',        originalFile: file,        processedData: processed,        metadata: {          ...imageInfo,          processingTime,          options        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(file, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(file, error as Error);      throw error;    }  }   /**   * Processa uma URL de imagem   */  async processUrl(url: string, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateUrl(url);       const cacheKey = this.generateCacheKey(url);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Baixar imagem      const response = await fetch(url);      if (!response.ok) {        throw new Error(`Erro ao baixar imagem: ${response.statusText}`);      }       const blob = await response.blob();      if (!this.allowedTypes.includes(blob.type)) {        throw new Error(`Tipo de imagem não suportado: ${blob.type}`);      }       // Converter para Base64      const base64 = await this.fileToBase64(        new File([blob], 'image', { type: blob.type })      );             // Carregar imagem para análise      const image = await this.loadImage(base64);             // Extrair informações da imagem      const imageInfo = await this.analyzeImage(image);             // Aplicar processamentos adicionais se necessário      const processed = await this.applyProcessing(image, options);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'image',        originalUrl: url,        processedData: processed,        metadata: {          ...imageInfo,          processingTime,          options        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(url, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(url, error as Error);      throw error;    }  }   /**   * Carrega uma imagem a partir de uma URL ou Base64   */  private loadImage(src: string): Promise<HTMLImageElement> {    return new Promise((resolve, reject) => {      const img = new Image();      img.onload = () => resolve(img);      img.onerror = () => reject(new Error('Erro ao carregar imagem'));      img.src = src;    });  }   /**   * Analisa uma imagem e extrai informações   */  private async analyzeImage(image: HTMLImageElement): Promise<{    width: number;    height: number;    aspectRatio: number;    size: number;    format: string;  }> {    return {      width: image.width,      height: image.height,      aspectRatio: image.width / image.height,      size: 0, // Será preenchido com o tamanho real do arquivo      format: image.src.startsWith('data:image/')        ? image.src.split(';')[0].split('/')[1]        : 'unknown'    };  }   /**   * Aplica processamentos adicionais na imagem   */  private async applyProcessing(    image: HTMLImageElement,    options?: ProcessingOptions  ): Promise<{    base64: string;    width: number;    height: number;  }> {    const canvas = document.createElement('canvas');    const ctx = canvas.getContext('2d');         if (!ctx) {      throw new Error('Contexto 2D não disponível');    }     // Aplicar redimensionamento se necessário    let width = image.width;    let height = image.height;     if (options?.maxWidth && width > options.maxWidth) {      const ratio = options.maxWidth / width;      width = options.maxWidth;      height = height * ratio;    }     if (options?.maxHeight && height > options.maxHeight) {      const ratio = options.maxHeight / height;      height = options.maxHeight;      width = width * ratio;    }     canvas.width = width;    canvas.height = height;     // Desenhar imagem no canvas    ctx.drawImage(image, 0, 0, width, height);     // Aplicar filtros se necessário    if (options?.filters) {      this.applyFilters(ctx, options.filters);    }     return {      base64: canvas.toDataURL('image/jpeg', 0.9),      width,      height    };  }   /**   * Aplica filtros em um contexto de canvas   */  private applyFilters(    ctx: CanvasRenderingContext2D,    filters: Record<string, number>  ): void {    // Implementar aplicação de filtros    // Exemplo: brilho, contraste, saturação, etc.    const { width, height } = ctx.canvas;    const imageData = ctx.getImageData(0, 0, width, height);    const data = imageData.data;     // Aplicar filtros pixel por pixel    for (let i = 0; i < data.length; i += 4) {      // Aplicar brilho      if (filters.brightness) {        data[i] = Math.min(255, data[i] * filters.brightness);     // R        data[i + 1] = Math.min(255, data[i + 1] * filters.brightness); // G        data[i + 2] = Math.min(255, data[i + 2] * filters.brightness); // B      }       // Aplicar contraste      if (filters.contrast) {        const factor = (259 * (filters.contrast + 255)) / (255 * (259 - filters.contrast));        data[i] = factor * (data[i] - 128) + 128;     // R        data[i + 1] = factor * (data[i + 1] - 128) + 128; // G        data[i + 2] = factor * (data[i + 2] - 128) + 128; // B      }    }     ctx.putImageData(imageData, 0, 0);  } }``

### src/services/media/AudioProcessor.ts

``import { BaseMediaProcessor } from './BaseMediaProcessor'; import { MediaProcessingResult, ProcessingOptions } from '@/types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class AudioProcessor extends BaseMediaProcessor {   private allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm'];  private audioContext: AudioContext | null = null;   constructor(    cacheService: CacheService<MediaProcessingResult>,    monitoringService: MonitoringService  ) {    super(cacheService, monitoringService);         // Inicializar AudioContext sob demanda para evitar problemas em browsers    if (typeof window !== 'undefined' && 'AudioContext' in window) {      this.audioContext = new AudioContext();    }  }   /**   * Processa um arquivo de áudio   */  async processFile(file: File, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateFile(file, this.allowedTypes);       const cacheKey = this.generateCacheKey(file);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Ler o arquivo como ArrayBuffer      const arrayBuffer = await this.readFileAsArrayBuffer(file);             // Decodificar o áudio      const audioBuffer = await this.decodeAudio(arrayBuffer);             // Extrair informações do áudio      const audioInfo = await this.analyzeAudio(audioBuffer);             // Aplicar processamentos adicionais se necessário      const processed = await this.applyProcessing(audioBuffer, options);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'audio',        originalFile: file,        processedData: processed,        metadata: {          ...audioInfo,          processingTime,          options        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(file, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(file, error as Error);      throw error;    }  }   /**   * Processa uma URL de áudio   */  async processUrl(url: string, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateUrl(url);       const cacheKey = this.generateCacheKey(url);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Baixar áudio      const response = await fetch(url);      if (!response.ok) {        throw new Error(`Erro ao baixar áudio: ${response.statusText}`);      }       const blob = await response.blob();      const arrayBuffer = await blob.arrayBuffer();             // Decodificar o áudio      const audioBuffer = await this.decodeAudio(arrayBuffer);             // Extrair informações do áudio      const audioInfo = await this.analyzeAudio(audioBuffer);             // Aplicar processamentos adicionais se necessário      const processed = await this.applyProcessing(audioBuffer, options);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'audio',        originalUrl: url,        processedData: processed,        metadata: {          ...audioInfo,          processingTime,          options        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(url, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(url, error as Error);      throw error;    }  }   /**   * Lê um arquivo como ArrayBuffer   */  private readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as ArrayBuffer);      reader.onerror = () => reject(new Error('Erro ao ler arquivo de áudio'));      reader.readAsArrayBuffer(file);    });  }   /**   * Decodifica um ArrayBuffer em AudioBuffer   */  private async decodeAudio(arrayBuffer: ArrayBuffer): Promise<AudioBuffer> {    if (!this.audioContext) {      throw new Error('AudioContext não disponível');    }     try {      return await this.audioContext.decodeAudioData(arrayBuffer);    } catch (error) {      throw new Error('Erro ao decodificar áudio: ' + (error as Error).message);    }  }   /**   * Analisa um AudioBuffer e extrai informações   */  private async analyzeAudio(audioBuffer: AudioBuffer): Promise<{    duration: number;    sampleRate: number;    numberOfChannels: number;    format: string;    averageAmplitude: number;    peakAmplitude: number;  }> {    // Calcular amplitude média e pico    let sum = 0;    let peak = 0;         const channel = audioBuffer.getChannelData(0);         for (let i = 0; i < channel.length; i++) {      const amplitude = Math.abs(channel[i]);      sum += amplitude;      peak = Math.max(peak, amplitude);    }         const averageAmplitude = sum / channel.length;     return {      duration: audioBuffer.duration,      sampleRate: audioBuffer.sampleRate,      numberOfChannels: audioBuffer.numberOfChannels,      format: 'wav', // Formato padrão para AudioBuffer      averageAmplitude,      peakAmplitude: peak    };  }   /**   * Aplica processamentos adicionais no áudio   */  private async applyProcessing(    audioBuffer: AudioBuffer,    options?: ProcessingOptions  ): Promise<{    duration: number;    sampleRate: number;  }> {    // Implementar processamentos como normalização, corte, etc.    // Para este exemplo, apenas retornamos as propriedades básicas     return {      duration: audioBuffer.duration,      sampleRate: audioBuffer.sampleRate    };  } }``

### src/services/media/VideoProcessor.ts

`import { BaseMediaProcessor } from './BaseMediaProcessor'; import { MediaProcessingResult, ProcessingOptions } from '@/types/media'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class VideoProcessor extends BaseMediaProcessor {   private allowedTypes = ['video/mp4', 'video/webm', 'video/ogg'];   constructor(    cacheService: CacheService<MediaProcessingResult>,    monitoringService: MonitoringService  ) {    super(cacheService, monitoringService);  }   /**   * Processa um arquivo de vídeo   */  async processFile(file: File, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateFile(file, this.allowedTypes);       const cacheKey = this.generateCacheKey(file);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Converter arquivo para URL      const videoUrl = URL.createObjectURL(file);             // Carregar vídeo para análise      const video = await this.loadVideo(videoUrl);             // Extrair informações do vídeo      const videoInfo = await this.analyzeVideo(video);             // Capturar frames do vídeo      const frames = await this.captureFrames(video, options?.frameCount || 3);             // Limpar URL do objeto      URL.revokeObjectURL(videoUrl);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'video',        originalFile: file,        processedData: {          ...videoInfo,          frames        },        metadata: {          ...videoInfo,          processingTime,          options,          frameCount: frames.length        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(file, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(file, error as Error);      throw error;    }  }   /**   * Processa uma URL de vídeo   */  async processUrl(url: string, options?: ProcessingOptions): Promise<MediaProcessingResult> {    try {      this.validateUrl(url);       const cacheKey = this.generateCacheKey(url);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();             // Carregar vídeo para análise      const video = await this.loadVideo(url);             // Extrair informações do vídeo      const videoInfo = await this.analyzeVideo(video);             // Capturar frames do vídeo      const frames = await this.captureFrames(video, options?.frameCount || 3);             const processingTime = performance.now() - startTime;             const result: MediaProcessingResult = {        mediaType: 'video',        originalUrl: url,        processedData: {          ...videoInfo,          frames        },        metadata: {          ...videoInfo,          processingTime,          options,          frameCount: frames.length        }      };       // Armazenar no cache      await this.cacheService.set(cacheKey, result);             // Registrar métricas      this.logProcessingMetrics(url, result, processingTime);       return result;    } catch (error) {      this.logProcessingError(url, error as Error);      throw error;    }  }   /**   * Carrega um vídeo a partir de uma URL   */  private loadVideo(url: string): Promise<HTMLVideoElement> {    return new Promise((resolve, reject) => {      const video = document.createElement('video');      video.crossOrigin = 'anonymous';      video.muted = true;             video.onloadedmetadata = () => {        // Precarregar um pouco do vídeo para garantir acesso aos frames        video.currentTime = 0.1;        video.addEventListener('seeked', () => resolve(video), { once: true });      };             video.onerror = () => reject(new Error('Erro ao carregar vídeo'));      video.src = url;    });  }   /**   * Analisa um vídeo e extrai informações   */  private async analyzeVideo(video: HTMLVideoElement): Promise<{    width: number;    height: number;    duration: number;    aspectRatio: number;    fps?: number;  }> {    return {      width: video.videoWidth,      height: video.videoHeight,      duration: video.duration,      aspectRatio: video.videoWidth / video.videoHeight    };  }   /**   * Captura frames de um vídeo   */  private async captureFrames(    video: HTMLVideoElement,    count: number  ): Promise<string[]> {    const frames: string[] = [];    const duration = video.duration;         // Verificar se o vídeo tem duração    if (!duration || isNaN(duration) || duration <= 0) {      return frames;    }         // Configurar canvas    const canvas = document.createElement('canvas');    canvas.width = video.videoWidth;    canvas.height = video.videoHeight;    const ctx = canvas.getContext('2d');         if (!ctx) {      throw new Error('Contexto 2D não disponível');    }         // Capturar frames em intervalos regulares    const interval = duration / (count + 1);         for (let i = 1; i <= count; i++) {      const time = interval * i;      const frame = await this.captureFrameAt(video, time, canvas, ctx);      frames.push(frame);    }         return frames;  }   /**   * Captura um frame de um vídeo em um tempo específico   */  private captureFrameAt(    video: HTMLVideoElement,    time: number,    canvas: HTMLCanvasElement,    ctx: CanvasRenderingContext2D  ): Promise<string> {    return new Promise((resolve) => {      const handleSeeked = () => {        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);        video.removeEventListener('seeked', handleSeeked);        resolve(dataUrl);      };             video.addEventListener('seeked', handleSeeked);      video.currentTime = Math.min(time, video.duration - 0.1);    });  } }`

### src/services/media/MediaProcessor.ts

``import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { MediaProcessingResult, ProcessingOptions } from '@/types/media'; import { ImageProcessor } from './ImageProcessor'; import { AudioProcessor } from './AudioProcessor'; import { VideoProcessor } from './VideoProcessor'; import { MediaRecordService } from './MediaRecordService'; export class MediaProcessor {   private imageProcessor: ImageProcessor;  private audioProcessor: AudioProcessor;  private videoProcessor: VideoProcessor;  private mediaRecordService: MediaRecordService;   constructor(    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    const cache = cacheService || new CacheService<MediaProcessingResult>();    const monitoring = monitoringService || new MonitoringService();         this.imageProcessor = new ImageProcessor(cache, monitoring);    this.audioProcessor = new AudioProcessor(cache, monitoring);    this.videoProcessor = new VideoProcessor(cache, monitoring);    this.mediaRecordService = new MediaRecordService(monitoring);  }   /**   * Processa um arquivo de mídia   */  async processFile(file: File, options?: ProcessingOptions): Promise<MediaProcessingResult> {    if (!file) {      throw new Error('Nenhum arquivo fornecido');    }     if (file.type.startsWith('image/')) {      return this.imageProcessor.processFile(file, options);    } else if (file.type.startsWith('audio/')) {      return this.audioProcessor.processFile(file, options);    } else if (file.type.startsWith('video/')) {      return this.videoProcessor.processFile(file, options);    } else {      throw new Error(`Tipo de arquivo não suportado: ${file.type}`);    }  }   /**   * Processa uma URL de mídia   */  async processUrl(url: string, mediaType: 'image' | 'audio' | 'video', options?: ProcessingOptions): Promise<MediaProcessingResult> {    if (!url) {      throw new Error('Nenhuma URL fornecida');    }     switch (mediaType) {      case 'image':        return this.imageProcessor.processUrl(url, options);      case 'audio':        return this.audioProcessor.processUrl(url, options);      case 'video':        return this.videoProcessor.processUrl(url, options);      default:        throw new Error(`Tipo de mídia não suportado: ${mediaType}`);    }  }   /**   * Processa um lote de arquivos   */  async processBatch(files: File[], options?: ProcessingOptions): Promise<MediaProcessingResult[]> {    if (!files.length) {      throw new Error('Nenhum arquivo fornecido');    }     // Processar em paralelo    const promises = files.map(file => this.processFile(file, options));    return Promise.all(promises);  }   /**   * Inicia a gravação de áudio   */  async startAudioRecording(): Promise<{    stream: MediaStream;  }> {    return this.mediaRecordService.startAudioRecording();  }   /**   * Para a gravação de áudio   */  async stopAudioRecording(): Promise<{    file: File;    url: string;    duration: number;  }> {    return this.mediaRecordService.stopRecording();  }   /**   * Inicia a gravação de vídeo   */  async startVideoRecording(): Promise<{    stream: MediaStream;  }> {    return this.mediaRecordService.startVideoRecording();  }   /**   * Para a gravação de vídeo   */  async stopVideoRecording(): Promise<{    file: File;    url: string;    duration: number;  }> {    return this.mediaRecordService.stopRecording();  }   /**   * Cancela a gravação em andamento   */  cancelRecording(): void {    this.mediaRecordService.cancelRecording();  } }``

### src/services/media/MediaRecordService.ts

``import { MonitoringService } from '../monitoring/MonitoringService'; export class MediaRecordService {   private monitoringService: MonitoringService;  private mediaRecorder: MediaRecorder | null = null;  private recordedChunks: Blob[] = [];  private stream: MediaStream | null = null;  private startTime: number = 0;   constructor(monitoringService: MonitoringService) {    this.monitoringService = monitoringService;  }   /**   * Inicia a gravação de áudio   */  async startAudioRecording(): Promise<{    stream: MediaStream;  }> {    try {      // Solicitar permissão para acessar o microfone      const stream = await navigator.mediaDevices.getUserMedia({        audio: true,        video: false      });       this.setupRecording(stream, 'audio/webm');             this.monitoringService.logEvent({        type: 'audio_recording_start'      });       return { stream };    } catch (error) {      this.monitoringService.logEvent({        type: 'audio_recording_error',        error: (error as Error).message      });      throw error;    }  }   /**   * Inicia a gravação de vídeo   */  async startVideoRecording(): Promise<{    stream: MediaStream;  }> {    try {      // Solicitar permissão para acessar a câmera e o microfone      const stream = await navigator.mediaDevices.getUserMedia({        audio: true,        video: {          width: { ideal: 1280 },          height: { ideal: 720 }        }      });       this.setupRecording(stream, 'video/webm');             this.monitoringService.logEvent({        type: 'video_recording_start'      });       return { stream };    } catch (error) {      this.monitoringService.logEvent({        type: 'video_recording_error',        error: (error as Error).message      });      throw error;    }  }   /**   * Configura a gravação   */  private setupRecording(stream: MediaStream, mimeType: string): void {    this.stream = stream;    this.recordedChunks = [];         // Criar MediaRecorder    this.mediaRecorder = new MediaRecorder(stream, {      mimeType    });         // Configurar evento de dados disponíveis    this.mediaRecorder.ondataavailable = (event) => {      if (event.data.size > 0) {        this.recordedChunks.push(event.data);      }    };         // Iniciar gravação    this.mediaRecorder.start();    this.startTime = Date.now();  }   /**   * Para a gravação   */  async stopRecording(): Promise<{    file: File;    url: string;    duration: number;  }> {    if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') {      throw new Error('Nenhuma gravação em andamento');    }     return new Promise((resolve, reject) => {      this.mediaRecorder!.onstop = () => {        try {          // Calcular duração          const duration = (Date.now() - this.startTime) / 1000;                     // Criar Blob          const mimeType = this.mediaRecorder!.mimeType;          const blob = new Blob(this.recordedChunks, { type: mimeType });                     // Criar URL          const url = URL.createObjectURL(blob);                     // Criar arquivo          const extension = mimeType.includes('audio') ? 'webm' : 'webm';          const filename = `recording-${Date.now()}.${extension}`;          const file = new File([blob], filename, { type: mimeType });                     // Interromper todas as faixas          if (this.stream) {            this.stream.getTracks().forEach(track => track.stop());            this.stream = null;          }                     // Registrar evento          this.monitoringService.logEvent({            type: mimeType.includes('audio') ? 'audio_recording_stop' : 'video_recording_stop',            duration,            fileSize: blob.size          });                     resolve({ file, url, duration });        } catch (error) {          reject(error);        }      };             this.mediaRecorder!.stop();    });  }   /**   * Cancela a gravação em andamento   */  cancelRecording(): void {    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {      this.mediaRecorder.stop();             // Interromper todas as faixas      if (this.stream) {        this.stream.getTracks().forEach(track => track.stop());        this.stream = null;      }             this.monitoringService.logEvent({        type: 'recording_cancelled'      });    }         this.recordedChunks = [];  } }``

### src/services/knowledge/KnowledgeService.ts

``import { ContentAnalyzer } from './analyzers/ContentAnalyzer'; import { KnowledgeExtractor } from './extractors/KnowledgeExtractor'; import { PromptGenerator } from './generators/PromptGenerator'; import { StructureGenerator } from './generators/StructureGenerator'; import { MetadataGenerator } from './generators/MetadataGenerator'; import { OutputValidator } from './validators/OutputValidator'; import { Document, ExtractedKnowledge, ProcessedDocument } from '@/types/knowledge'; export class KnowledgeService {   private contentAnalyzer: ContentAnalyzer;  private knowledgeExtractor: KnowledgeExtractor;  private promptGenerator: PromptGenerator;  private structureGenerator: StructureGenerator;  private metadataGenerator: MetadataGenerator;  private outputValidator: OutputValidator;   constructor() {    this.contentAnalyzer = new ContentAnalyzer();    this.knowledgeExtractor = new KnowledgeExtractor();    this.promptGenerator = new PromptGenerator();    this.structureGenerator = new StructureGenerator();    this.metadataGenerator = new MetadataGenerator();    this.outputValidator = new OutputValidator();  }   /**   * Processa um documento e extrai conhecimento estruturado   */  async processDocument(document: Document): Promise<ProcessedDocument> {    try {      // 1. Analisar conteúdo      console.log('Analisando conteúdo...');      const analysisResult = await this.contentAnalyzer.analyze(document.content);       // 2. Extrair conhecimento      console.log('Extraindo conhecimento...');      const extractedKnowledge = await this.knowledgeExtractor.extract(document.content, analysisResult);       // 3. Gerar estrutura      console.log('Gerando estrutura...');      const structure = await this.structureGenerator.generate(extractedKnowledge);       // 4. Gerar metadados      console.log('Gerando metadados...');      const metadata = await this.metadataGenerator.generate(document, extractedKnowledge);       // 5. Validar saída      console.log('Validando saída...');      const validationResult = await this.outputValidator.validate({        document,        extractedKnowledge,        structure,        metadata      });       // 6. Gerar prompts      console.log('Gerando prompts...');      const prompts = await this.promptGenerator.generatePrompts(extractedKnowledge, structure);       // Construir documento processado      const processedDocument: ProcessedDocument = {        id: document.id,        title: document.title,        content: document.content,        extractedKnowledge,        structure,        metadata,        prompts,        validationResult,        status: validationResult.isValid ? 'valid' : 'invalid',        processingDate: new Date().toISOString()      };       return processedDocument;    } catch (error) {      console.error('Erro ao processar documento:', error);      throw error;    }  }   /**   * Extrai conhecimento de um texto   */  async extractKnowledge(text: string): Promise<ExtractedKnowledge> {    try {      // 1. Analisar conteúdo      const analysisResult = await this.contentAnalyzer.analyze(text);       // 2. Extrair conhecimento      return await this.knowledgeExtractor.extract(text, analysisResult);    } catch (error) {      console.error('Erro ao extrair conhecimento:', error);      throw error;    }  }   /**   * Gera prompts baseados em um documento processado   */  async generatePrompts(document: ProcessedDocument): Promise<string[]> {    try {      return await this.promptGenerator.generatePrompts(        document.extractedKnowledge,        document.structure      );    } catch (error) {      console.error('Erro ao gerar prompts:', error);      throw error;    }  }   /**   * Otimiza um prompt existente   */  async optimizePrompt(prompt: string, targetModel: string): Promise<string> {    try {      return await this.promptGenerator.optimizePrompt(prompt, targetModel);    } catch (error) {      console.error('Erro ao otimizar prompt:', error);      throw error;    }  }   /**   * Analisa um conjunto de documentos para encontrar relações   */  async analyzeDocumentRelations(documents: Document[]): Promise<{    relations: Array<{      source: string;      target: string;      type: string;      strength: number;    }>;    clusters: Array<{      id: string;      documents: string[];      theme: string;    }>;  }> {    if (documents.length < 2) {      return { relations: [], clusters: [] };    }     try {      // 1. Extrair conhecimento de cada documento      const processedDocuments: ProcessedDocument[] = [];             for (const doc of documents) {        const processed = await this.processDocument(doc);        processedDocuments.push(processed);      }       // 2. Identificar relações entre documentos      const relations: Array<{        source: string;        target: string;        type: string;        strength: number;      }> = [];       // Comparar cada par de documentos      for (let i = 0; i < processedDocuments.length; i++) {        for (let j = i + 1; j < processedDocuments.length; j++) {          const doc1 = processedDocuments[i];          const doc2 = processedDocuments[j];                     // Calcular similaridade entre documentos          const similarity = this.calculateDocumentSimilarity(doc1, doc2);                     if (similarity.strength > 0.3) { // Limiar mínimo de similaridade            relations.push({              source: doc1.id,              target: doc2.id,              type: similarity.type,              strength: similarity.strength            });          }        }      }       // 3. Identificar clusters de documentos relacionados      const clusters = this.identifyClusters(processedDocuments, relations);       return { relations, clusters };    } catch (error) {      console.error('Erro ao analisar relações entre documentos:', error);      throw error;    }  }   /**   * Calcula a similaridade entre dois documentos   */  private calculateDocumentSimilarity(doc1: ProcessedDocument, doc2: ProcessedDocument): {    type: string;    strength: number;  } {    // Implementação simplificada para determinar similaridade         // Verificar sobreposição de conceitos    const concepts1 = doc1.extractedKnowledge.concepts || [];    const concepts2 = doc2.extractedKnowledge.concepts || [];         const commonConcepts = concepts1.filter(c1 =>      concepts2.some(c2 => c2.name === c1.name)    );         const conceptSimilarity = commonConcepts.length /      Math.max(1, Math.max(concepts1.length, concepts2.length));         // Determinar tipo de relação    let relationType = 'related';         if (conceptSimilarity > 0.7) {      relationType = 'highly-related';    } else if (doc1.metadata.category === doc2.metadata.category) {      relationType = 'same-category';    }         return {      type: relationType,      strength: conceptSimilarity    };  }   /**   * Identifica clusters de documentos relacionados   */  private identifyClusters(    documents: ProcessedDocument[],    relations: Array<{      source: string;      target: string;      type: string;      strength: number;    }>  ): Array<{    id: string;    documents: string[];    theme: string;  }> {    // Implementação simplificada de clustering         // Criar mapa de documentos conectados    const connectionMap: Record<string, string[]> = {};         documents.forEach(doc => {      connectionMap[doc.id] = [];    });         relations.forEach(relation => {      connectionMap[relation.source].push(relation.target);      connectionMap[relation.target].push(relation.source);    });         // Criar clusters usando BFS    const visited = new Set<string>();    const clusters: Array<{      id: string;      documents: string[];      theme: string;    }> = [];         for (const doc of documents) {      if (visited.has(doc.id)) continue;             // Iniciar novo cluster      const cluster: string[] = [];      const queue: string[] = [doc.id];      visited.add(doc.id);             // BFS para encontrar todos os documentos conectados      while (queue.length > 0) {        const current = queue.shift()!;        cluster.push(current);                 for (const neighbor of connectionMap[current]) {          if (!visited.has(neighbor)) {            visited.add(neighbor);            queue.push(neighbor);          }        }      }             // Adicionar cluster se contiver mais de um documento      if (cluster.length > 1) {        // Identificar tema do cluster        const clusterDocs = documents.filter(d => cluster.includes(d.id));        const theme = this.identifyClusterTheme(clusterDocs);                 clusters.push({          id: `cluster-${clusters.length + 1}`,          documents: cluster,          theme        });      }    }         return clusters;  }   /**   * Identifica o tema de um cluster de documentos   */  private identifyClusterTheme(documents: ProcessedDocument[]): string {    // Contar ocorrências de conceitos    const conceptCounts: Record<string, number> = {};         documents.forEach(doc => {      (doc.extractedKnowledge.concepts || []).forEach(concept => {        conceptCounts[concept.name] = (conceptCounts[concept.name] || 0) + 1;      });    });         // Encontrar conceitos mais comuns    const sortedConcepts = Object.entries(conceptCounts)      .sort((a, b) => b[1] - a[1])      .slice(0, 3)      .map(([name]) => name);         return sortedConcepts.length > 0      ? sortedConcepts.join(', ')      : 'Tema não identificado';  } }``

### src/services/knowledge/extractors/KnowledgeExtractor.ts

``import { LLMService } from '@/services/llm/LLMService'; import { SummaryExtractor } from './SummaryExtractor'; import { ExtractedKnowledge } from '@/types/knowledge'; export class KnowledgeExtractor {   private llmService: LLMService;  private summaryExtractor: SummaryExtractor;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });    this.summaryExtractor = new SummaryExtractor();  }   /**   * Extrai conhecimento estruturado de um texto   */  async extract(content: string, analysisResult: any): Promise<ExtractedKnowledge> {    try {      // Extrair resumo      const summary = await this.summaryExtractor.extract(content);       // Extrair conceitos      const concepts = await this.extractConcepts(content);       // Extrair relacionamentos      const relationships = await this.extractRelationships(content, concepts);       // Extrair dependências      const dependencies = await this.extractDependencies(content);       // Extrair requisitos      const requirements = await this.extractRequirements(content);       return {        summary,        concepts,        relationships,        dependencies,        requirements,        analysisMetadata: {          processingDate: new Date().toISOString(),          contentLength: content.length,          topics: analysisResult.topics || []        }      };    } catch (error) {      console.error('Erro na extração de conhecimento:', error);      throw error;    }  }   /**   * Extrai conceitos de um texto   */  private async extractConcepts(content: string): Promise<Array<{    name: string;    description?: string;    category?: string;    importance: number;  }>> {    const prompt = `    Analise o seguinte texto e extraia os principais conceitos técnicos, entidades e termos importantes.         Para cada conceito, forneça:    1. Nome    2. Breve descrição (opcional)    3. Categoria (ex: tecnologia, metodologia, design pattern, etc.)    4. Nível de importância (0.0-1.0)         Retorne apenas o JSON:    [      {        "name": "nome do conceito",        "description": "breve descrição",        "category": "categoria",        "importance": 0.X      },      ...    ]         Texto para análise:    ${content.substring(0, 3000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para conceitos');    } catch (error) {      console.error('Erro ao extrair conceitos:', error);      return [];    }  }   /**   * Extrai relacionamentos entre conceitos   */  private async extractRelationships(    content: string,    concepts: Array<{      name: string;      description?: string;      category?: string;      importance: number;    }>  ): Promise<Array<{    source: string;    target: string;    type: string;    description?: string;  }>> {    if (concepts.length < 2) {      return [];    }     const conceptNames = concepts.map(c => c.name).join(', ');         const prompt = `    Analise o seguinte texto e identifique relacionamentos entre os conceitos mencionados.         Conceitos identificados: ${conceptNames}         Para cada relacionamento, forneça:    1. Conceito de origem    2. Conceito de destino    3. Tipo de relacionamento (ex: depende de, contém, amplia, etc.)    4. Breve descrição do relacionamento (opcional)         Retorne apenas o JSON:    [      {        "source": "conceito origem",        "target": "conceito destino",        "type": "tipo de relacionamento",        "description": "descrição do relacionamento"      },      ...    ]         Texto para análise:    ${content.substring(0, 3000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para relacionamentos');    } catch (error) {      console.error('Erro ao extrair relacionamentos:', error);      return [];    }  }   /**   * Extrai dependências de um texto   */  private async extractDependencies(content: string): Promise<Array<{    name: string;    version?: string;    type: string;    priority: 'high' | 'medium' | 'low';    description?: string;  }>> {    const prompt = `    Analise o seguinte texto e extraia todas as dependências técnicas mencionadas.         Para cada dependência, forneça:    1. Nome    2. Versão (se mencionada)    3. Tipo (ex: biblioteca, framework, ferramenta, etc.)    4. Prioridade (high, medium, low)    5. Breve descrição (opcional)         Retorne apenas o JSON:    [      {        "name": "nome da dependência",        "version": "versão (se mencionada)",        "type": "tipo",        "priority": "high|medium|low",        "description": "descrição opcional"      },      ...    ]         Texto para análise:    ${content.substring(0, 3000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para dependências');    } catch (error) {      console.error('Erro ao extrair dependências:', error);      return [];    }  }   /**   * Extrai requisitos de um texto   */  private async extractRequirements(content: string): Promise<Array<{    id: string;    description: string;    type: 'functional' | 'non-functional';    priority: 'high' | 'medium' | 'low';  }>> {    const prompt = `    Analise o seguinte texto e extraia todos os requisitos mencionados.         Para cada requisito, forneça:    1. ID único (req-XX)    2. Descrição    3. Tipo (functional ou non-functional)    4. Prioridade (high, medium, low)         Retorne apenas o JSON:    [      {        "id": "req-XX",        "description": "descrição do requisito",        "type": "functional|non-functional",        "priority": "high|medium|low"      },      ...    ]         Texto para análise:    ${content.substring(0, 3000)}... (texto truncado)    `;     try {      const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para requisitos');    } catch (error) {      console.error('Erro ao extrair requisitos:', error);      return [];    }  } }``

### src/services/knowledge/generators/PromptGenerator.ts

``import { LLMService } from '@/services/llm/LLMService'; import { ExtractedKnowledge } from '@/types/knowledge'; export class PromptGenerator {   private llmService: LLMService;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }   /**   * Gera prompts executáveis a partir de conhecimento extraído   */  async generatePrompts(    extractedKnowledge: ExtractedKnowledge,    structure: any  ): Promise<string[]> {    try {      // Formatar conhecimento extraído para passar ao LLM      const knowledgeJSON = JSON.stringify({        summary: extractedKnowledge.summary,        concepts: extractedKnowledge.concepts,        relationships: extractedKnowledge.relationships,        dependencies: extractedKnowledge.dependencies,        requirements: extractedKnowledge.requirements      }, null, 2);       const structureJSON = JSON.stringify(structure, null, 2);       const prompt = `      Você é um especialista em converter documentação em prompts executáveis.             A partir do seguinte conhecimento extraído e estrutura, gere uma série de prompts      que podem ser executados por um desenvolvedor ou modelo de linguagem para implementar      este sistema.             Os prompts devem:      1. Ser claros e específicos      2. Incluir contexto necessário      3. Ser ordenados para implementação progressiva      4. Incluir instruções para testes e validação             Conhecimento Extraído:      ${knowledgeJSON}             Estrutura:      ${structureJSON}             Forneça os prompts no formato:             # Prompt 1: [Título]      [Corpo do prompt]             # Prompt 2: [Título]      [Corpo do prompt]             ...      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.7,        maxTokens: 2000      });       // Extrair prompts da resposta      return this.parsePromptsFromResponse(response);    } catch (error) {      console.error('Erro ao gerar prompts:', error);      return [];    }  }   /**   * Otimiza um prompt existente para um modelo específico   */  async optimizePrompt(promptText: string, targetModel: string): Promise<string> {    try {      const prompt = `      Você é um especialista em engenharia de prompts para modelos de linguagem.             Otimize o seguinte prompt para o modelo ${targetModel}, mantendo sua intenção      e objetivo, mas melhorando sua clareza, eficiência e capacidade de gerar resultados      de alta qualidade.             Prompt Original:      ${promptText}             Forneça apenas o prompt otimizado como resposta, sem introdução ou explicação.      `;       return await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.5,        maxTokens: 1500      });    } catch (error) {      console.error('Erro ao otimizar prompt:', error);      return promptText;    }  }   /**   * Gera um prompt para uma tarefa específica   */  async generateTaskPrompt(taskDescription: string, context: string): Promise<string> {    try {      const prompt = `      Gere um prompt detalhado para a seguinte tarefa:             Tarefa: ${taskDescription}             Contexto relevante:      ${context}             O prompt deve incluir:      1. Uma descrição clara do objetivo      2. Contexto necessário      3. Restrições e requisitos      4. Critérios de aceitação      5. Exemplos relevantes (se aplicável)             Forneça apenas o prompt gerado como resposta, sem introdução ou explicação.      `;       return await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.6,        maxTokens: 1200      });    } catch (error) {      console.error('Erro ao gerar prompt de tarefa:', error);      return `Falha ao gerar prompt para: ${taskDescription}`;    }  }   /**   * Analisa prompts de uma resposta de texto   */  private parsePromptsFromResponse(response: string): string[] {    const promptRegex = /# Prompt \d+: .+?\n([\s\S]+?)(?=\n# Prompt \d+:|$)/g;    const prompts: string[] = [];         let match;    while ((match = promptRegex.exec(response)) !== null) {      prompts.push(match[0].trim());    }         return prompts;  } }``

### src/services/knowledge/generators/StructureGenerator.ts

``import { LLMService } from '@/services/llm/LLMService'; import { ExtractedKnowledge } from '@/types/knowledge'; export class StructureGenerator {   private llmService: LLMService;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }   /**   * Gera uma estrutura a partir de conhecimento extraído   */  async generate(extractedKnowledge: ExtractedKnowledge): Promise<{    components: Array<{      name: string;      type: string;      purpose: string;      dependencies: string[];    }>;    modules: Array<{      name: string;      components: string[];      purpose: string;    }>;    fileStructure: {      directories: Array<{        name: string;        purpose: string;        children: Array<string | { name: string, type: string }>;      }>;    };    dataSchema?: Record<string, any>;  }> {    try {      // Formatar conhecimento extraído para passar ao LLM      const knowledgeJSON = JSON.stringify({        summary: extractedKnowledge.summary,        concepts: extractedKnowledge.concepts,        relationships: extractedKnowledge.relationships,        dependencies: extractedKnowledge.dependencies,        requirements: extractedKnowledge.requirements      }, null, 2);       const prompt = `      Você é um especialista em arquitetura de software e estruturação de aplicações.             A partir do seguinte conhecimento extraído, gere uma estrutura de aplicação      que atenda aos requisitos e conceitos identificados.             Conhecimento Extraído:      ${knowledgeJSON}             Gere uma estrutura que inclua:             1. Componentes (nome, tipo, propósito, dependências)      2. Módulos (nome, componentes, propósito)      3. Estrutura de arquivos (diretórios, propósito, arquivos)      4. Schema de dados (se aplicável)             Retorne apenas o JSON:      {        "components": [          {            "name": "nome do componente",            "type": "tipo (UI, serviço, etc.)",            "purpose": "propósito",            "dependencies": ["dependência1", "dependência2"]          }        ],        "modules": [          {            "name": "nome do módulo",            "components": ["componente1", "componente2"],            "purpose": "propósito"          }        ],        "fileStructure": {          "directories": [            {              "name": "nome do diretório",              "purpose": "propósito",              "children": ["arquivo1", {"name": "subdiretório", "type": "directory"}]            }          ]        },        "dataSchema": {          // Schema de dados, se aplicável        }      }      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.2,        maxTokens: 2000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para estrutura');    } catch (error) {      console.error('Erro ao gerar estrutura:', error);             // Retornar estrutura vazia em caso de erro      return {        components: [],        modules: [],        fileStructure: {          directories: []        }      };    }  }   /**   * Gera uma estrutura de diretórios e arquivos   */  async generateFileStructure(    components: Array<{      name: string;      type: string;      purpose: string;      dependencies: string[];    }>,    modules: Array<{      name: string;      components: string[];      purpose: string;    }>  ): Promise<{    directories: Array<{      name: string;      purpose: string;      children: Array<string | { name: string, type: string }>;    }>;  }> {    try {      const componentsJSON = JSON.stringify(components, null, 2);      const modulesJSON = JSON.stringify(modules, null, 2);       const prompt = `      Você é um especialista em estruturação de projetos de software.             Com base nos seguintes componentes e módulos, crie uma estrutura de diretórios      e arquivos que siga as melhores práticas para projetos React com TypeScript.             Componentes:      ${componentsJSON}             Módulos:      ${modulesJSON}             Gere uma estrutura de diretórios que:      1. Seja organizada e escalável      2. Siga o princípio de separação de responsabilidades      3. Agrupe arquivos relacionados      4. Utilize padrões comuns para projetos React/TypeScript             Retorne apenas o JSON:      {        "directories": [          {            "name": "nome do diretório",            "purpose": "propósito",            "children": [              "arquivo.tsx",              {"name": "subdiretório", "type": "directory", "children": ["arquivo.ts"]}            ]          }        ]      }      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1500      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para estrutura de arquivos');    } catch (error) {      console.error('Erro ao gerar estrutura de arquivos:', error);             // Retornar estrutura vazia em caso de erro      return {        directories: []      };    }  }   /**   * Gera um schema de dados a partir de requisitos   */  async generateDataSchema(    requirements: Array<{      id: string;      description: string;      type: string;      priority: string;    }>  ): Promise<Record<string, any>> {    try {      const requirementsJSON = JSON.stringify(requirements, null, 2);       const prompt = `      Você é um especialista em modelagem de dados.             Com base nos seguintes requisitos, crie um schema de dados para o sistema.             Requisitos:      ${requirementsJSON}             Gere um schema de dados que:      1. Capture todas as entidades necessárias      2. Inclua relacionamentos entre entidades      3. Especifique tipos de dados e restrições      4. Siga princípios de design de banco de dados             Retorne apenas o JSON com o schema de dados.      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.2,        maxTokens: 1500      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para schema de dados');    } catch (error) {      console.error('Erro ao gerar schema de dados:', error);             // Retornar objeto vazio em caso de erro      return {};    }  } }``

### src/services/knowledge/generators/MetadataGenerator.ts

``import { LLMService } from '@/services/llm/LLMService'; import { Document, ExtractedKnowledge } from '@/types/knowledge'; import { metadataUtils } from './utils/metadataUtils'; export class MetadataGenerator {   private llmService: LLMService;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }   /**   * Gera metadados a partir de um documento e conhecimento extraído   */  async generate(    document: Document,    extractedKnowledge: ExtractedKnowledge  ): Promise<{    tags: string[];    category: string;    complexity: number;    estimatedImplementationTime: string;    targetAudience: string[];    prerequisites: string[];    relatedTopics: string[];    lastUpdated: string;    version: string;    status: string;    author: string;  }> {    try {      // Extrair tags do conhecimento      const tags = await this.extractTags(document.content, extractedKnowledge);             // Determinar categoria      const category = await this.determineCategory(document.content, extractedKnowledge);             // Estimar complexidade      const complexity = this.estimateComplexity(extractedKnowledge);             // Estimar tempo de implementação      const estimatedImplementationTime = this.estimateImplementationTime(complexity, extractedKnowledge);             // Identificar público-alvo      const targetAudience = await this.identifyTargetAudience(document.content, extractedKnowledge);             // Identificar pré-requisitos      const prerequisites = this.identifyPrerequisites(extractedKnowledge);             // Identificar tópicos relacionados      const relatedTopics = await this.identifyRelatedTopics(extractedKnowledge);       return {        tags,        category,        complexity,        estimatedImplementationTime,        targetAudience,        prerequisites,        relatedTopics,        lastUpdated: new Date().toISOString(),        version: '1.0',        status: 'draft',        author: document.author || 'Unknown'      };    } catch (error) {      console.error('Erro ao gerar metadados:', error);             // Retornar metadados básicos em caso de erro      return {        tags: [],        category: 'Uncategorized',        complexity: 0.5,        estimatedImplementationTime: 'Unknown',        targetAudience: [],        prerequisites: [],        relatedTopics: [],        lastUpdated: new Date().toISOString(),        version: '1.0',        status: 'draft',        author: document.author || 'Unknown'      };    }  }   /**   * Extrai tags de um documento   */  private async extractTags(    content: string,    extractedKnowledge: ExtractedKnowledge  ): Promise<string[]> {    // Extrair tags dos conceitos    const conceptTags = (extractedKnowledge.concepts || [])      .map(concept => concept.name.toLowerCase())      .filter(tag => tag.length > 0);         // Limitar a 10 tags no máximo    return Array.from(new Set(conceptTags)).slice(0, 10);  }   /**   * Determina a categoria do documento   */  private async determineCategory(    content: string,    extractedKnowledge: ExtractedKnowledge  ): Promise<string> {    try {      const prompt = `      Determine a categoria principal do seguinte texto.      Escolha entre: Documentação Técnica, Tutorial, Guia de Referência, Especificação,      Conceitual, Arquitetura, Implementação, Teste, Operação, ou outro que seja apropriado.             Forneça apenas o nome da categoria, sem explicação.             Texto:      ${content.substring(0, 2000)}... (texto truncado)      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.1,        maxTokens: 50      });       return response.trim();    } catch (error) {      console.error('Erro ao determinar categoria:', error);      return 'Uncategorized';    }  }   /**   * Estima a complexidade do documento   */  private estimateComplexity(    extractedKnowledge: ExtractedKnowledge  ): number {    // Fatores que contribuem para complexidade    const numberOfConcepts = (extractedKnowledge.concepts || []).length;    const numberOfRelationships = (extractedKnowledge.relationships || []).length;    const numberOfDependencies = (extractedKnowledge.dependencies || []).length;    const numberOfRequirements = (extractedKnowledge.requirements || []).length;         // Calcular pontuação de complexidade (0-1)    let complexityScore = metadataUtils.calculateComplexity(      numberOfConcepts,      numberOfRelationships,      numberOfDependencies,      numberOfRequirements    );         // Ajustar com base na importância dos conceitos    const highImportanceConcepts = (extractedKnowledge.concepts || [])      .filter(concept => concept.importance >= 0.7)      .length;         if (highImportanceConcepts > 5) {      complexityScore = Math.min(1, complexityScore * 1.2);    }         return Number(complexityScore.toFixed(2));  }   /**   * Estima o tempo de implementação   */  private estimateImplementationTime(    complexity: number,    extractedKnowledge: ExtractedKnowledge  ): string {    const numberOfRequirements = (extractedKnowledge.requirements || []).length;    const numberOfDependencies = (extractedKnowledge.dependencies || []).length;         // Cálculo base: complexidade * fatores    let baseHours = complexity * 40; // 40h como base para complexidade 1.0         // Ajustar com base em requisitos e dependências    baseHours += numberOfRequirements * 2;    baseHours += numberOfDependencies * 3;         // Converter em formato legível    if (baseHours < 8) {      return `${Math.ceil(baseHours)} horas`;    } else if (baseHours < 40) {      return `${Math.ceil(baseHours / 8)} dias`;    } else {      return `${Math.ceil(baseHours / 40)} semanas`;    }  }   /**   * Identifica o público-alvo do documento   */  private async identifyTargetAudience(    content: string,    extractedKnowledge: ExtractedKnowledge  ): Promise<string[]> {    try {      const prompt = `      Identifique o público-alvo para o seguinte texto.      Exemplos: Desenvolvedores Frontend, Arquitetos de Software, DevOps, QA, etc.             Retorne apenas uma lista separada por vírgulas, sem explicação.             Texto:      ${content.substring(0, 2000)}... (texto truncado)      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.1,        maxTokens: 100      });       return response.split(',').map(audience => audience.trim());    } catch (error) {      console.error('Erro ao identificar público-alvo:', error);      return ['Desenvolvedores'];    }  }   /**   * Identifica pré-requisitos do conhecimento extraído   */  private identifyPrerequisites(    extractedKnowledge: ExtractedKnowledge  ): string[] {    // Extrair de dependências    const dependencyPrerequisites = (extractedKnowledge.dependencies || [])      .filter(dep => dep.priority === 'high')      .map(dep => dep.name);         // Extrair de conceitos importantes    const conceptPrerequisites = (extractedKnowledge.concepts || [])      .filter(concept => concept.importance >= 0.8)      .map(concept => concept.name);         // Combinar e remover duplicatas    return Array.from(new Set([...dependencyPrerequisites, ...conceptPrerequisites]));  }   /**   * Identifica tópicos relacionados   */  private async identifyRelatedTopics(    extractedKnowledge: ExtractedKnowledge  ): Promise<string[]> {    try {      const conceptsJSON = JSON.stringify(extractedKnowledge.concepts || [], null, 2);             const prompt = `      Com base nos seguintes conceitos, identifique tópicos relacionados      que não estão diretamente mencionados, mas seriam relevantes para      quem está interessado neste assunto.             Conceitos:      ${conceptsJSON}             Retorne apenas uma lista de 5-7 tópicos relacionados, separados por vírgulas.      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.6,        maxTokens: 100      });       return response.split(',').map(topic => topic.trim());    } catch (error) {      console.error('Erro ao identificar tópicos relacionados:', error);      return [];    }  } }``

### src/services/knowledge/generators/analyzers/ComplexityAnalyzer.ts

``/**  * Analisador de complexidade para textos e documentos */ export class ComplexityAnalyzer {   /**   * Analisa a complexidade de um texto   */  async analyze(text: string): Promise<{    score: number;    readability: string;    metrics: {      sentenceLength: number;      wordLength: number;      lexicalDensity: number;      longWordPercentage: number;    };  }> {    try {      // Métricas básicas      const metrics = this.calculateMetrics(text);             // Calcular pontuação de complexidade      const score = this.calculateComplexityScore(metrics);             // Determinar nível de legibilidade      const readability = this.determineReadabilityLevel(score);             return {        score,        readability,        metrics      };    } catch (error) {      console.error('Erro ao analisar complexidade:', error);      return {        score: 0.5,        readability: 'Média',        metrics: {          sentenceLength: 0,          wordLength: 0,          lexicalDensity: 0,          longWordPercentage: 0        }      };    }  }   /**   * Calcula métricas básicas de texto   */  private calculateMetrics(text: string): {    sentenceLength: number;    wordLength: number;    lexicalDensity: number;    longWordPercentage: number;  } {    // Limpar texto    const cleanText = text.replace(/\s+/g, ' ').trim();         // Dividir em sentenças (simplificado)    const sentences = cleanText.split(/[.!?]+/).filter(s => s.trim().length > 0);         // Dividir em palavras    const words = cleanText.split(/\s+/).filter(w => w.length > 0);         // Contar palavras únicas    const uniqueWords = new Set(words.map(w => w.toLowerCase()));         // Contar palavras longas (>6 caracteres)    const longWords = words.filter(w => w.length > 6);         // Calcular métricas    const sentenceLength = sentences.length > 0      ? words.length / sentences.length      : 0;         const wordLength = words.length > 0      ? words.join('').length / words.length      : 0;         const lexicalDensity = words.length > 0      ? uniqueWords.size / words.length      : 0;         const longWordPercentage = words.length > 0      ? longWords.length / words.length      : 0;         return {      sentenceLength,      wordLength,      lexicalDensity,      longWordPercentage    };  }   /**   * Calcula pontuação de complexidade   */  private calculateComplexityScore(metrics: {    sentenceLength: number;    wordLength: number;    lexicalDensity: number;    longWordPercentage: number;  }): number {    // Pesos para cada métrica    const weights = {      sentenceLength: 0.25,      wordLength: 0.25,      lexicalDensity: 0.3,      longWordPercentage: 0.2    };         // Normalizar sentenceLength (20 palavras/sentença = 1.0)    const normalizedSentenceLength = Math.min(1, metrics.sentenceLength / 20);         // Normalizar wordLength (8 caracteres/palavra = 1.0)    const normalizedWordLength = Math.min(1, metrics.wordLength / 8);         // Lexical density já está normalizada (0-1)         // Long word percentage já está normalizada (0-1)         // Calcular score ponderado    const score =      normalizedSentenceLength * weights.sentenceLength +      normalizedWordLength * weights.wordLength +      metrics.lexicalDensity * weights.lexicalDensity +      metrics.longWordPercentage * weights.longWordPercentage;         // Limitar entre 0 e 1    return Math.min(1, Math.max(0, score));  }   /**   * Determina nível de legibilidade   */  private determineReadabilityLevel(score: number): string {    if (score < 0.3) {      return 'Simples';    } else if (score < 0.6) {      return 'Média';    } else if (score < 0.8) {      return 'Complexa';    } else {      return 'Muito Complexa';    }  }     /**   * Analisa a complexidade técnica de um documento   */  public analyzeTechnicalComplexity(    text: string,    technicalTerms: string[] = []  ): {    technicalScore: number;    technicalLevel: string;    technicalTermFrequency: Record<string, number>;  } {    // Limpar texto    const cleanText = text.toLowerCase();         // Dividir em palavras    const words = cleanText.split(/\s+/).filter(w => w.length > 0);         // Contar ocorrências de termos técnicos    const technicalTermFrequency: Record<string, number> = {};         // Usar termos fornecidos ou termos padrão    const terms = technicalTerms.length > 0      ? technicalTerms      : [          'algoritmo', 'api', 'arquitetura', 'framework', 'interface',          'módulo', 'componente', 'serviço', 'função', 'classe',          'objeto', 'método', 'parâmetro', 'biblioteca', 'dependência'        ];         // Contar ocorrências    terms.forEach(term => {      const regex = new RegExp(`\\b${term.toLowerCase()}\\b`, 'g');      const matches = cleanText.match(regex);      technicalTermFrequency[term] = matches ? matches.length : 0;    });         // Calcular pontuação técnica    const totalTerms = Object.values(technicalTermFrequency).reduce((a, b) => a + b, 0);    const technicalScore = Math.min(1, totalTerms / (words.length * 0.05));         // Determinar nível técnico    let technicalLevel: string;    if (technicalScore < 0.3) {      technicalLevel = 'Básico';    } else if (technicalScore < 0.6) {      technicalLevel = 'Intermediário';    } else if (technicalScore < 0.8) {      technicalLevel = 'Avançado';    } else {      technicalLevel = 'Especialista';    }         return {      technicalScore,      technicalLevel,      technicalTermFrequency    };  } }``

### src/services/knowledge/generators/extractors/SummaryExtractor.ts

``import { LLMService } from '@/services/llm/LLMService'; export class SummaryExtractor {   private llmService: LLMService;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }   /**   * Extrai um resumo de um texto   */  async extract(content: string): Promise<{    brief: string;    detailed: string;    keyPoints: string[];  }> {    try {      const prompt = `      Analise o seguinte texto e crie três versões de resumo:             1. Um resumo breve (2-3 sentenças)      2. Um resumo detalhado (1-2 parágrafos)      3. Uma lista de pontos-chave (3-7 itens)             Retorne no formato JSON:      {        "brief": "Resumo breve aqui...",        "detailed": "Resumo detalhado aqui...",        "keyPoints": ["Ponto 1", "Ponto 2", ...]      }             Texto para análise:      ${content.substring(0, 4000)}... (texto truncado)      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para resumo');    } catch (error) {      console.error('Erro ao extrair resumo:', error);      return {        brief: 'Resumo não disponível',        detailed: 'Resumo detalhado não disponível',        keyPoints: ['Pontos-chave não disponíveis']      };    }  }   /**   * Extrai um resumo executivo de um texto   */  async extractExecutiveSummary(content: string): Promise<string> {    try {      const prompt = `      Crie um resumo executivo do seguinte texto. O resumo deve:             1. Ter no máximo 250 palavras      2. Ser direto e conciso      3. Focar nos pontos mais importantes      4. Ser adequado para uma audiência executiva             Texto para resumir:      ${content.substring(0, 4000)}... (texto truncado)             Forneça apenas o resumo executivo, sem introdução ou texto adicional.      `;       return await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.3,        maxTokens: 500      });    } catch (error) {      console.error('Erro ao extrair resumo executivo:', error);      return 'Resumo executivo não disponível';    }  }   /**   * Extrai um resumo focado em aspectos técnicos   */  async extractTechnicalSummary(content: string): Promise<string> {    try {      const prompt = `      Crie um resumo técnico do seguinte texto. O resumo deve:             1. Focar em aspectos técnicos e implementação      2. Destacar tecnologias, arquitetura e design      3. Incluir considerações técnicas importantes      4. Ser adequado para desenvolvedores e engenheiros             Texto para resumir:      ${content.substring(0, 4000)}... (texto truncado)             Forneça apenas o resumo técnico, sem introdução ou texto adicional.      `;       return await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.3,        maxTokens: 800      });    } catch (error) {      console.error('Erro ao extrair resumo técnico:', error);      return 'Resumo técnico não disponível';    }  }   /**   * Extrai um resumo para audiência não técnica   */  async extractNonTechnicalSummary(content: string): Promise<string> {    try {      const prompt = `      Crie um resumo não técnico do seguinte texto. O resumo deve:             1. Explicar o conteúdo em linguagem acessível      2. Evitar jargões técnicos ou explicá-los quando necessário      3. Focar em benefícios e aplicações práticas      4. Ser adequado para stakeholders não técnicos             Texto para resumir:      ${content.substring(0, 4000)}... (texto truncado)             Forneça apenas o resumo não técnico, sem introdução ou texto adicional.      `;       return await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.4,        maxTokens: 700      });    } catch (error) {      console.error('Erro ao extrair resumo não técnico:', error);      return 'Resumo não técnico não disponível';    }  } }``

### src/services/knowledge/generators/utils/metadataUtils.ts

``/**  * Utilidades para geração e manipulação de metadados */ export const metadataUtils = {   /**   * Calcula a complexidade com base em fatores   */  calculateComplexity(    numberOfConcepts: number,    numberOfRelationships: number,    numberOfDependencies: number,    numberOfRequirements: number  ): number {    // Pesos para cada fator    const weights = {      concepts: 0.3,      relationships: 0.3,      dependencies: 0.2,      requirements: 0.2    };         // Normalizar fatores (escala 0-1)    const normalizedConcepts = Math.min(1, numberOfConcepts / 20);    const normalizedRelationships = Math.min(1, numberOfRelationships / 30);    const normalizedDependencies = Math.min(1, numberOfDependencies / 10);    const normalizedRequirements = Math.min(1, numberOfRequirements / 15);         // Calcular score ponderado    const score =      normalizedConcepts * weights.concepts +      normalizedRelationships * weights.relationships +      normalizedDependencies * weights.dependencies +      normalizedRequirements * weights.requirements;         // Limitar entre 0 e 1    return Math.min(1, Math.max(0, score));  },   /**   * Estima o tempo de implementação   */  estimateImplementationTime(    complexity: number,    numberOfRequirements: number,    numberOfDependencies: number  ): string {    // Cálculo base: complexidade * fatores    let baseHours = complexity * 40; // 40h como base para complexidade 1.0         // Ajustar com base em requisitos e dependências    baseHours += numberOfRequirements * 2;    baseHours += numberOfDependencies * 3;         // Converter em formato legível    if (baseHours < 8) {      return `${Math.ceil(baseHours)} horas`;    } else if (baseHours < 40) {      return `${Math.ceil(baseHours / 8)} dias`;    } else {      return `${Math.ceil(baseHours / 40)} semanas`;    }  },   /**   * Gera tags a partir de conceitos   */  generateTags(    concepts: Array<{      name: string;      importance: number;      category?: string;    }>,    maxTags: number = 10  ): string[] {    // Ordenar por importância    const sortedConcepts = [...concepts].sort((a, b) => b.importance - a.importance);         // Extrair tags    const tags = sortedConcepts      .map(concept => concept.name.toLowerCase())      .filter(tag => tag.length > 0);         // Limitar quantidade e remover duplicatas    return Array.from(new Set(tags)).slice(0, maxTags);  },   /**   * Determina a categoria principal   */  determineMainCategory(    concepts: Array<{      name: string;      category?: string;      importance: number;    }>  ): string {    // Contar ocorrências de categorias    const categoryCounts: Record<string, number> = {};         concepts.forEach(concept => {      if (concept.category) {        categoryCounts[concept.category] = (categoryCounts[concept.category] || 0) + 1;      }    });         // Encontrar categoria mais comum    let mainCategory = 'Uncategorized';    let maxCount = 0;         for (const [category, count] of Object.entries(categoryCounts)) {      if (count > maxCount) {        maxCount = count;        mainCategory = category;      }    }         return mainCategory;  },   /**   * Calcula a versão com base no histórico   */  calculateVersion(    currentVersion: string,    changes: 'major' | 'minor' | 'patch'  ): string {    const [major, minor, patch] = currentVersion.split('.').map(Number);         switch (changes) {      case 'major':        return `${major + 1}.0.0`;      case 'minor':        return `${major}.${minor + 1}.0`;      case 'patch':        return `${major}.${minor}.${patch + 1}`;      default:        return currentVersion;    }  } };``

### src/services/knowledge/generators/interfaces/TokenInterfaces.ts

`/**  * Interface para informações de tokens */ export interface TokenInfo {   /**   * Número total de tokens   */  totalTokens: number;     /**   * Número de tokens de prompt   */  promptTokens: number;     /**   * Número de tokens de completamento   */  completionTokens: number;     /**   * Custo estimado em USD   */  estimatedCost: number; } /**  * Interface para metadados de uso de tokens */ export interface TokenUsageMetadata {   /**   * Informações de tokens por requisição   */  requests: Array<{    /**     * Identificador da requisição     */    id: string;         /**     * Informações de tokens     */    tokenInfo: TokenInfo;         /**     * Modelo usado     */    model: string;         /**     * Timestamp da requisição     */    timestamp: string;  }>;     /**   * Informações de tokens agregadas   */  aggregated: {    /**     * Número total de tokens     */    totalTokens: number;         /**     * Número total de tokens de prompt     */    totalPromptTokens: number;         /**     * Número total de tokens de completamento     */    totalCompletionTokens: number;         /**     * Custo total estimado em USD     */    totalEstimatedCost: number;  }; } /**  * Interface para rastreador de uso de tokens */ export interface TokenTracker {   /**   * Registra uso de tokens   */  trackTokenUsage(    requestId: string,    model: string,    tokenInfo: TokenInfo  ): void;     /**   * Obtém metadados de uso de tokens   */  getTokenUsageMetadata(): TokenUsageMetadata;     /**   * Limpa dados de rastreamento   */  clearTracking(): void;     /**   * Estima tokens para um texto   */  estimateTokens(text: string): number;     /**   * Estima custo para um modelo e contagem de tokens   */  estimateCost(    model: string,    promptTokens: number,    completionTokens: number  ): number; }`

### src/services/knowledge/validators/OutputValidator.ts

``import { LLMService } from '@/services/llm/LLMService'; import { Document, ExtractedKnowledge } from '@/types/knowledge'; export class OutputValidator {   private llmService: LLMService;   constructor() {    this.llmService = new LLMService({      defaultProvider: 'openai',      providers: {},      settings: {        maxConcurrentRequests: 3,        retryAttempts: 2,        timeout: 30000      }    });  }   /**   * Valida o resultado do processamento   */  async validate(data: {    document: Document;    extractedKnowledge: ExtractedKnowledge;    structure: any;    metadata: any;  }): Promise<{    isValid: boolean;    score: number;    issues: Array<{      severity: 'error' | 'warning' | 'info';      message: string;      location: string;    }>;    suggestions: string[];  }> {    try {      // Validar conhecimento extraído      const knowledgeValidation = await this.validateExtractedKnowledge(        data.document.content,        data.extractedKnowledge      );             // Validar estrutura      const structureValidation = await this.validateStructure(        data.extractedKnowledge,        data.structure      );             // Validar metadados      const metadataValidation = await this.validateMetadata(        data.extractedKnowledge,        data.metadata      );             // Combinar resultados      const allIssues = [        ...knowledgeValidation.issues,        ...structureValidation.issues,        ...metadataValidation.issues      ];             // Calcular pontuação geral      const overallScore = (        knowledgeValidation.score +        structureValidation.score +        metadataValidation.score      ) / 3;             // Determinar validade      const isValid = overallScore >= 0.7 &&        !allIssues.some(issue => issue.severity === 'error');             // Gerar sugestões      const suggestions = await this.generateSuggestions(        data.document,        data.extractedKnowledge,        allIssues      );             return {        isValid,        score: Number(overallScore.toFixed(2)),        issues: allIssues,        suggestions      };    } catch (error) {      console.error('Erro na validação:', error);      return {        isValid: false,        score: 0,        issues: [{          severity: 'error',          message: 'Erro durante validação: ' + (error as Error).message,          location: 'validator'        }],        suggestions: ['Tentar novamente o processamento']      };    }  }   /**   * Valida conhecimento extraído   */  private async validateExtractedKnowledge(    originalContent: string,    extractedKnowledge: ExtractedKnowledge  ): Promise<{    score: number;    issues: Array<{      severity: 'error' | 'warning' | 'info';      message: string;      location: string;    }>;  }> {    try {      const knowledgeJSON = JSON.stringify({        summary: extractedKnowledge.summary,        concepts: extractedKnowledge.concepts,        relationships: extractedKnowledge.relationships,        dependencies: extractedKnowledge.dependencies,        requirements: extractedKnowledge.requirements      }, null, 2);             const prompt = `      Você é um validador de conhecimento extraído. Avalie o conhecimento extraído      do texto original e identifique quaisquer problemas, como:             1. Conceitos importantes ausentes      2. Relacionamentos incorretos      3. Dependências omitidas      4. Requisitos mal interpretados      5. Resumo impreciso ou incompleto             Conhecimento extraído:      ${knowledgeJSON}             Trecho do texto original (primeiros 2000 caracteres):      ${originalContent.substring(0, 2000)}... (texto truncado)             Retorne apenas o JSON:      {        "score": X.X, // 0.0 a 1.0        "issues": [          {            "severity": "error|warning|info",            "message": "Descrição do problema",            "location": "Onde o problema foi encontrado (summary, concepts, etc.)"          }        ]      }      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.1,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para validação');    } catch (error) {      console.error('Erro ao validar conhecimento extraído:', error);      return {        score: 0.5,        issues: [{          severity: 'warning',          message: 'Não foi possível validar completamente o conhecimento extraído',          location: 'validator'        }]      };    }  }   /**   * Valida estrutura gerada   */  private async validateStructure(    extractedKnowledge: ExtractedKnowledge,    structure: any  ): Promise<{    score: number;    issues: Array<{      severity: 'error' | 'warning' | 'info';      message: string;      location: string;    }>;  }> {    try {      const knowledgeJSON = JSON.stringify({        concepts: extractedKnowledge.concepts,        relationships: extractedKnowledge.relationships,        dependencies: extractedKnowledge.dependencies,        requirements: extractedKnowledge.requirements      }, null, 2);             const structureJSON = JSON.stringify(structure, null, 2);             const prompt = `      Você é um validador de estrutura de aplicação. Avalie a estrutura gerada      com base no conhecimento extraído e identifique quaisquer problemas, como:             1. Componentes ausentes      2. Módulos incompletos      3. Estrutura de arquivos inadequada      4. Inconsistências entre componentes e módulos      5. Incompatibilidade com os requisitos             Conhecimento extraído:      ${knowledgeJSON}             Estrutura gerada:      ${structureJSON}             Retorne apenas o JSON:      {        "score": X.X, // 0.0 a 1.0        "issues": [          {            "severity": "error|warning|info",            "message": "Descrição do problema",            "location": "Onde o problema foi encontrado (components, modules, fileStructure)"          }        ]      }      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-4-turbo',        temperature: 0.1,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para validação de estrutura');    } catch (error) {      console.error('Erro ao validar estrutura:', error);      return {        score: 0.5,        issues: [{          severity: 'warning',          message: 'Não foi possível validar completamente a estrutura',          location: 'validator'        }]      };    }  }   /**   * Valida metadados gerados   */  private async validateMetadata(    extractedKnowledge: ExtractedKnowledge,    metadata: any  ): Promise<{    score: number;    issues: Array<{      severity: 'error' | 'warning' | 'info';      message: string;      location: string;    }>;  }> {    try {      const knowledgeJSON = JSON.stringify({        concepts: extractedKnowledge.concepts,        relationships: extractedKnowledge.relationships      }, null, 2);             const metadataJSON = JSON.stringify(metadata, null, 2);             const prompt = `      Você é um validador de metadados. Avalie os metadados gerados      com base no conhecimento extraído e identifique quaisquer problemas, como:             1. Tags irrelevantes      2. Categorização incorreta      3. Estimativa de complexidade implausível      4. Público-alvo inadequado      5. Pré-requisitos ausentes ou incorretos             Conhecimento extraído:      ${knowledgeJSON}             Metadados gerados:      ${metadataJSON}             Retorne apenas o JSON:      {        "score": X.X, // 0.0 a 1.0        "issues": [          {            "severity": "error|warning|info",            "message": "Descrição do problema",            "location": "Onde o problema foi encontrado (tags, category, etc.)"          }        ]      }      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.1,        maxTokens: 800      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para validação de metadados');    } catch (error) {      console.error('Erro ao validar metadados:', error);      return {        score: 0.7, // Metadados são menos críticos        issues: [{          severity: 'info',          message: 'Não foi possível validar completamente os metadados',          location: 'validator'        }]      };    }  }   /**   * Gera sugestões de melhoria   */  private async generateSuggestions(    document: Document,    extractedKnowledge: ExtractedKnowledge,    issues: Array<{      severity: 'error' | 'warning' | 'info';      message: string;      location: string;    }>  ): Promise<string[]> {    try {      // Se não houver problemas significativos, retornar lista vazia      if (issues.length === 0 ||          !issues.some(issue => issue.severity === 'error' || issue.severity === 'warning')) {        return [];      }             const issuesJSON = JSON.stringify(issues, null, 2);             const prompt = `      Com base nos problemas identificados, forneça 3-5 sugestões específicas      para melhorar o processamento do documento e obter um resultado mais preciso.             Problemas identificados:      ${issuesJSON}             Retorne apenas uma lista de sugestões, uma por linha, sem numeração ou marcadores.      `;       const response = await this.llmService.generateCompletion(prompt, {        model: 'openai:gpt-3.5-turbo',        temperature: 0.4,        maxTokens: 500      });       // Dividir por linha e filtrar linhas vazias      return response        .split('\n')        .map(line => line.trim())        .filter(line => line.length > 0);    } catch (error) {      console.error('Erro ao gerar sugestões:', error);      return ['Tente processar o documento novamente com configurações diferentes'];    }  } }``

### src/components/file-explorer/FileExplorer.tsx

``import React, { useState } from 'react'; import { Folder, File, ChevronRight, ChevronDown, Plus, MoreHorizontal, Trash, PenLine, Copy } from 'lucide-react'; import {   DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; import { Button } from '@/components/ui/button'; import { toast } from 'sonner'; import { ScrollArea } from '@/components/ui/scroll-area'; import { cn } from '@/lib/utils'; export interface FileNode {   id: string;  name: string;  type: 'file' | 'folder';  content?: string;  children?: FileNode[];  createdAt: string;  modifiedAt: string;  tags?: string[];  parent?: string; } interface FileExplorerProps {   files: FileNode[];  onFileSelect: (file: FileNode) => void;  onFileCreate: (type: 'file' | 'folder', parentId?: string) => void;  onFileDelete: (fileId: string) => void;  onFileRename: (fileId: string, newName: string) => void;  selectedFileId?: string; } export const FileExplorer: React.FC<FileExplorerProps> = ({   files,  onFileSelect,  onFileCreate,  onFileDelete,  onFileRename,  selectedFileId }) => {   const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());  const [renamingId, setRenamingId] = useState<string | null>(null);  const [newName, setNewName] = useState<string>('');   const toggleFolder = (folderId: string) => {    const newExpandedFolders = new Set(expandedFolders);    if (newExpandedFolders.has(folderId)) {      newExpandedFolders.delete(folderId);    } else {      newExpandedFolders.add(folderId);    }    setExpandedFolders(newExpandedFolders);  };   const startRenaming = (file: FileNode, e: React.MouseEvent) => {    e.stopPropagation();    setRenamingId(file.id);    setNewName(file.name);  };   const handleRename = (fileId: string) => {    if (newName.trim()) {      onFileRename(fileId, newName);      toast.success(`Arquivo renomeado para ${newName}`);    }    setRenamingId(null);  };   const handleDelete = (fileId: string, e: React.MouseEvent) => {    e.stopPropagation();    onFileDelete(fileId);    toast.success("Arquivo excluído com sucesso");  };   const renderFileTree = (nodes: FileNode[], level = 0) => {    return nodes.map((node) => {      const isExpanded = expandedFolders.has(node.id);      const isSelected = selectedFileId === node.id;             return (        <div key={node.id} className="select-none">          <div            className={cn(              "flex items-center py-1 px-2 hover:bg-muted/50 rounded cursor-pointer",              isSelected && "bg-muted",              level > 0 && `ml-${level * 4}`            )}            onClick={() => node.type === 'folder'              ? toggleFolder(node.id)              : onFileSelect(node)            }          >            {node.type === 'folder' && (              <Button variant="ghost" size="icon" className="h-4 w-4 p-0 mr-1">                {isExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}              </Button>            )}                         {node.type === 'folder'              ? <Folder className="h-4 w-4 mr-2 text-blue-500" />              : <File className="h-4 w-4 mr-2 text-gray-500" />            }                         {renamingId === node.id ? (              <input                type="text"                value={newName}                onChange={(e) => setNewName(e.target.value)}                onBlur={() => handleRename(node.id)}                onKeyDown={(e) => e.key === 'Enter' && handleRename(node.id)}                className="bg-background border rounded px-1 py-0 text-sm w-full focus:outline-none focus:ring-1 focus:ring-primary"                autoFocus                onClick={(e) => e.stopPropagation()}              />            ) : (              <span className="text-sm flex-grow truncate">{node.name}</span>            )}                         <DropdownMenu>              <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>                <Button variant="ghost" size="icon" className="h-6 w-6 p-0 opacity-0 group-hover:opacity-100 hover:opacity-100">                  <MoreHorizontal className="h-4 w-4" />                </Button>              </DropdownMenuTrigger>              <DropdownMenuContent align="end">                <DropdownMenuItem onClick={(e) => startRenaming(node, e)}>                  <PenLine className="h-4 w-4 mr-2" />                  Renomear                </DropdownMenuItem>                <DropdownMenuItem onClick={(e) => handleDelete(node.id, e)}>                  <Trash className="h-4 w-4 mr-2" />                  Excluir                </DropdownMenuItem>                {node.type === 'folder' && (                  <DropdownMenuItem onClick={(e) => {                    e.stopPropagation();                    onFileCreate('file', node.id);                  }}>                    <Plus className="h-4 w-4 mr-2" />                    Novo Arquivo                  </DropdownMenuItem>                )}              </DropdownMenuContent>            </DropdownMenu>          </div>                     {node.type === 'folder' && isExpanded && node.children && (            <div className="pl-4">              {renderFileTree(node.children, level + 1)}            </div>          )}        </div>      );    });  };   return (    <div className="h-full border-r">      <div className="p-4 border-b flex justify-between items-center">        <h2 className="text-lg font-semibold">Arquivos</h2>        <div className="flex space-x-1">          <Button            variant="outline"            size="sm"            onClick={() => onFileCreate('file')}            className="h-8 px-2"          >            <Plus className="h-4 w-4 mr-1" />            Arquivo          </Button>          <Button            variant="outline"            size="sm"            onClick={() => onFileCreate('folder')}            className="h-8 px-2"          >            <Folder className="h-4 w-4 mr-1" />            Pasta          </Button>        </div>      </div>      <ScrollArea className="h-[calc(100vh-10rem)]">        <div className="p-2">          {renderFileTree(files)}        </div>      </ScrollArea>    </div>  ); };``

### src/services/agent/AgentService.ts

``import { toast } from 'sonner'; import { Agent, AgentConfig, AgentStatus, AgentTaskResult, ChatMessage, ChatRole } from '../../types/agent'; import { LLMService } from '../llm/LLMService'; import { ProcessedDocument } from '../../types/knowledge'; import { generateAgentId } from '../../utils/agentUtils'; /**  * Service responsible for managing AI agents */ export class AgentService {   private agents: Map<string, Agent>;  private activeTasksById: Map<string, AbortController>;  private llmService: LLMService;  private listeners: ((agents: Agent[]) => void)[] = [];   constructor(llmConfig?: any) {    this.agents = new Map();    this.activeTasksById = new Map();    this.llmService = new LLMService(llmConfig || {      defaultProvider: 'openai',      providers: {}    });  }   /**   * Initialize with default agents   */  async initialize(): Promise<void> {    // Add default agents    this.registerAgent({      id: 'analyzer',      name: 'Analisador de Documentos',      description: 'Analisa e extrai estrutura e metadados de documentos Markdown',      status: 'inactive',      capabilities: ['Análise Estrutural', 'Extração de Metadados', 'Classificação'],      config: {        llmProvider: 'openai',        model: 'gpt-4',        temperature: 0.2,        maxTokens: 2048,        customInstructions: 'Extraia a estrutura e metadados do documento'      },      stats: {        documentsProcessed: 0,        averageProcessingTime: '0s',        successRate: '0%',        lastRun: 'Nunca',        agentId: 'analyzer',        agentName: 'Analisador de Documentos',        errorRate: '0%'      }    });     this.registerAgent({      id: 'improver',      name: 'Melhorador de Conteúdo',      description: 'Aprimora a qualidade do conteúdo existente e sugere melhorias',      status: 'inactive',      capabilities: ['Correção Gramatical', 'Melhoria de Clareza', 'Reformulação'],      config: {        llmProvider: 'openai',        model: 'gpt-3.5-turbo',        temperature: 0.7,        maxTokens: 1024,        customInstructions: 'Melhore a qualidade e clareza do texto'      },      stats: {        documentsProcessed: 0,        averageProcessingTime: '0s',        successRate: '0%',        lastRun: 'Nunca',        agentId: 'improver',        agentName: 'Melhorador de Conteúdo',        errorRate: '0%'      }    });     this.registerAgent({      id: 'generator',      name: 'Gerador de Prompts',      description: 'Cria prompts de desenvolvimento baseados na documentação',      status: 'inactive',      capabilities: ['Geração de Prompts', 'Estruturação de Tarefas', 'Sugestão de Dependências'],      config: {        llmProvider: 'anthropic',        model: 'claude-2',        temperature: 0.5,        maxTokens: 1536,        customInstructions: 'Gere prompts detalhados para desenvolvimento'      },      stats: {        documentsProcessed: 0,        averageProcessingTime: '0s',        successRate: '0%',        lastRun: 'Nunca',        agentId: 'generator',        agentName: 'Gerador de Prompts',        errorRate: '0%'      }    });     // Notify listeners    this.notifyListeners();  }   /**   * Register a new agent   */  registerAgent(agent: Agent): void {    this.agents.set(agent.id, agent);    this.notifyListeners();  }   /**   * Get all registered agents   */  getAgents(): Agent[] {    return Array.from(this.agents.values());  }   /**   * Get agent by ID   */  getAgent(id: string): Agent | undefined {    return this.agents.get(id);  }   /**   * Update agent configuration   */  updateAgentConfig(id: string, config: AgentConfig): boolean {    const agent = this.agents.get(id);    if (!agent) return false;     agent.config = config;    this.agents.set(id, agent);    this.notifyListeners();    return true;  }   /**   * Start an agent   */  async startAgent(id: string): Promise<boolean> {    const agent = this.agents.get(id);    if (!agent) return false;     agent.status = 'active';    this.agents.set(id, agent);    this.notifyListeners();         // Log agent start    console.log(`Agent started: ${agent.name} (${agent.id})`);    return true;  }   /**   * Stop an agent   */  async stopAgent(id: string): Promise<boolean> {    const agent = this.agents.get(id);    if (!agent) return false;     // Abort any active tasks    const abortController = this.activeTasksById.get(id);    if (abortController) {      abortController.abort();      this.activeTasksById.delete(id);    }     agent.status = 'inactive';    this.agents.set(id, agent);    this.notifyListeners();         // Log agent stop    console.log(`Agent stopped: ${agent.name} (${agent.id})`);    return true;  }   /**   * Remove an agent   */  removeAgent(id: string): boolean {    // Can't remove agent with active tasks    if (this.activeTasksById.has(id)) {      return false;    }     const result = this.agents.delete(id);    if (result) {      this.notifyListeners();    }    return result;  }   /**   * Create a new agent   */  createAgent(agentData: Omit<Agent, 'id'>): Agent {    const id = generateAgentId();    const agent: Agent = {      ...agentData,      id,      status: 'inactive',      stats: {        documentsProcessed: 0,        averageProcessingTime: '0s',        successRate: '0%',        lastRun: 'Nunca',        agentId: id,        agentName: agentData.name      }    };     this.registerAgent(agent);    return agent;  }   /**   * Execute a task with an agent   */  async executeTask(    agentId: string,    document: ProcessedDocument,    taskType: 'analyze' | 'improve' | 'generate'  ): Promise<AgentTaskResult> {    const agent = this.agents.get(agentId);    if (!agent) {      return {        success: false,        error: 'Agent not found',        processingTime: 0      };    }     if (agent.status !== 'active') {      return {        success: false,        error: 'Agent is not active',        processingTime: 0      };    }     const startTime = performance.now();    const abortController = new AbortController();    this.activeTasksById.set(agentId, abortController);     try {      // Update agent stats      this.updateAgentStats(agentId, document);       // Execute task based on type      let result: any;      switch (taskType) {        case 'analyze':          result = await this.analyzeDocument(agent, document, abortController.signal);          break;        case 'improve':          result = await this.improveDocument(agent, document, abortController.signal);          break;        case 'generate':          result = await this.generatePrompts(agent, document, abortController.signal);          break;        default:          throw new Error(`Unknown task type: ${taskType}`);      }       const processingTime = performance.now() - startTime;      this.activeTasksById.delete(agentId);       return {        success: true,        data: result,        processingTime,        tokensUsed: result.tokensUsed      };    } catch (error) {      const processingTime = performance.now() - startTime;      this.activeTasksById.delete(agentId);       // Only update error stats if it wasn't aborted      if (!(error instanceof DOMException && error.name === 'AbortError')) {        this.updateAgentErrorStats(agentId);      }       return {        success: false,        error: error instanceof Error ? error.message : 'Unknown error',        processingTime      };    }  }   /**   * Listen for agent changes   */  subscribe(callback: (agents: Agent[]) => void): () => void {    this.listeners.push(callback);         // Initial notification    callback(this.getAgents());         // Return unsubscribe function    return () => {      this.listeners = this.listeners.filter(l => l !== callback);    };  }   /**   * Notify all listeners of agent changes   */  private notifyListeners(): void {    const agents = this.getAgents();    for (const listener of this.listeners) {      listener(agents);    }  }   /**   * Update agent stats after processing a document   */  private updateAgentStats(agentId: string, document: ProcessedDocument): void {    const agent = this.agents.get(agentId);    if (!agent || !agent.stats) return;     // Update processed count    const documentsProcessed = (agent.stats.documentsProcessed || 0) + 1;         // Calculate success rate    const successCount = Math.floor(documentsProcessed * 0.95); // Simplified for demo    const successRate = `${Math.round((successCount / documentsProcessed) * 100)}%`;         // Update average processing time    const currentAvg = agent.stats.averageProcessingTime || '0s';    const currentAvgMs = parseInt(currentAvg.replace('s', '')) * 1000;    const newAvgMs = (currentAvgMs * (documentsProcessed - 1) + 3000) / documentsProcessed; // Example 3s processing    const averageProcessingTime = `${(newAvgMs / 1000).toFixed(1)}s`;     agent.stats = {      ...agent.stats,      documentsProcessed,      successRate,      averageProcessingTime,      lastRun: 'Agora'    };     this.agents.set(agentId, agent);    this.notifyListeners();  }   /**   * Update agent stats after an error   */  private updateAgentErrorStats(agentId: string): void {    const agent = this.agents.get(agentId);    if (!agent || !agent.stats) return;     // Update processed count    const documentsProcessed = (agent.stats.documentsProcessed || 0) + 1;         // Calculate success rate with one more failure    const successCount = Math.floor(documentsProcessed * 0.9) - 1; // One more failure    const successRate = `${Math.round((successCount / documentsProcessed) * 100)}%`;     agent.stats = {      ...agent.stats,      documentsProcessed,      successRate,      lastRun: 'Agora (com erro)'    };     this.agents.set(agentId, agent);    this.notifyListeners();  }   /**   * Analyze a document with an agent   */  private async analyzeDocument(    agent: Agent,    document: ProcessedDocument,    signal: AbortSignal  ): Promise<any> {    // Construct prompt based on agent configuration and document    const messages: ChatMessage[] = [      {        role: 'system',        content: `Você é um analisador de documentos especializado. ${agent.config.customInstructions || ''}`      },      {        role: 'user',        content: `Analise o seguinte documento e extraia metadados, estrutura e conceitos importantes:                 ${document.content}`      }    ];     // Use LLM service to process the document    const response = await this.llmService.generateChat(messages, {      model: agent.config.model,      temperature: agent.config.temperature,      maxTokens: agent.config.maxTokens    });     return {      analysis: response.message,      tokensUsed: response.usage?.totalTokens || 0    };  }   /**   * Improve a document with an agent   */  private async improveDocument(    agent: Agent,    document: ProcessedDocument,    signal: AbortSignal  ): Promise<any> {    // Construct prompt based on agent configuration and document    const messages: ChatMessage[] = [      {        role: 'system',        content: `Você é um assistente especializado em melhorar a qualidade de documentos. ${agent.config.customInstructions || ''}`      },      {        role: 'user',        content: `Melhore o seguinte documento, corrigindo erros, melhorando a clareza e reformulando quando necessário:                 ${document.content}`      }    ];     // Use LLM service to process the document    const response = await this.llmService.generateChat(messages, {      model: agent.config.model,      temperature: agent.config.temperature,      maxTokens: agent.config.maxTokens    });     return {      improvedContent: response.message,      tokensUsed: response.usage?.totalTokens || 0    };  }   /**   * Generate prompts from a document with an agent   */  private async generatePrompts(    agent: Agent,    document: ProcessedDocument,    signal: AbortSignal  ): Promise<any> {    // Construct prompt based on agent configuration and document    const messages: ChatMessage[] = [      {        role: 'system',        content: `Você é um especialista em gerar prompts de desenvolvimento a partir de documentos. ${agent.config.customInstructions || ''}`      },      {        role: 'user',        content: `Gere prompts de desenvolvimento a partir do seguinte documento:                 ${document.content}                 Para cada seção importante, crie um prompt estruturado com os seguintes elementos:        - Título        - Descrição        - Contexto        - Passos de implementação        - Dependências/Requisitos`      }    ];     // Use LLM service to process the document    const response = await this.llmService.generateChat(messages, {      model: agent.config.model,      temperature: agent.config.temperature,      maxTokens: agent.config.maxTokens    });     return {      prompts: response.message,      tokensUsed: response.usage?.totalTokens || 0    };  } }``

### src/services/connections/ConnectionService.ts

`import { Connection, ConnectionServiceOptions } from './types'; import { MonitoringService } from '../monitoring/MonitoringService'; import {    getConnections as fetchConnections,  getConnection as fetchConnection  } from './retrievalService'; import {   createConnection as createNewConnection,  updateConnection as updateExistingConnection,  deleteConnection as deleteExistingConnection,  testConnection as testExistingConnection } from './modificationService'; /**  * Serviço para gerenciar conexões com sistemas externos */ export class ConnectionService {   private monitoring: MonitoringService;   constructor(options?: ConnectionServiceOptions) {    this.monitoring = options?.monitoring || new MonitoringService();  }   /**   * Obtém todas as conexões do usuário   */  async getConnections(): Promise<Connection[]> {    return fetchConnections(this.monitoring);  }   /**   * Obtém uma conexão específica pelo ID   */  async getConnection(id: string): Promise<Connection | null> {    return fetchConnection(id, this.monitoring);  }   /**   * Cria uma nova conexão   */  async createConnection(connection: Connection): Promise<Connection> {    return createNewConnection(connection, this.monitoring);  }   /**   * Atualiza uma conexão existente   */  async updateConnection(id: string, connection: Partial<Connection>): Promise<Connection> {    return updateExistingConnection(id, connection, this.monitoring);  }   /**   * Exclui uma conexão   */  async deleteConnection(id: string): Promise<void> {    return deleteExistingConnection(id, this.monitoring);  }   /**   * Testa a conexão com um serviço   */  async testConnection(connection: Connection): Promise<boolean> {    return testExistingConnection(connection, this.monitoring);  } }`

### src/hooks/connections/useConnections.ts

`import { useConnectionState } from './useConnectionState'; import { useConnectionForm } from './useConnectionForm'; import { useConnectionQueries } from './useConnectionQueries'; import { useConnectionActions } from './useConnectionActions'; /**  * Hook principal para gerenciar conexões com sistemas externos */ export function useConnections() {   const {    selectedTab,    setSelectedTab,    isAddDialogOpen,    setIsAddDialogOpen,    isEditDialogOpen,    setIsEditDialogOpen,    isConfirmDeleteOpen,    setIsConfirmDeleteOpen,    selectedConnection,    isTesting,    formData,    setFormData  } = useConnectionState();   const {    handleChange,    handleCredentialChange,    handleServiceChange,    handleProviderChange,    handleActiveChange  } = useConnectionForm(formData, setFormData);   const {    connections,    isLoading,    error,    createMutation,    updateMutation,    deleteMutation  } = useConnectionQueries();   const {    handleSubmit,    handleDelete,    handleEdit,    handleDeleteClick,    handleAdd,    testConnection  } = useConnectionActions();   return {    // Estado    selectedTab,    isAddDialogOpen,    isEditDialogOpen,    isConfirmDeleteOpen,    selectedConnection,    isTesting,    formData,    connections,    isLoading,    error,         // Mutations    createMutation,    updateMutation,    deleteMutation,         // Ações    setSelectedTab,    setIsAddDialogOpen,    setIsEditDialogOpen,    setIsConfirmDeleteOpen,    testConnection,         // Handlers    handleChange,    handleCredentialChange,    handleServiceChange,    handleProviderChange,    handleActiveChange,    handleSubmit,    handleDelete,    handleEdit,    handleDeleteClick,    handleAdd  }; }`

### supabase/functions/process-media/services/audio-service.ts

``import { ProcessingOptions } from '../types/media.ts'; // Serviço para processar áudio export async function processAudio(   openAIKey: string,  mediaUrl: string,  options?: ProcessingOptions ) {   const detailLevel = options?.detailLevel || 'detailed';  const language = options?.language || 'pt-BR';     // Configurar prompt para simulação de análise de áudio  // Para uma implementação real, seria necessário usar um serviço de transcrição  const messages = [    {      role: 'system',      content: `Você é um assistente especializado em análise de áudio.               Como esta é uma demonstração, forneça uma análise simulada para um arquivo de áudio.               Inclua detalhes como prováveis falantes, qualidade do áudio, e conteúdo principal.               O nível de detalhe deve ser: ${detailLevel}.               Responda no idioma: ${language}.`    },    {      role: 'user',      content: `Simule uma análise de áudio para: ${mediaUrl}`    }  ];   // Chamar API da OpenAI  const response = await fetch('https://api.openai.com/v1/chat/completions', {    method: 'POST',    headers: {      'Content-Type': 'application/json',      'Authorization': `Bearer ${openAIKey}`    },    body: JSON.stringify({      model: 'gpt-4o-mini',      messages: messages,      max_tokens: 1000    })  });   const data = await response.json();     if (!response.ok) {    throw new Error(`Erro da API OpenAI: ${data.error?.message || 'Resposta inválida'}`);  }     // Retornar resultado formatado  return {    analysis: data.choices[0].message.content,    mediaType: 'audio',    processedAt: new Date().toISOString(),    modelUsed: 'gpt-4o-mini',    detailLevel  }; }``

### supabase/functions/process-media/services/video-service.ts

``import { ProcessingOptions } from '../types/media.ts'; // Serviço para processar vídeo export async function processVideo(   openAIKey: string,  mediaUrl: string,  options?: ProcessingOptions ) {   const detailLevel = options?.detailLevel || 'detailed';  const language = options?.language || 'pt-BR';     // Configurar prompt para simulação de análise de vídeo  // Para uma implementação real, seria necessário extrair frames e áudio  const messages = [    {      role: 'system',      content: `Você é um assistente especializado em análise de vídeo.               Como esta é uma demonstração, forneça uma análise simulada para um arquivo de vídeo.               Inclua detalhes como cenas principais, objetos, ações, e narrativa.               O nível de detalhe deve ser: ${detailLevel}.               Responda no idioma: ${language}.`    },    {      role: 'user',      content: `Simule uma análise de vídeo para: ${mediaUrl}`    }  ];   // Chamar API da OpenAI  const response = await fetch('https://api.openai.com/v1/chat/completions', {    method: 'POST',    headers: {      'Content-Type': 'application/json',      'Authorization': `Bearer ${openAIKey}`    },    body: JSON.stringify({      model: 'gpt-4o-mini',      messages: messages,      max_tokens: 1000    })  });   const data = await response.json();     if (!response.ok) {    throw new Error(`Erro da API OpenAI: ${data.error?.message || 'Resposta inválida'}`);  }     // Retornar resultado formatado  return {    analysis: data.choices[0].message.content,    mediaType: 'video',    processedAt: new Date().toISOString(),    modelUsed: 'gpt-4o-mini',    detailLevel  }; }``

### supabase/functions/process-media/services/image-service.ts

``import { ProcessingOptions } from '../types/media.ts'; // Serviço para processar imagens export async function processImage(   openAIKey: string,  mediaUrl: string,  options?: ProcessingOptions ) {   const detailLevel = options?.detailLevel || 'detailed';  const language = options?.language || 'pt-BR';     // Configurar prompt para análise de imagem  const messages = [    {      role: 'system',      content: `Você é um assistente especializado em análise de imagens.               Analise a imagem fornecida com um nível de detalhe ${detailLevel}.               ${options?.includeObjects ? 'Identifique todos os objetos na imagem.' : ''}               ${options?.includeTags ? 'Crie tags relevantes para a imagem.' : ''}               ${options?.includeDescription ? 'Forneça uma descrição detalhada da imagem.' : ''}               Responda no idioma: ${language}.`    },    {      role: 'user',      content: [        { type: 'text', text: 'Analise esta imagem em detalhes:' },        { type: 'image_url', image_url: { url: mediaUrl } }      ]    }  ];   // Chamar API da OpenAI  const response = await fetch('https://api.openai.com/v1/chat/completions', {    method: 'POST',    headers: {      'Content-Type': 'application/json',      'Authorization': `Bearer ${openAIKey}`    },    body: JSON.stringify({      model: 'gpt-4o-mini', // Modelo que suporta visão      messages: messages,      max_tokens: 1000    })  });   const data = await response.json();     if (!response.ok) {    throw new Error(`Erro da API OpenAI: ${data.error?.message || 'Resposta inválida'}`);  }     // Retornar resultado formatado  return {    analysis: data.choices[0].message.content,    mediaType: 'image',    processedAt: new Date().toISOString(),    modelUsed: 'gpt-4o-mini',    detailLevel  }; }``

### supabase/functions/process-media/index.ts

`import { serve } from "https://deno.land/std@0.168.0/http/server.ts"; import "https://deno.land/x/xhr@0.1.0/mod.ts"; // Importar tipos import {    ProcessMediaRequest,  ProcessMediaResponse  } from "./types/media.ts"; // Importar utilidades import { corsHeaders, handleCorsRequest } from "./utils/cors.ts"; // Importar serviço principal de mídia import { processMedia } from "./services/media-service.ts"; // Obter chave da API OpenAI const openAIKey = Deno.env.get('OPENAI_API_KEY'); // Função principal para processamento de requisições serve(async (req) => {   // Lidar com solicitações preflight CORS  const corsResponse = handleCorsRequest(req);  if (corsResponse) return corsResponse;   try {    // Verificar chave da API    if (!openAIKey) {      throw new Error('OPENAI_API_KEY não está configurada no ambiente');    }     // Extrair dados da requisição    const { mediaUrl, mediaType, processingOptions } = await req.json() as ProcessMediaRequest;     // Validar dados obrigatórios    if (!mediaUrl || !mediaType) {      return new Response(        JSON.stringify({          success: false,          error: 'mediaUrl e mediaType são obrigatórios'        } as ProcessMediaResponse),        {          status: 400,          headers: { ...corsHeaders, 'Content-Type': 'application/json' }        }      );    }     // Processar mídia usando o serviço centralizado    const result = await processMedia(openAIKey, mediaUrl, mediaType, processingOptions);     // Retornar resposta de sucesso    return new Response(      JSON.stringify({        success: true,        result      } as ProcessMediaResponse),      {        headers: { ...corsHeaders, 'Content-Type': 'application/json' }      }    );  } catch (error) {    // Registrar erro no console    console.error('Erro ao processar mídia:', error);         // Retornar resposta de erro    return new Response(      JSON.stringify({        success: false,        error: error.message || 'Erro desconhecido ao processar mídia'      } as ProcessMediaResponse),      {        status: 500,        headers: { ...corsHeaders, 'Content-Type': 'application/json' }      }    );  } });`

### supabase/functions/process-media/services/media-service.ts

``import { MediaType, ProcessingOptions, MediaProcessingResult } from '../types/media.ts'; import { processImage } from './image-service.ts'; import { processAudio } from './audio-service.ts'; import { processVideo } from './video-service.ts'; import { generateCategoryDistribution } from './category-service.ts'; import { generateInsights } from './insights-service.ts'; // Serviço centralizador para processamento de mídia export async function processMedia(   openAIKey: string,  mediaUrl: string,  mediaType: MediaType,  options?: ProcessingOptions ): Promise<MediaProcessingResult> {   // Chamar o serviço correto baseado no tipo de mídia  let response;     console.log(`Processando mídia do tipo: ${mediaType}, URL: ${mediaUrl}`);     // Registrar o início do processamento  const startTime = Date.now();     try {    // Direcionar para o serviço específico do tipo de mídia    switch (mediaType) {      case 'image':        response = await processImage(openAIKey, mediaUrl, options);        break;      case 'audio':        response = await processAudio(openAIKey, mediaUrl, options);        break;      case 'video':        response = await processVideo(openAIKey, mediaUrl, options);        break;      default:        throw new Error(`Tipo de mídia não suportado: ${mediaType}`);    }         // Calcular o tempo de processamento    const endTime = Date.now();    const processingTime = endTime - startTime;         // Adicionar estatísticas de processamento    if (!response.statistics) {      response.statistics = {        processingTime,        confidenceScore: 0.85, // Valor padrão, deve ser calculado pelo processador específico        complexityScore: 0.5,  // Valor padrão, deve ser calculado pelo processador específico        elementCount: 1,       // Valor padrão, deve ser calculado pelo processador específico        qualityScore: 0.75,    // Valor padrão, deve ser calculado pelo processador específico        performance: {          resourceUtilization: 0.5,          efficiencyScore: 0.8,          loadTime: processingTime / 1000 // Converter para segundos        }      };    } else {      response.statistics.processingTime = processingTime;    }         // Adicionar categorias e insights se solicitado    if (options?.includeCategoryDistribution) {      response.statistics.categoryDistribution = generateCategoryDistribution(mediaType, response.analysis);    }     if (options?.generateInsights) {      response.statistics.insights = generateInsights(mediaType, response);    }         return response;  } catch (error) {    console.error(`Erro ao processar mídia: ${error}`);    throw error;  } } // Função para processar múltiplas mídias em paralelo export async function processBatchMedia(   openAIKey: string,  mediaItems: {url: string, type: MediaType}[],  options?: ProcessingOptions ): Promise<MediaProcessingResult[]> {   try {    // Criar um array de promessas para processamento em paralelo    const processingPromises = mediaItems.map(item =>      processMedia(openAIKey, item.url, item.type, options)    );         // Aguardar o processamento de todas as mídias    return await Promise.all(processingPromises);  } catch (error) {    console.error(`Erro ao processar lote de mídia: ${error}`);    throw error;  } } // Função para integrar o processamento de mídia com o sistema de funil de triagem export async function processMediaWithTriageFunnel(   openAIKey: string,  mediaUrl: string,  mediaType: MediaType,  funnelId: string,  options?: ProcessingOptions ): Promise<any> {   try {    // 1. Processar a mídia inicialmente    const initialResult = await processMedia(openAIKey, mediaUrl, mediaType, options);         // 2. Recuperar a configuração do funil de triagem    // Nota: Aqui precisaríamos acessar o banco de dados para obter a configuração do funil    // Por enquanto, vamos simular isso com um valor padrão         // 3. Passar o resultado através de cada etapa do funil    // Isso será implementado quando tivermos acesso ao banco de dados e aos LLMs configurados         return {      status: 'success',      message: 'Processamento com funil de triagem simulado',      initialResult    };  } catch (error) {    console.error(`Erro ao processar mídia com funil de triagem: ${error}`);    throw error;  } }``


### src/services/messaging/MessageBus.ts

`import { EventEmitter } from 'events'; export type MessageHandler = (data: any) => void; export class MessageBus {   private static instance: MessageBus;  private eventEmitter: EventEmitter;   private constructor() {    this.eventEmitter = new EventEmitter();    // Aumentar limite de listeners para evitar warnings    this.eventEmitter.setMaxListeners(50);  }   /**   * Obtém instância única do MessageBus (Singleton)   */  public static getInstance(): MessageBus {    if (!MessageBus.instance) {      MessageBus.instance = new MessageBus();    }    return MessageBus.instance;  }   /**   * Publica uma mensagem em um tópico   */  publish(topic: string, data: any): void {    this.eventEmitter.emit(topic, data);  }   /**   * Assina um tópico para receber mensagens   */  subscribe(topic: string, handler: MessageHandler): () => void {    this.eventEmitter.on(topic, handler);         // Retorna função para cancelar inscrição    return () => {      this.eventEmitter.removeListener(topic, handler);    };  }   /**   * Assina um tópico para receber apenas a próxima mensagem   */  subscribeOnce(topic: string, handler: MessageHandler): void {    this.eventEmitter.once(topic, handler);  }   /**   * Remove todas as inscrições de um tópico   */  clearSubscriptions(topic: string): void {    this.eventEmitter.removeAllListeners(topic);  }   /**   * Remove todas as inscrições   */  clearAllSubscriptions(): void {    this.eventEmitter.removeAllListeners();  }   /**   * Lista todos os tópicos ativos   */  getActiveTopics(): string[] {    return this.eventEmitter.eventNames() as string[];  }   /**   * Obtém número de inscritos em um tópico   */  getSubscriberCount(topic: string): number {    return this.eventEmitter.listenerCount(topic);  } }`

### src/services/monitoring/MonitoringService.ts

`import { MessageBus } from '../messaging/MessageBus'; export interface MonitoringEvent {   type: string;  timestamp?: string;  data?: any; } export class MonitoringService {   private static instance: MonitoringService;  private messageBus: MessageBus;  private events: MonitoringEvent[] = [];  private maxEvents: number = 1000;   private constructor() {    this.messageBus = MessageBus.getInstance();  }   /**   * Obtém instância única do MonitoringService (Singleton)   */  public static getInstance(): MonitoringService {    if (!MonitoringService.instance) {      MonitoringService.instance = new MonitoringService();    }    return MonitoringService.instance;  }   /**   * Registra um evento   */  logEvent(event: MonitoringEvent): void {    // Adicionar timestamp se não fornecido    const eventWithTimestamp = {      ...event,      timestamp: event.timestamp || new Date().toISOString()    };     // Adicionar evento à lista    this.events.push(eventWithTimestamp);     // Limitar tamanho da lista    if (this.events.length > this.maxEvents) {      this.events = this.events.slice(-this.maxEvents);    }     // Publicar evento no MessageBus    this.messageBus.publish('monitoring:event', eventWithTimestamp);  }   /**   * Obtém todos os eventos   */  getEvents(): MonitoringEvent[] {    return [...this.events];  }   /**   * Obtém eventos por tipo   */  getEventsByType(type: string): MonitoringEvent[] {    return this.events.filter(event => event.type === type);  }   /**   * Obtém eventos por intervalo de tempo   */  getEventsByTimeRange(startTime: Date, endTime: Date): MonitoringEvent[] {    return this.events.filter(event => {      const eventTime = new Date(event.timestamp!);      return eventTime >= startTime && eventTime <= endTime;    });  }   /**   * Limpa todos os eventos   */  clearEvents(): void {    this.events = [];    this.messageBus.publish('monitoring:clear', null);  }   /**   * Define o número máximo de eventos a manter   */  setMaxEvents(max: number): void {    this.maxEvents = max;         // Ajustar lista se necessário    if (this.events.length > max) {      this.events = this.events.slice(-max);    }  }   /**   * Assina eventos de monitoramento   */  subscribeToEvents(handler: (event: MonitoringEvent) => void): () => void {    return this.messageBus.subscribe('monitoring:event', handler);  }   /**   * Gera relatório de eventos   */  generateReport(): {    totalEvents: number;    eventsByType: Record<string, number>;    timeRange: {      start: string;      end: string;    };  } {    const eventsByType: Record<string, number> = {};    let firstEventTime: string | null = null;    let lastEventTime: string | null = null;     this.events.forEach(event => {      // Contar eventos por tipo      eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;       // Rastrear intervalo de tempo      if (!firstEventTime || event.timestamp! < firstEventTime) {        firstEventTime = event.timestamp!;      }      if (!lastEventTime || event.timestamp! > lastEventTime) {        lastEventTime = event.timestamp!;      }    });     return {      totalEvents: this.events.length,      eventsByType,      timeRange: {        start: firstEventTime || new Date().toISOString(),        end: lastEventTime || new Date().toISOString()      }    };  }   /**   * Gera métricas de desempenho   */  generatePerformanceMetrics(): {    averageEventsPerMinute: number;    eventsPerType: Record<string, {      count: number;      percentage: number;    }>;  } {    const now = new Date();    const oneMinuteAgo = new Date(now.getTime() - 60000);     // Eventos no último minuto    const recentEvents = this.getEventsByTimeRange(oneMinuteAgo, now);     // Calcular eventos por tipo    const eventsByType: Record<string, number> = {};    this.events.forEach(event => {      eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;    });     // Calcular percentagens    const totalEvents = this.events.length;    const eventsPerType: Record<string, {      count: number;      percentage: number;    }> = {};     Object.entries(eventsByType).forEach(([type, count]) => {      eventsPerType[type] = {        count,        percentage: (count / totalEvents) * 100      };    });     return {      averageEventsPerMinute: recentEvents.length,      eventsPerType    };  }   /**   * Gera alerta para condição específica   */  generateAlert(condition: (events: MonitoringEvent[]) => boolean): void {    if (condition(this.events)) {      this.messageBus.publish('monitoring:alert', {        timestamp: new Date().toISOString(),        message: 'Condição de alerta detectada'      });    }  }   /**   * Configura alerta automático   */  setupAutoAlert(    condition: (events: MonitoringEvent[]) => boolean,    interval: number  ): () => void {    const timer = setInterval(() => {      this.generateAlert(condition);    }, interval);     // Retorna função para cancelar alerta    return () => clearInterval(timer);  } }`

### src/services/cache/CacheService.ts

`export class CacheService<T> {   private cache: Map<string, {    value: T;    expiresAt?: number;  }>;  private maxSize: number;  private currentSize: number;   constructor(maxSize: number = 100) {    this.cache = new Map();    this.maxSize = maxSize;    this.currentSize = 0;  }   /**   * Armazena um valor no cache   */  async set(    key: string,    value: T,    options: {      ttl?: number; // Time to live in milliseconds      size?: number; // Tamanho estimado do item    } = {}  ): Promise<void> {    try {      // Calcular tamanho do item      const itemSize = options.size || this.estimateSize(value);       // Verificar se há espaço      while (this.currentSize + itemSize > this.maxSize) {        this.evictOldest();      }       // Calcular tempo de expiração      const expiresAt = options.ttl        ? Date.now() + options.ttl        : undefined;       // Armazenar valor      this.cache.set(key, {        value,        expiresAt      });       // Atualizar tamanho atual      this.currentSize += itemSize;    } catch (error) {      console.error('Erro ao armazenar no cache:', error);      throw error;    }  }   /**   * Obtém um valor do cache   */  async get(key: string): Promise<T | null> {    try {      const item = this.cache.get(key);             if (!item) {        return null;      }       // Verificar expiração      if (item.expiresAt && Date.now() > item.expiresAt) {        this.delete(key);        return null;      }       return item.value;    } catch (error) {      console.error('Erro ao recuperar do cache:', error);      return null;    }  }   /**   * Remove um item do cache   */  delete(key: string): void {    const item = this.cache.get(key);    if (item) {      this.currentSize -= this.estimateSize(item.value);      this.cache.delete(key);    }  }   /**   * Limpa todo o cache   */  clear(): void {    this.cache.clear();    this.currentSize = 0;  }   /**   * Verifica se uma chave existe no cache   */  has(key: string): boolean {    const item = this.cache.get(key);         if (!item) {      return false;    }     // Verificar expiração    if (item.expiresAt && Date.now() > item.expiresAt) {      this.delete(key);      return false;    }     return true;  }   /**   * Obtém todas as chaves do cache   */  keys(): string[] {    return Array.from(this.cache.keys());  }   /**   * Obtém tamanho atual do cache   */  size(): number {    return this.currentSize;  }   /**   * Define tamanho máximo do cache   */  setMaxSize(size: number): void {    this.maxSize = size;         // Remover itens se necessário    while (this.currentSize > this.maxSize) {      this.evictOldest();    }  }   /**   * Estima o tamanho de um valor   */  private estimateSize(value: T): number {    if (typeof value === 'string') {      return value.length * 2; // Aproximação para UTF-16    }         if (typeof value === 'number') {      return 8; // 64 bits    }         if (typeof value === 'boolean') {      return 1;    }         if (Array.isArray(value)) {      return value.reduce((size, item) => size + this.estimateSize(item), 0);    }         if (typeof value === 'object' && value !== null) {      return Object.entries(value).reduce(        (size, [key, val]) =>          size + key.length * 2 + this.estimateSize(val as any),        0      );    }         return 0;  }   /**   * Remove o item mais antigo do cache   */  private evictOldest(): void {    const [oldestKey] = this.cache.keys();    if (oldestKey) {      this.delete(oldestKey);    }  } }`

### src/services/ai/OpenAIService.ts

``import OpenAI from 'openai'; import { MessageBus } from '../messaging/MessageBus'; import { MonitoringService } from '../monitoring/MonitoringService'; import { CacheService } from '../cache/CacheService'; interface CompletionOptions {   model?: string;  temperature?: number;  maxTokens?: number;  topP?: number;  frequencyPenalty?: number;  presencePenalty?: number; } interface ChatMessage {   role: 'system' | 'user' | 'assistant';  content: string; } export class OpenAIService {   private static instance: OpenAIService;  private openai: OpenAI;  private messageBus: MessageBus;  private monitoringService: MonitoringService;  private cache: CacheService<string>;   private constructor(apiKey: string) {    this.openai = new OpenAI({      apiKey,      dangerouslyAllowBrowser: true    });    this.messageBus = MessageBus.getInstance();    this.monitoringService = MonitoringService.getInstance();    this.cache = new CacheService<string>(1000);  }   /**   * Obtém instância única do OpenAIService (Singleton)   */  public static getInstance(apiKey: string): OpenAIService {    if (!OpenAIService.instance) {      OpenAIService.instance = new OpenAIService(apiKey);    }    return OpenAIService.instance;  }   /**   * Gera texto usando modelo de completamento   */  async generateCompletion(    prompt: string,    options: CompletionOptions = {}  ): Promise<string> {    try {      // Verificar cache      const cacheKey = this.generateCacheKey('completion', prompt, options);      const cached = await this.cache.get(cacheKey);      if (cached) {        this.logEvent('completion_cache_hit', { prompt });        return cached;      }       const startTime = Date.now();       const completion = await this.openai.chat.completions.create({        model: options.model || 'gpt-3.5-turbo',        messages: [{ role: 'user', content: prompt }],        temperature: options.temperature ?? 0.7,        max_tokens: options.maxTokens,        top_p: options.topP ?? 1,        frequency_penalty: options.frequencyPenalty ?? 0,        presence_penalty: options.presencePenalty ?? 0      });       const result = completion.choices[0]?.message?.content || '';             // Armazenar no cache      await this.cache.set(cacheKey, result, {        ttl: 3600000 // 1 hora      });       // Registrar métricas      this.logEvent('completion_success', {        prompt,        processingTime: Date.now() - startTime,        tokens: {          prompt: completion.usage?.prompt_tokens || 0,          completion: completion.usage?.completion_tokens || 0,          total: completion.usage?.total_tokens || 0        }      });       return result;    } catch (error) {      this.logEvent('completion_error', {        prompt,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Gera chat usando modelo de chat   */  async generateChat(    messages: ChatMessage[],    options: CompletionOptions = {}  ): Promise<string> {    try {      // Verificar cache      const cacheKey = this.generateCacheKey('chat', JSON.stringify(messages), options);      const cached = await this.cache.get(cacheKey);      if (cached) {        this.logEvent('chat_cache_hit', { messages });        return cached;      }       const startTime = Date.now();       const completion = await this.openai.chat.completions.create({        model: options.model || 'gpt-3.5-turbo',        messages,        temperature: options.temperature ?? 0.7,        max_tokens: options.maxTokens,        top_p: options.topP ?? 1,        frequency_penalty: options.frequencyPenalty ?? 0,        presence_penalty: options.presencePenalty ?? 0      });       const result = completion.choices[0]?.message?.content || '';             // Armazenar no cache      await this.cache.set(cacheKey, result, {        ttl: 3600000 // 1 hora      });       // Registrar métricas      this.logEvent('chat_success', {        messages,        processingTime: Date.now() - startTime,        tokens: {          prompt: completion.usage?.prompt_tokens || 0,          completion: completion.usage?.completion_tokens || 0,          total: completion.usage?.total_tokens || 0        }      });       return result;    } catch (error) {      this.logEvent('chat_error', {        messages,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Gera embeddings para um texto   */  async generateEmbedding(text: string): Promise<number[]> {    try {      // Verificar cache      const cacheKey = this.generateCacheKey('embedding', text);      const cached = await this.cache.get(cacheKey);      if (cached) {        this.logEvent('embedding_cache_hit', { text });        return JSON.parse(cached);      }       const startTime = Date.now();       const response = await this.openai.embeddings.create({        model: 'text-embedding-ada-002',        input: text      });       const result = response.data[0]?.embedding || [];             // Armazenar no cache      await this.cache.set(cacheKey, JSON.stringify(result), {        ttl: 86400000 // 24 horas      });       // Registrar métricas      this.logEvent('embedding_success', {        text,        processingTime: Date.now() - startTime,        dimensions: result.length      });       return result;    } catch (error) {      this.logEvent('embedding_error', {        text,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Gera uma chave de cache   */  private generateCacheKey(type: string, input: string, options: any = {}): string {    const key = {      type,      input,      options    };    return JSON.stringify(key);  }   /**   * Registra um evento   */  private logEvent(type: string, data: any): void {    this.monitoringService.logEvent({      type: `openai:${type}`,      data    });     // Publicar evento no MessageBus    this.messageBus.publish(`openai:${type}`, data);  } }``




### src/services/markdown/MarkdownProcessor.ts

``import { marked } from 'marked'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import * as yaml from 'js-yaml'; interface MarkdownProcessingOptions {   parseMetadata?: boolean;  highlightCode?: boolean;  sanitize?: boolean;  gfm?: boolean; } interface MarkdownProcessingResult {   html: string;  metadata?: Record<string, any>;  headings: Array<{    text: string;    level: number;    id: string;  }>;  wordCount: number;  readingTime: number;  links: string[];  images: string[];  codeBlocks: Array<{    language: string;    code: string;  }>; } export class MarkdownProcessor {   private cacheService: CacheService<MarkdownProcessingResult>;  private monitoringService: MonitoringService;   constructor(    cacheService?: CacheService<MarkdownProcessingResult>,    monitoringService?: MonitoringService  ) {    this.cacheService = cacheService || new CacheService<MarkdownProcessingResult>();    this.monitoringService = monitoringService || new MonitoringService();  }   /**   * Processa conteúdo Markdown   */  async processMarkdown(    markdown: string,    options: MarkdownProcessingOptions = {}  ): Promise<MarkdownProcessingResult> {    try {      // Gerar chave de cache      const cacheKey = this.generateCacheKey(markdown, options);             // Verificar cache      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();       // Separar metadados se necessário      let content = markdown;      let metadata: Record<string, any> | undefined;             if (options.parseMetadata) {        const parsed = this.parseMetadata(markdown);        content = parsed.content;        metadata = parsed.metadata;      }       // Configurar Marked      marked.use({        gfm: options.gfm !== false,        breaks: true,        pedantic: false,        silent: false      });       // Extrair headings, links e code blocks      const headings: Array<{        text: string;        level: number;        id: string;      }> = [];             const links: string[] = [];      const images: string[] = [];      const codeBlocks: Array<{        language: string;        code: string;      }> = [];       // Customizar renderer para extrair informações      const renderer = new marked.Renderer();             // Capturar headings      renderer.heading = (text, level) => {        const slug = text.toLowerCase()          .replace(/[^\w\s-]/g, '')          .replace(/\s+/g, '-');                 const id = `heading-${slug}`;                 headings.push({          text,          level,          id        });                 return `<h${level} id="${id}">${text}</h${level}>`;      };             // Capturar links      renderer.link = (href, title, text) => {        if (href) {          links.push(href);        }        return `<a href="${href}" title="${title || ''}">${text}</a>`;      };             // Capturar imagens      renderer.image = (href, title, text) => {        if (href) {          images.push(href);        }        return `<img src="${href}" alt="${text}" title="${title || ''}">`;      };             // Capturar blocos de código      renderer.code = (code, language) => {        codeBlocks.push({          language: language || 'text',          code        });                 return `<pre><code class="language-${language || 'text'}">${code}</code></pre>`;      };             marked.use({ renderer });       // Converter para HTML      const html = marked.parse(content, {        renderer      }) as string;       // Calcular estatísticas      const wordCount = this.countWords(content);      const readingTime = this.calculateReadingTime(wordCount);       const result: MarkdownProcessingResult = {        html,        metadata,        headings,        wordCount,        readingTime,        links,        images,        codeBlocks      };       // Registrar no cache      await this.cacheService.set(cacheKey, result);       // Registrar métricas      const processingTime = performance.now() - startTime;      this.monitoringService.logEvent({        type: 'markdown_processing',        data: {          processingTime,          wordCount,          headingsCount: headings.length,          linksCount: links.length,          imagesCount: images.length,          codeBlocksCount: codeBlocks.length        }      });       return result;    } catch (error) {      this.monitoringService.logEvent({        type: 'markdown_processing_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error'        }      });      throw error;    }  }   /**   * Extrai metadados frontmatter do Markdown   */  private parseMetadata(markdown: string): {    content: string;    metadata?: Record<string, any>;  } {    // Verificar se tem frontmatter (---...---)    const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;    const match = markdown.match(frontMatterRegex);         if (!match) {      return { content: markdown };    }         try {      // Extrair frontmatter e conteúdo      const [fullMatch, yamlContent] = match;      const content = markdown.slice(fullMatch.length);             // Parsear YAML      const metadata = yaml.load(yamlContent) as Record<string, any>;             return {        content,        metadata      };    } catch (error) {      // Em caso de erro no parsing do YAML, retornar conteúdo original      return { content: markdown };    }  }   /**   * Conta palavras em um texto   */  private countWords(text: string): number {    // Remover caracteres especiais e HTML    const cleanText = text      .replace(/<[^>]*>/g, '') // Remove HTML      .replace(/```[\s\S]*?```/g, '') // Remove blocos de código      .replace(/`[^`]*`/g, '') // Remove código inline      .replace(/\s+/g, ' ') // Normaliza espaços      .trim();         // Dividir por espaços e contar    return cleanText.split(/\s+/).filter(word => word.length > 0).length;  }   /**   * Calcula tempo de leitura em minutos   */  private calculateReadingTime(wordCount: number): number {    // Média de 200 palavras por minuto    const wordsPerMinute = 200;    return Math.ceil(wordCount / wordsPerMinute);  }   /**   * Gera chave de cache   */  private generateCacheKey(    markdown: string,    options: MarkdownProcessingOptions  ): string {    // Hash simples do conteúdo + opções    const optionsString = JSON.stringify(options);    return `md-${markdown.length}-${this.simpleHash(markdown)}-${optionsString}`;  }   /**   * Gera hash simples de uma string   */  private simpleHash(str: string): number {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash; // Convert to 32bit integer    }    return Math.abs(hash);  }   /**   * Extrai sumário (TOC)   */  extractTableOfContents(headings: Array<{    text: string;    level: number;    id: string;  }>): string {    if (headings.length === 0) {      return '';    }         let toc = '<ul class="toc">\n';    let currentLevel = 1;    const minLevel = Math.min(...headings.map(h => h.level));         headings.forEach(heading => {      const relativeLevel = heading.level - minLevel;             // Abrir listas aninhadas      while (currentLevel < relativeLevel) {        toc += '<ul>\n';        currentLevel++;      }             // Fechar listas aninhadas      while (currentLevel > relativeLevel) {        toc += '</ul>\n';        currentLevel--;      }             // Adicionar item      toc += `<li><a href="#${heading.id}">${heading.text}</a></li>\n`;    });         // Fechar listas restantes    while (currentLevel > 0) {      toc += '</ul>\n';      currentLevel--;    }         return toc;  }   /**   * Extrai primeira imagem como thumbnail   */  extractThumbnail(images: string[]): string | null {    return images.length > 0 ? images[0] : null;  }   /**   * Extrai resumo curto (primeira frase ou parágrafo)   */  extractSummary(markdown: string, maxLength: number = 150): string {    // Remover HTML, código e formatação    const plainText = markdown      .replace(/<[^>]*>/g, '')      .replace(/```[\s\S]*?```/g, '')      .replace(/`[^`]*`/g, '')      .replace(/#+\s+(.*)\n/g, '$1. ')      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')      .replace(/\*\*([^*]+)\*\*/g, '$1')      .replace(/\*([^*]+)\*/g, '$1')      .replace(/\n\s*\n/g, '. ')      .replace(/\s+/g, ' ')      .trim();         // Pegar primeiro parágrafo ou sentença    const firstSentence = plainText.split(/\.\s+/)[0] + '.';         // Truncar se necessário    return firstSentence.length > maxLength      ? firstSentence.substring(0, maxLength - 3) + '...'      : firstSentence;  } }``

### src/components/llm/provider-form/ParametersSection.tsx

``import React from "react"; import { Label } from "../../ui/label"; import { Input } from "../../ui/input"; import { Slider } from "../../ui/slider"; import { LLMProvider } from "@/types/llm"; interface ParametersSectionProps {   provider: LLMProvider;  onChange: (field: keyof LLMProvider, value: any) => void; } export function ParametersSection({ provider, onChange }: ParametersSectionProps) {   const handleParameterChange = (    parameter: keyof LLMProvider["parameters"],    value: number  ) => {    onChange("parameters", {      ...provider.parameters,      [parameter]: value,    });  };   return (    <div className="space-y-4">      <h3 className="text-sm font-semibold">Parâmetros Padrão</h3>       <div className="space-y-6">        <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`temperature-${provider.id}`}>              Temperatura ({provider.parameters?.defaultTemperature?.toFixed(1) || "0.7"})            </Label>            <span className="text-xs text-muted-foreground">              0.0 = Determinístico, 1.0 = Criativo            </span>          </div>          <Slider            id={`temperature-${provider.id}`}            min={0}            max={1}            step={0.1}            value={[provider.parameters?.defaultTemperature || 0.7]}            onValueChange={([value]) =>              handleParameterChange("defaultTemperature", value)            }          />        </div>         <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`max-tokens-${provider.id}`}>              Máximo de Tokens ({provider.parameters?.defaultMaxTokens || "1000"})            </Label>            <span className="text-xs text-muted-foreground">              Limite para resposta do modelo            </span>          </div>          <Input            id={`max-tokens-${provider.id}`}            type="number"            min={1}            max={4096}            value={provider.parameters?.defaultMaxTokens || 1000}            onChange={(e) =>              handleParameterChange(                "defaultMaxTokens",                parseInt(e.target.value, 10)              )            }          />        </div>         <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`top-p-${provider.id}`}>              Top P ({provider.parameters?.defaultTopP?.toFixed(1) || "1.0"})            </Label>            <span className="text-xs text-muted-foreground">              Amostragem por núcleo            </span>          </div>          <Slider            id={`top-p-${provider.id}`}            min={0}            max={1}            step={0.1}            value={[provider.parameters?.defaultTopP || 1.0]}            onValueChange={([value]) =>              handleParameterChange("defaultTopP", value)            }          />        </div>      </div>    </div>  ); }``

### src/components/llm/provider-form/CapabilitiesSection.tsx

``import React from "react"; import { Checkbox } from "../../ui/checkbox"; import { Label } from "../../ui/label"; import { LLMProvider } from "@/types/llm"; interface CapabilitiesSectionProps {   provider: LLMProvider;  onChange: (field: keyof LLMProvider, value: any) => void; } export function CapabilitiesSection({ provider, onChange }: CapabilitiesSectionProps) {   const handleCapabilityChange = (    capability: keyof LLMProvider["capabilities"],    checked: boolean  ) => {    onChange("capabilities", {      ...provider.capabilities,      [capability]: checked,    });  };   return (    <div className="space-y-4">      <h3 className="text-sm font-semibold">Capacidades</h3>       <div className="space-y-2">        <div className="flex items-center space-x-2">          <Checkbox            id={`text-completion-${provider.id}`}            checked={provider.capabilities?.textCompletion}            onCheckedChange={(checked) =>              handleCapabilityChange("textCompletion", !!checked)            }          />          <Label            htmlFor={`text-completion-${provider.id}`}            className="text-sm font-normal"          >            Completamento de Texto          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`chat-completion-${provider.id}`}            checked={provider.capabilities?.chatCompletion}            onCheckedChange={(checked) =>              handleCapabilityChange("chatCompletion", !!checked)            }          />          <Label            htmlFor={`chat-completion-${provider.id}`}            className="text-sm font-normal"          >            Chat Completamento          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`embedding-${provider.id}`}            checked={provider.capabilities?.embedding}            onCheckedChange={(checked) =>              handleCapabilityChange("embedding", !!checked)            }          />          <Label            htmlFor={`embedding-${provider.id}`}            className="text-sm font-normal"          >            Embeddings          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`image-generation-${provider.id}`}            checked={provider.capabilities?.imageGeneration}            onCheckedChange={(checked) =>              handleCapabilityChange("imageGeneration", !!checked)            }          />          <Label            htmlFor={`image-generation-${provider.id}`}            className="text-sm font-normal"          >            Geração de Imagem          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`audio-transcription-${provider.id}`}            checked={provider.capabilities?.audioTranscription}            onCheckedChange={(checked) =>              handleCapabilityChange("audioTranscription", !!checked)            }          />          <Label            htmlFor={`audio-transcription-${provider.id}`}            className="text-sm font-normal"          >            Transcrição de Áudio          </Label>        </div>      </div>    </div>  ); }``

### src/components/llm/monitoring/PerformanceChart.tsx

``import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { PieChart, Pie, Cell, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface PerformanceChartProps {   providerUsageData: Array<{    name: string;    requests: number;    tokens: number;    successRate: number;  }>; } export function PerformanceChart({ providerUsageData }: PerformanceChartProps) {   const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];     return (    <Card>      <CardHeader>        <CardTitle>Taxa de Sucesso</CardTitle>        <CardDescription>          Comparativo de desempenho entre provedores        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <PieChart>              <Pie                data={providerUsageData}                cx="50%"                cy="50%"                labelLine={false}                label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}                outerRadius={80}                fill="#8884d8"                dataKey="successRate"              >                {providerUsageData.map((entry, index) => (                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />                ))}              </Pie>              <Tooltip />              <Legend />            </PieChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }``

### src/components/llm/monitoring/TimelineChart.tsx

``import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface TimelineChartProps {   timelineData: Array<{    timestamp: string;    count: number;  }>; } export function TimelineChart({ timelineData }: TimelineChartProps) {   return (    <Card>      <CardHeader>        <CardTitle>Timeline de Requisições</CardTitle>        <CardDescription>          Histórico de requisições ao longo do tempo        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <LineChart              data={timelineData}              margin={{ top: 5, right: 30, left: 20, bottom: 5 }}            >              <CartesianGrid strokeDasharray="3 3" />              <XAxis                dataKey="timestamp"                tickFormatter={(value) => {                  const date = new Date(value);                  return `${date.getDate()}/${date.getMonth() + 1}`;                }}              />              <YAxis />              <Tooltip                labelFormatter={(value) => {                  const date = new Date(value);                  return date.toLocaleDateString();                }}              />              <Legend />              <Line                type="monotone"                dataKey="count"                name="Requisições"                stroke="#8884d8"                activeDot={{ r: 8 }}              />            </LineChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }``

### src/components/llm/monitoring/UsageChart.tsx

`import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface UsageChartProps {   providerUsageData: Array<{    name: string;    requests: number;    tokens: number;    successRate: number;  }>; } export function UsageChart({ providerUsageData }: UsageChartProps) {   return (    <Card>      <CardHeader>        <CardTitle>Uso por Provedor</CardTitle>        <CardDescription>          Comparativo de uso entre os diferentes provedores de LLM        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <BarChart              data={providerUsageData}              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}            >              <CartesianGrid strokeDasharray="3 3" />              <XAxis dataKey="name" />              <YAxis />              <Tooltip />              <Legend />              <Bar dataKey="requests" name="Requisições" fill="#8884d8" />              <Bar dataKey="tokens" name="Tokens (x100)" fill="#82ca9d" />            </BarChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }`

### src/hooks/llm/useCompletions.ts

`import { useState, useCallback } from 'react'; import { CompletionOptions, ChatMessage, ChatResponse } from '../../types/llm'; import { llmServiceInstance } from './llmServiceInstance'; export const useCompletions = () => {   const [isLoading, setIsLoading] = useState(false);  const [error, setError] = useState<string | null>(null);   const generateCompletion = useCallback(async (    prompt: string,    options?: CompletionOptions  ): Promise<string> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateCompletion(prompt, options);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   const generateChat = useCallback(async (    messages: ChatMessage[],    options?: CompletionOptions  ): Promise<ChatResponse> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateChat(messages, options);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   const generateEmbedding = useCallback(async (    text: string  ): Promise<number[]> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateEmbedding(text);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   return {    generateCompletion,    generateChat,    generateEmbedding,    isLoading,    error  }; };`

### src/hooks/useLLM.ts

`import { useState, useEffect, useCallback } from 'react'; import { llmServiceInstance } from './llm/llmServiceInstance'; import { LLMProvider, LLMPipeline } from '@/types/llm'; export function useLLM() {   const [providers, setProviders] = useState<LLMProvider[]>([]);  const [pipelines, setPipelines] = useState<LLMPipeline[]>([]);  const [defaultProvider, setDefaultProvider] = useState<string>('');  const [isLoading, setIsLoading] = useState(true);     useEffect(() => {    // Carregar provedores ao inicializar    const loadProviders = () => {      const allProviders = llmServiceInstance.listProviders();      const defaultProviderID = llmServiceInstance.getDefaultProvider();      const allPipelines = llmServiceInstance.listPipelines();             setProviders(allProviders);      setDefaultProvider(defaultProviderID);      setPipelines(allPipelines);      setIsLoading(false);    };         loadProviders();  }, []);     // Gerenciamento de provedores  const addProvider = useCallback((provider: LLMProvider) => {    llmServiceInstance.addProvider(provider);    setProviders(llmServiceInstance.listProviders());  }, []);     const updateProvider = useCallback((providerId: string, updates: Partial<LLMProvider>) => {    llmServiceInstance.updateProvider(providerId, updates);    setProviders(llmServiceInstance.listProviders());  }, []);     const removeProvider = useCallback((providerId: string) => {    llmServiceInstance.removeProvider(providerId);    setProviders(llmServiceInstance.listProviders());  }, []);     const changeDefaultProvider = useCallback((providerId: string) => {    llmServiceInstance.setDefaultProvider(providerId);    setDefaultProvider(providerId);  }, []);     // Gerenciamento de pipelines  const addPipeline = useCallback((pipeline: LLMPipeline) => {    llmServiceInstance.addPipeline(pipeline);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const updatePipeline = useCallback((pipelineId: string, updates: Partial<LLMPipeline>) => {    llmServiceInstance.updatePipeline(pipelineId, updates);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const removePipeline = useCallback((pipelineId: string) => {    llmServiceInstance.removePipeline(pipelineId);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const executePipeline = useCallback((pipelineId: string, input: string) => {    return llmServiceInstance.executePipeline(pipelineId, input);  }, []);   // Métodos de geração  const generateCompletion = useCallback((prompt: string, options?: any) => {    return llmServiceInstance.generateCompletion(prompt, options);  }, []);     const generateChat = useCallback((messages: any[], options?: any) => {    return llmServiceInstance.generateChat(messages, options);  }, []);     const generateEmbedding = useCallback((text: string) => {    return llmServiceInstance.generateEmbedding(text);  }, []);   return {    // Estado    providers,    pipelines,    defaultProvider,    isLoading,         // Gerenciamento de provedores    addProvider,    updateProvider,    removeProvider,    changeDefaultProvider,         // Gerenciamento de pipelines    addPipeline,    updatePipeline,    removePipeline,    executePipeline,         // Métodos de geração    generateCompletion,    generateChat,    generateEmbedding  }; }`

### src/hooks/useDocumentProcessor.ts

``import { useState, useCallback } from 'react'; import { useCompletions } from './llm/useCompletions'; import { ProcessedDocument } from '@/types/knowledge'; export const useDocumentProcessor = () => {   const [content, setContent] = useState<string>('');  const [isProcessing, setIsProcessing] = useState<boolean>(false);  const [processingProgress, setProcessingProgress] = useState<number>(0);  const [result, setResult] = useState<ProcessedDocument | null>(null);  const [viewMode, setViewMode] = useState<'input' | 'output'>('input');     const { generateCompletion } = useCompletions();   const processStep = async (step: string, stepNumber: number, totalSteps: number) => {    setProcessingProgress(Math.floor((stepNumber / totalSteps) * 100));         // Lógica específica para cada passo    switch (step) {      case 'analysis':        return analyzeDocument(content);      case 'structure':        return extractStructure(content);      case 'validation':        return validateDocument(content);      case 'suggestions':        return generateSuggestions(content);      default:        return null;    }  };   const handleProcess = useCallback(async () => {    if (!content.trim()) return;         setIsProcessing(true);    setProcessingProgress(0);    setResult(null);         try {      // Definição dos passos      const steps = ['analysis', 'structure', 'validation', 'suggestions'];      const totalSteps = steps.length;             // Processar cada passo sequencialmente      const processedContent = { content, title: getDocumentTitle(content) };      const results: any = {};             for (let i = 0; i < steps.length; i++) {        const stepResult = await processStep(steps[i], i + 1, totalSteps);        results[steps[i]] = stepResult;      }             // Compilar resultado final      const processedDocument: ProcessedDocument = {        id: generateId(),        title: processedContent.title,        content: processedContent.content,        metadata: {          processedAt: new Date().toISOString(),          wordCount: countWords(content),          readingTime: calculateReadingTime(content),          category: detectCategory(content),          ...results.analysis?.metadata        },        structure: results.structure,        analysis: results.analysis,        validationResult: results.validation,        suggestions: results.suggestions,        processingDate: new Date().toISOString(),        status: 'processed'      };             setResult(processedDocument);      setProcessingProgress(100);      setViewMode('output');    } catch (error) {      console.error('Erro ao processar documento:', error);    } finally {      setIsProcessing(false);    }  }, [content, generateCompletion]);   const resetProcessor = useCallback(() => {    setContent('');    setResult(null);    setProcessingProgress(0);    setViewMode('input');  }, []);   // Funções auxiliares internas  const analyzeDocument = async (text: string) => {    const prompt = `      Analise o seguinte documento Markdown e extraia informações importantes:      1. Tópicos principais      2. Conceitos-chave      3. Complexidade (baixa, média, alta)      4. Palavras-chave      5. Categoria do documento             Formate a resposta como um JSON com as seguintes chaves:      {        "topics": ["Tópico 1", "Tópico 2", ...],        "concepts": ["Conceito 1", "Conceito 2", ...],        "complexity": "baixa|média|alta",        "keywords": ["palavra1", "palavra2", ...],        "category": "categoria do documento",        "summary": "Breve resumo do conteúdo (máx. 100 palavras)"      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de análise');    } catch (error) {      console.error('Erro na análise:', error);      return {        topics: [],        concepts: [],        complexity: 'média',        keywords: [],        category: 'Não determinado',        summary: 'Não foi possível gerar um resumo.'      };    }  };   const extractStructure = async (text: string) => {    const prompt = `      Analise o seguinte documento Markdown e extraia sua estrutura:      1. Headings (h1, h2, h3, etc.) com hierarquia      2. Principais seções      3. Elementos visuais (imagens, tabelas, etc.)      4. Listas e enumerações             Formate a resposta como um JSON com as seguintes chaves:      {        "headings": [          {"level": 1, "text": "Título principal", "children": [            {"level": 2, "text": "Subtítulo", "children": []}          ]}        ],        "sections": ["Seção 1", "Seção 2", ...],        "visualElements": ["Elemento 1", "Elemento 2", ...],        "lists": ["Lista 1", "Lista 2", ...]      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de estrutura');    } catch (error) {      console.error('Erro na extração de estrutura:', error);      return {        headings: [],        sections: [],        visualElements: [],        lists: []      };    }  };   const validateDocument = async (text: string) => {    const prompt = `      Valide o seguinte documento Markdown e identifique possíveis problemas:      1. Erros gramaticais ou ortográficos      2. Inconsistências de estilo ou formato      3. Links quebrados (URLs malformadas)      4. Problemas de organização ou estrutura             Formate a resposta como um JSON com as seguintes chaves:      {        "issues": [          {"type": "grammar|spelling|style|link|structure", "description": "Descrição do problema", "severity": "high|medium|low", "location": "Onde ocorre"}        ],        "score": X.X (pontuação de 0.0 a 10.0)      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de validação');    } catch (error) {      console.error('Erro na validação:', error);      return {        issues: [],        score: 5.0      };    }  };   const generateSuggestions = async (text: string) => {    const prompt = `      Com base no seguinte documento Markdown, forneça sugestões para melhorá-lo:      1. Clareza e legibilidade      2. Estrutura e organização      3. Completude do conteúdo      4. Formatação e apresentação             Formate a resposta como uma lista de sugestões no formato JSON:      [        {"title": "Título da sugestão", "description": "Descrição detalhada"}      ]             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.5,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de sugestões');    } catch (error) {      console.error('Erro ao gerar sugestões:', error);      return [];    }  };   const getDocumentTitle = (text: string): string => {    // Buscar pelo primeiro heading (# Título)    const headingMatch = text.match(/^#\s+(.+)$/m);    if (headingMatch && headingMatch[1]) {      return headingMatch[1].trim();    }         // Se não encontrar, usar as primeiras palavras    const firstLine = text.split('\n')[0];    if (firstLine && firstLine.length > 0) {      return firstLine.length > 50        ? firstLine.substring(0, 47) + '...'        : firstLine;    }         return 'Documento sem título';  };   const generateId = (): string => {    return 'doc-' + Math.random().toString(36).substring(2, 9);  };   const countWords = (text: string): number => {    return text.split(/\s+/).filter(word => word.length > 0).length;  };   const calculateReadingTime = (text: string): number => {    const words = countWords(text);    // Tempo médio de leitura: 200 palavras por minuto    return Math.ceil(words / 200);  };   const detectCategory = (text: string): string => {    // Implementação simples baseada em palavras-chave    if (text.match(/\b(código|function|class|import|export|const|var|let)\b/i)) {      return 'Programação';    }         if (text.match(/\b(api|rest|http|endpoint|request|response)\b/i)) {      return 'API';    }         if (text.match(/\b(design|ui|ux|interface|usuário|experiência)\b/i)) {      return 'Design';    }         if (text.match(/\b(arquitetura|sistema|componente|módulo|serviço)\b/i)) {      return 'Arquitetura';    }         return 'Documentação Geral';  };   return {    content,    setContent,    isProcessing,    processingProgress,    result,    viewMode,    setViewMode,    handleProcess,    resetProcessor  }; };``


### src/services/document/DocumentProcessor.ts

``import { Document, ProcessedDocument } from '@/types/knowledge'; import { OpenAIService } from '../ai/OpenAIService'; import { DocumentStructureService } from './DocumentStructureService'; import { DocumentValidationService } from './DocumentValidationService'; import { SuggestionService } from './SuggestionService'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class DocumentProcessor {   private openAIService: OpenAIService;  private structureService: DocumentStructureService;  private validationService: DocumentValidationService;  private suggestionService: SuggestionService;  private cacheService: CacheService<ProcessedDocument>;  private monitoringService: MonitoringService;   constructor(    openAIKey: string,    cacheService?: CacheService<ProcessedDocument>,    monitoringService?: MonitoringService  ) {    this.openAIService = OpenAIService.getInstance(openAIKey);    this.structureService = new DocumentStructureService(this.openAIService);    this.validationService = new DocumentValidationService(this.openAIService);    this.suggestionService = new SuggestionService(this.openAIService);    this.cacheService = cacheService || new CacheService<ProcessedDocument>();    this.monitoringService = monitoringService || MonitoringService.getInstance();  }   /**   * Processa um documento   */  async processDocument(document: Document): Promise<ProcessedDocument> {    try {      const startTime = Date.now();      this.logEvent('document_processing_start', { documentId: document.id });       // Verificar cache      const cacheKey = this.generateCacheKey(document);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        this.logEvent('document_processing_cache_hit', { documentId: document.id });        return cached;      }       // Processar documento      const processedDocument = await this.processDocumentSteps(document);       // Armazenar em cache      await this.cacheService.set(cacheKey, processedDocument);       // Registrar métricas      const processingTime = Date.now() - startTime;      this.logEvent('document_processing_complete', {        documentId: document.id,        processingTime,        wordCount: this.countWords(document.content),        status: processedDocument.status      });       return processedDocument;    } catch (error) {      this.logEvent('document_processing_error', {        documentId: document.id,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Processa um documento em etapas   */  private async processDocumentSteps(document: Document): Promise<ProcessedDocument> {    // Etapa 1: Análise    const analysis = await this.analyzeDocument(document);     // Etapa 2: Estrutura    const structure = await this.structureService.extractStructure(document.content);     // Etapa 3: Validação    const validationResult = await this.validationService.validateDocument(document.content);     // Etapa 4: Sugestões    const suggestions = await this.suggestionService.generateSuggestions(document.content);     // Compilar resultado    return {      id: document.id || this.generateId(),      title: document.title || this.extractTitle(document.content),      content: document.content,      metadata: {        processedAt: new Date().toISOString(),        wordCount: this.countWords(document.content),        readingTime: this.calculateReadingTime(document.content),        category: analysis.category || 'Uncategorized',        ...analysis.metadata      },      analysis,      structure,      validationResult,      suggestions,      processingDate: new Date().toISOString(),      status: 'processed'    };  }   /**   * Analisa o documento para extrair informações   */  private async analyzeDocument(document: Document): Promise<{    topics: string[];    concepts: Array<{ name: string; importance: number }>;    complexity: string;    keywords: string[];    category: string;    summary: string;    metadata?: Record<string, any>;  }> {    try {      const prompt = `        Analise o seguinte documento e extraia informações importantes:        1. Tópicos principais (3-7 tópicos)        2. Conceitos-chave (3-10 conceitos com nível de importância de 0.0 a 1.0)        3. Complexidade (baixa, média, alta)        4. Palavras-chave (5-15 palavras)        5. Categoria do documento        6. Resumo (max. 150 palavras)                 Formate a resposta como um JSON:        {          "topics": ["Tópico 1", "Tópico 2", ...],          "concepts": [            {"name": "Conceito 1", "importance": 0.9},            {"name": "Conceito 2", "importance": 0.7},            ...          ],          "complexity": "baixa|média|alta",          "keywords": ["palavra1", "palavra2", ...],          "category": "categoria do documento",          "summary": "Resumo do conteúdo..."        }                 Documento:        ${document.content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-4-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para análise');    } catch (error) {      console.error('Erro ao analisar documento:', error);      return {        topics: [],        concepts: [],        complexity: 'média',        keywords: [],        category: 'Não determinado',        summary: 'Não foi possível gerar um resumo.'      };    }  }   /**   * Extrai título do conteúdo   */  private extractTitle(content: string): string {    // Buscar pelo primeiro heading (# Título)    const headingMatch = content.match(/^#\s+(.+)$/m);    if (headingMatch && headingMatch[1]) {      return headingMatch[1].trim();    }     // Se não encontrar, usar as primeiras palavras    const firstLine = content.split('\n')[0];    if (firstLine && firstLine.length > 0) {      return firstLine.length > 50        ? firstLine.substring(0, 47) + '...'        : firstLine;    }     return 'Documento sem título';  }   /**   * Gera um ID para o documento   */  private generateId(): string {    return 'doc-' + Math.random().toString(36).substring(2, 9);  }   /**   * Conta palavras em um texto   */  private countWords(text: string): number {    return text.split(/\s+/).filter(word => word.length > 0).length;  }   /**   * Calcula tempo de leitura em minutos   */  private calculateReadingTime(text: string): number {    const words = this.countWords(text);    // Tempo médio de leitura: 200 palavras por minuto    return Math.ceil(words / 200);  }   /**   * Gera chave de cache   */  private generateCacheKey(document: Document): string {    return `doc-${document.id}-${this.simpleHash(document.content)}`;  }   /**   * Gera hash simples   */  private simpleHash(str: string): number {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash; // Convert to 32bit integer    }    return Math.abs(hash);  }   /**   * Registra evento   */  private logEvent(type: string, data: any): void {    this.monitoringService.logEvent({      type: `document_processor:${type}`,      data    });  } }``

### src/services/document/DocumentStructureService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface DocumentStructure {   headings: Array<{    level: number;    text: string;    children?: Array<{      level: number;      text: string;      children?: any[];    }>;  }>;  sections: string[];  visualElements: string[];  lists: string[]; } export class DocumentStructureService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Extrai estrutura de um documento   */  async extractStructure(content: string): Promise<DocumentStructure> {    try {      const prompt = `        Analise o seguinte documento e extraia sua estrutura:        1. Headings (h1, h2, h3, etc.) com hierarquia        2. Principais seções        3. Elementos visuais (imagens, tabelas, etc.)        4. Listas e enumerações                 Formate a resposta como um JSON:        {          "headings": [            {"level": 1, "text": "Título principal", "children": [              {"level": 2, "text": "Subtítulo", "children": []}            ]}          ],          "sections": ["Seção 1", "Seção 2", ...],          "visualElements": ["Elemento 1", "Elemento 2", ...],          "lists": ["Lista 1", "Lista 2", ...]        }                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para estrutura');    } catch (error) {      console.error('Erro ao extrair estrutura:', error);      return {        headings: [],        sections: [],        visualElements: [],        lists: []      };    }  }   /**   * Extrai estrutura de headings usando expressões regulares   */  extractHeadingsWithRegex(content: string): Array<{    level: number;    text: string;  }> {    const headings: Array<{      level: number;      text: string;    }> = [];         // Expressão regular para headings Markdown    const headingRegex = /^(#{1,6})\s+(.+)$/gm;    let match;         while ((match = headingRegex.exec(content)) !== null) {      const level = match[1].length;      const text = match[2].trim();             headings.push({        level,        text      });    }         return headings;  }   /**   * Constrói hierarquia de headings   */  buildHeadingHierarchy(headings: Array<{    level: number;    text: string;  }>): Array<{    level: number;    text: string;    children: any[];  }> {    if (headings.length === 0) {      return [];    }         const result: Array<{      level: number;      text: string;      children: any[];    }> = [];    let currentLevel1: any = null;    let currentLevel2: any = null;    let currentLevel3: any = null;         for (const heading of headings) {      const node = {        level: heading.level,        text: heading.text,        children: []      };             switch (heading.level) {        case 1:          currentLevel1 = node;          result.push(currentLevel1);          currentLevel2 = null;          currentLevel3 = null;          break;        case 2:          currentLevel2 = node;          if (currentLevel1) {            currentLevel1.children.push(currentLevel2);          } else {            result.push(currentLevel2);          }          currentLevel3 = null;          break;        case 3:          currentLevel3 = node;          if (currentLevel2) {            currentLevel2.children.push(currentLevel3);          } else if (currentLevel1) {            currentLevel1.children.push(currentLevel3);          } else {            result.push(currentLevel3);          }          break;        default:          // Níveis mais profundos          if (currentLevel3) {            currentLevel3.children.push(node);          } else if (currentLevel2) {            currentLevel2.children.push(node);          } else if (currentLevel1) {            currentLevel1.children.push(node);          } else {            result.push(node);          }      }    }         return result;  }   /**   * Extrai listas usando expressões regulares   */  extractListsWithRegex(content: string): string[] {    const lists: string[] = [];         // Expressão regular para listas não ordenadas    const ulRegex = /^(\s*[-*+]\s+.+\n)+/gm;    let ulMatch;         while ((ulMatch = ulRegex.exec(content)) !== null) {      lists.push(ulMatch[0].trim());    }         // Expressão regular para listas ordenadas    const olRegex = /^(\s*\d+\.\s+.+\n)+/gm;    let olMatch;         while ((olMatch = olRegex.exec(content)) !== null) {      lists.push(olMatch[0].trim());    }         return lists;  }   /**   * Extrai elementos visuais usando expressões regulares   */  extractVisualElementsWithRegex(content: string): string[] {    const visualElements: string[] = [];         // Expressão regular para imagens    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/gm;    let imgMatch;         while ((imgMatch = imageRegex.exec(content)) !== null) {      const altText = imgMatch[1];      const url = imgMatch[2];      visualElements.push(`Imagem: ${altText || 'Sem descrição'} (${url})`);    }         // Expressão regular para tabelas simplificadas    const tableRegex = /^\|(.+\|)+\n\|(\s*[-:]+\s*\|)+\n(\|.+\|(\n|$))+/gm;    let tableMatch;         while ((tableMatch = tableRegex.exec(content)) !== null) {      visualElements.push(`Tabela: ${tableMatch[0].split('\n')[0]}`);    }         return visualElements;  }   /**   * Gera tabela de conteúdo (TOC)   */  generateTableOfContents(headings: Array<{    level: number;    text: string;  }>): string {    if (headings.length === 0) {      return '';    }         let toc = '';    let previousLevel = 0;         for (const heading of headings) {      const slug = heading.text.toLowerCase()        .replace(/[^\w\s-]/g, '')        .replace(/\s+/g, '-');             // Ajustar indentação      if (heading.level > previousLevel) {        for (let i = 0; i < heading.level - previousLevel; i++) {          toc += '\n';        }      }             // Adicionar item      toc += '  '.repeat(heading.level - 1);      toc += `- [${heading.text}](#${slug})\n`;             previousLevel = heading.level;    }         return toc;  } }``

### src/services/document/DocumentValidationService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface ValidationResult {   issues: Array<{    type: 'grammar' | 'spelling' | 'style' | 'link' | 'structure';    description: string;    severity: 'high' | 'medium' | 'low';    location: string;  }>;  score: number; } export class DocumentValidationService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Valida um documento   */  async validateDocument(content: string): Promise<ValidationResult> {    try {      const prompt = `        Valide o seguinte documento e identifique possíveis problemas:        1. Erros gramaticais ou ortográficos        2. Inconsistências de estilo ou formato        3. Links quebrados (URLs malformadas)        4. Problemas de organização ou estrutura                 Formate a resposta como um JSON:        {          "issues": [            {"type": "grammar|spelling|style|link|structure", "description": "Descrição do problema", "severity": "high|medium|low", "location": "Onde ocorre"}          ],          "score": X.X (pontuação de 0.0 a 10.0)        }                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para validação');    } catch (error) {      console.error('Erro ao validar documento:', error);      return {        issues: [],        score: 5.0      };    }  }   /**   * Realiza verificações básicas no documento   */  performBasicChecks(content: string): ValidationResult {    const issues: Array<{      type: 'grammar' | 'spelling' | 'style' | 'link' | 'structure';      description: string;      severity: 'high' | 'medium' | 'low';      location: string;    }> = [];         // Verificar links quebrados    const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;    let match;         while ((match = linkRegex.exec(content)) !== null) {      const linkText = match[1];      const url = match[2];             if (!this.isValidUrl(url)) {        issues.push({          type: 'link',          description: `Link potencialmente malformado: "${url}"`,          severity: 'medium',          location: `Link: ${linkText}`        });      }    }         // Verificar headings vazios    const emptyHeadingRegex = /^#+\s*$/gm;         while ((match = emptyHeadingRegex.exec(content)) !== null) {      issues.push({        type: 'structure',        description: 'Heading vazio',        severity: 'medium',        location: `Linha: ${this.getLineNumber(content, match.index)}`      });    }         // Verificar parágrafos muito longos    const paragraphs = content.split(/\n\s*\n/);    for (let i = 0; i < paragraphs.length; i++) {      const paragraph = paragraphs[i];      if (paragraph.length > 500) {        issues.push({          type: 'style',          description: 'Parágrafo muito longo (>500 caracteres)',          severity: 'low',          location: `Parágrafo ${i + 1}`        });      }    }         // Calcular pontuação    const score = 10 - (issues.length * 0.5);    const normalizedScore = Math.max(0, Math.min(10, score));         return {      issues,      score: normalizedScore    };  }   /**   * Verifica se uma URL é válida   */  private isValidUrl(url: string): boolean {    try {      new URL(url);      return true;    } catch (e) {      // Aceitar links relativos      return /^[/#][a-zA-Z0-9-_/]*$/.test(url);    }  }   /**   * Obtém número da linha para um índice   */  private getLineNumber(content: string, index: number): number {    const lines = content.slice(0, index).split('\n');    return lines.length;  }   /**   * Detecta inconsistências de formatação   */  detectFormattingInconsistencies(content: string): Array<{    type: 'style';    description: string;    severity: 'low';    location: string;  }> {    const issues: Array<{      type: 'style';      description: string;      severity: 'low';      location: string;    }> = [];         // Verificar inconsistências em listas    const ulFormats = new Set();    const ulItems = content.match(/^(\s*)[-*+]\s+.+$/gm);         if (ulItems) {      ulItems.forEach(item => {        const marker = item.match(/^(\s*)([*\-+])/)?.[2];        if (marker) {          ulFormats.add(marker);        }      });             if (ulFormats.size > 1) {        issues.push({          type: 'style',          description: `Inconsistência nos marcadores de lista não ordenada: ${Array.from(ulFormats).join(', ')}`,          severity: 'low',          location: 'Listas não ordenadas'        });      }    }         // Verificar inconsistências em headings    const headingStyles = new Set();    const headings = content.match(/^(#+)\s+.+$/gm);         if (headings) {      headings.forEach(heading => {        const hasSpace = /^#+\s+/.test(heading);        headingStyles.add(hasSpace ? 'com espaço' : 'sem espaço');      });             if (headingStyles.size > 1) {        issues.push({          type: 'style',          description: 'Inconsistência na formatação de headings (com/sem espaço após #)',          severity: 'low',          location: 'Headings'        });      }    }         return issues;  } }``

### src/services/document/SuggestionService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface Suggestion {   title: string;  description: string; } export class SuggestionService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Gera sugestões para um documento   */  async generateSuggestions(content: string): Promise<Suggestion[]> {    try {      const prompt = `        Com base no seguinte documento, forneça sugestões para melhorá-lo:        1. Clareza e legibilidade        2. Estrutura e organização        3. Completude do conteúdo        4. Formatação e apresentação                 Formate a resposta como uma lista de sugestões no formato JSON:        [          {"title": "Título da sugestão", "description": "Descrição detalhada"}        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.5,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para sugestões');    } catch (error) {      console.error('Erro ao gerar sugestões:', error);      return [];    }  }   /**   * Gera exemplos de melhoria para um documento   */  async generateExamples(content: string): Promise<Array<{    original: string;    improved: string;    explanation: string;  }>> {    try {      const prompt = `        Com base no seguinte documento, forneça 3 exemplos de melhorias específicas:                 Formate a resposta como JSON:        [          {            "original": "Trecho original",            "improved": "Versão melhorada",            "explanation": "Explicação da melhoria"          }        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-4-turbo',        temperature: 0.5,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para exemplos');    } catch (error) {      console.error('Erro ao gerar exemplos:', error);      return [];    }  }   /**   * Gera sugestões específicas para um tipo de problema   */  async generateSpecificSuggestions(    content: string,    aspect: 'clarity' | 'structure' | 'completeness' | 'formatting'  ): Promise<Suggestion[]> {    try {      let aspectPrompt = '';             switch (aspect) {        case 'clarity':          aspectPrompt = 'melhorar a clareza e legibilidade';          break;        case 'structure':          aspectPrompt = 'aprimorar a estrutura e organização';          break;        case 'completeness':          aspectPrompt = 'aumentar a completude do conteúdo';          break;        case 'formatting':          aspectPrompt = 'melhorar a formatação e apresentação';          break;      }             const prompt = `        Com base no seguinte documento, forneça sugestões específicas para ${aspectPrompt}:                 Formate a resposta como uma lista de sugestões no formato JSON:        [          {"title": "Título da sugestão", "description": "Descrição detalhada"}        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.5,        maxTokens: 800      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para sugestões específicas');    } catch (error) {      console.error(`Erro ao gerar sugestões para ${aspect}:`, error);      return [];    }  } }``

### src/plugins/MarkdownAnalyzerPlugin.ts

``import { Plugin } from '@/types/plugin'; export interface AnalysisResult {   headings: Array<{    level: number;    text: string;    position: {      start: number;      end: number;    };  }>;  links: Array<{    text: string;    url: string;    position: {      start: number;      end: number;    };  }>;  images: Array<{    altText: string;    url: string;    position: {      start: number;      end: number;    };  }>;  codeBlocks: Array<{    language: string;    code: string;    position: {      start: number;      end: number;    };  }>;  lists: Array<{    type: 'ordered' | 'unordered';    items: string[];    position: {      start: number;      end: number;    };  }>;  statistics: {    wordCount: number;    charCount: number;    paragraphCount: number;  }; } export class MarkdownAnalyzerPlugin implements Plugin {   id = 'markdown-analyzer';  name = 'Markdown Analyzer';  description = 'Analisa documentos Markdown para extrair estrutura e metadados';  version = '1.0.0';  author = 'System';   /**   * Analisa um documento Markdown   */  analyze(content: string): AnalysisResult {    // Extrair headings    const headings = this.extractHeadings(content);         // Extrair links    const links = this.extractLinks(content);         // Extrair imagens    const images = this.extractImages(content);         // Extrair blocos de código    const codeBlocks = this.extractCodeBlocks(content);         // Extrair listas    const lists = this.extractLists(content);         // Calcular estatísticas    const statistics = this.calculateStatistics(content);         return {      headings,      links,      images,      codeBlocks,      lists,      statistics    };  }   /**   * Extrai headings do Markdown   */  private extractHeadings(content: string): Array<{    level: number;    text: string;    position: {      start: number;      end: number;    };  }> {    const headings: Array<{      level: number;      text: string;      position: {        start: number;        end: number;      };    }> = [];         const headingRegex = /^(#{1,6})\s+(.+)$/gm;    let match;         while ((match = headingRegex.exec(content)) !== null) {      const level = match[1].length;      const text = match[2].trim();      const start = match.index;      const end = match.index + match[0].length;             headings.push({        level,        text,        position: {          start,          end        }      });    }         return headings;  }   /**   * Extrai links do Markdown   */  private extractLinks(content: string): Array<{    text: string;    url: string;    position: {      start: number;      end: number;    };  }> {    const links: Array<{      text: string;      url: string;      position: {        start: number;        end: number;      };    }> = [];         const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;    let match;         while ((match = linkRegex.exec(content)) !== null) {      const text = match[1];      const url = match[2];      const start = match.index;      const end = match.index + match[0].length;             links.push({        text,        url,        position: {          start,          end        }      });    }         return links;  }   /**   * Extrai imagens do Markdown   */  private extractImages(content: string): Array<{    altText: string;    url: string;    position: {      start: number;      end: number;    };  }> {    const images: Array<{      altText: string;      url: string;      position: {        start: number;        end: number;      };    }> = [];         const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;    let match;         while ((match = imageRegex.exec(content)) !== null) {      const altText = match[1];      const url = match[2];      const start = match.index;      const end = match.index + match[0].length;             images.push({        altText,        url,        position: {          start,          end        }      });    }         return images;  }   /**   * Extrai blocos de código do Markdown   */  private extractCodeBlocks(content: string): Array<{    language: string;    code: string;    position: {      start: number;      end: number;    };  }> {    const codeBlocks: Array<{      language: string;      code: string;      position: {        start: number;        end: number;      };    }> = [];         const codeBlockRegex = /```([a-zA-Z0-9]*)\n([\s\S]*?)```/g;    let match;         while ((match = codeBlockRegex.exec(content)) !== null) {      const language = match[1] || 'text';      const code = match[2];      const start = match.index;      const end = match.index + match[0].length;             codeBlocks.push({        language,        code,        position: {          start,          end        }      });    }         return codeBlocks;  }   /**   * Extrai listas do Markdown   */  private extractLists(content: string): Array<{    type: 'ordered' | 'unordered';    items: string[];    position: {      start: number;      end: number;    };  }> {    const lists: Array<{      type: 'ordered' | 'unordered';      items: string[];      position: {        start: number;        end: number;      };    }> = [];         // Listas não ordenadas    const ulRegex = /^(\s*[-*+]\s+.+\n)+/gm;    let ulMatch;         while ((ulMatch = ulRegex.exec(content)) !== null) {      const listText = ulMatch[0];      const start = ulMatch.index;      const end = ulMatch.index + listText.length;             // Extrair itens      const items = listText        .split('\n')        .filter(line => line.trim().length > 0)        .map(line => line.replace(/^\s*[-*+]\s+/, '').trim());             lists.push({        type: 'unordered',        items,        position: {          start,          end        }      });    }         // Listas ordenadas    const olRegex = /^(\s*\d+\.\s+.+\n)+/gm;    let olMatch;         while ((olMatch = olRegex.exec(content)) !== null) {      const listText = olMatch[0];      const start = olMatch.index;      const end = olMatch.index + listText.length;             // Extrair itens      const items = listText        .split('\n')        .filter(line => line.trim().length > 0)        .map(line => line.replace(/^\s*\d+\.\s+/, '').trim());             lists.push({        type: 'ordered',        items,        position: {          start,          end        }      });    }         return lists;  }   /**   * Calcula estatísticas do Markdown   */  private calculateStatistics(content: string): {    wordCount: number;    charCount: number;    paragraphCount: number;  } {    // Remover blocos de código    const contentWithoutCode = content.replace(/```[\s\S]*?```/g, '');         // Remover marcações básicas (links, ênfase, etc.)    const plainText = contentWithoutCode      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // links      .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1') // imagens      .replace(/[*_]{1,2}([^*_]+)[*_]{1,2}/g, '$1') // ênfase      .replace(/`([^`]+)`/g, '$1'); // código inline         // Contar caracteres    const charCount = plainText.length;         // Contar palavras    const wordCount = plainText      .split(/\s+/)      .filter(word => word.length > 0)      .length;         // Contar parágrafos    const paragraphCount = plainText      .split(/\n\s*\n/)      .filter(p => p.trim().length > 0)      .length;         return {      wordCount,      charCount,      paragraphCount    };  }   /**   * Gera tabela de conteúdo (TOC) a partir de headings   */  generateTableOfContents(    headings: Array<{      level: number;      text: string;    }>  ): string {    if (headings.length === 0) {      return '';    }         let toc = '';    const minLevel = Math.min(...headings.map(h => h.level));         for (const heading of headings) {      const slug = heading.text.toLowerCase()        .replace(/[^\w\s-]/g, '')        .replace(/\s+/g, '-');             const indent = '  '.repeat(heading.level - minLevel);      toc += `${indent}- [${heading.text}](#${slug})\n`;    }         return toc;  } }``


### src/services/markdown/MarkdownProcessor.ts

``import { marked } from 'marked'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; import * as yaml from 'js-yaml'; interface MarkdownProcessingOptions {   parseMetadata?: boolean;  highlightCode?: boolean;  sanitize?: boolean;  gfm?: boolean; } interface MarkdownProcessingResult {   html: string;  metadata?: Record<string, any>;  headings: Array<{    text: string;    level: number;    id: string;  }>;  wordCount: number;  readingTime: number;  links: string[];  images: string[];  codeBlocks: Array<{    language: string;    code: string;  }>; } export class MarkdownProcessor {   private cacheService: CacheService<MarkdownProcessingResult>;  private monitoringService: MonitoringService;   constructor(    cacheService?: CacheService<MarkdownProcessingResult>,    monitoringService?: MonitoringService  ) {    this.cacheService = cacheService || new CacheService<MarkdownProcessingResult>();    this.monitoringService = monitoringService || new MonitoringService();  }   /**   * Processa conteúdo Markdown   */  async processMarkdown(    markdown: string,    options: MarkdownProcessingOptions = {}  ): Promise<MarkdownProcessingResult> {    try {      // Gerar chave de cache      const cacheKey = this.generateCacheKey(markdown, options);             // Verificar cache      const cached = await this.cacheService.get(cacheKey);      if (cached) {        return cached;      }       const startTime = performance.now();       // Separar metadados se necessário      let content = markdown;      let metadata: Record<string, any> | undefined;             if (options.parseMetadata) {        const parsed = this.parseMetadata(markdown);        content = parsed.content;        metadata = parsed.metadata;      }       // Configurar Marked      marked.use({        gfm: options.gfm !== false,        breaks: true,        pedantic: false,        silent: false      });       // Extrair headings, links e code blocks      const headings: Array<{        text: string;        level: number;        id: string;      }> = [];             const links: string[] = [];      const images: string[] = [];      const codeBlocks: Array<{        language: string;        code: string;      }> = [];       // Customizar renderer para extrair informações      const renderer = new marked.Renderer();             // Capturar headings      renderer.heading = (text, level) => {        const slug = text.toLowerCase()          .replace(/[^\w\s-]/g, '')          .replace(/\s+/g, '-');                 const id = `heading-${slug}`;                 headings.push({          text,          level,          id        });                 return `<h${level} id="${id}">${text}</h${level}>`;      };             // Capturar links      renderer.link = (href, title, text) => {        if (href) {          links.push(href);        }        return `<a href="${href}" title="${title || ''}">${text}</a>`;      };             // Capturar imagens      renderer.image = (href, title, text) => {        if (href) {          images.push(href);        }        return `<img src="${href}" alt="${text}" title="${title || ''}">`;      };             // Capturar blocos de código      renderer.code = (code, language) => {        codeBlocks.push({          language: language || 'text',          code        });                 return `<pre><code class="language-${language || 'text'}">${code}</code></pre>`;      };             marked.use({ renderer });       // Converter para HTML      const html = marked.parse(content, {        renderer      }) as string;       // Calcular estatísticas      const wordCount = this.countWords(content);      const readingTime = this.calculateReadingTime(wordCount);       const result: MarkdownProcessingResult = {        html,        metadata,        headings,        wordCount,        readingTime,        links,        images,        codeBlocks      };       // Registrar no cache      await this.cacheService.set(cacheKey, result);       // Registrar métricas      const processingTime = performance.now() - startTime;      this.monitoringService.logEvent({        type: 'markdown_processing',        data: {          processingTime,          wordCount,          headingsCount: headings.length,          linksCount: links.length,          imagesCount: images.length,          codeBlocksCount: codeBlocks.length        }      });       return result;    } catch (error) {      this.monitoringService.logEvent({        type: 'markdown_processing_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error'        }      });      throw error;    }  }   /**   * Extrai metadados frontmatter do Markdown   */  private parseMetadata(markdown: string): {    content: string;    metadata?: Record<string, any>;  } {    // Verificar se tem frontmatter (---...---)    const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;    const match = markdown.match(frontMatterRegex);         if (!match) {      return { content: markdown };    }         try {      // Extrair frontmatter e conteúdo      const [fullMatch, yamlContent] = match;      const content = markdown.slice(fullMatch.length);             // Parsear YAML      const metadata = yaml.load(yamlContent) as Record<string, any>;             return {        content,        metadata      };    } catch (error) {      // Em caso de erro no parsing do YAML, retornar conteúdo original      return { content: markdown };    }  }   /**   * Conta palavras em um texto   */  private countWords(text: string): number {    // Remover caracteres especiais e HTML    const cleanText = text      .replace(/<[^>]*>/g, '') // Remove HTML      .replace(/```[\s\S]*?```/g, '') // Remove blocos de código      .replace(/`[^`]*`/g, '') // Remove código inline      .replace(/\s+/g, ' ') // Normaliza espaços      .trim();         // Dividir por espaços e contar    return cleanText.split(/\s+/).filter(word => word.length > 0).length;  }   /**   * Calcula tempo de leitura em minutos   */  private calculateReadingTime(wordCount: number): number {    // Média de 200 palavras por minuto    const wordsPerMinute = 200;    return Math.ceil(wordCount / wordsPerMinute);  }   /**   * Gera chave de cache   */  private generateCacheKey(    markdown: string,    options: MarkdownProcessingOptions  ): string {    // Hash simples do conteúdo + opções    const optionsString = JSON.stringify(options);    return `md-${markdown.length}-${this.simpleHash(markdown)}-${optionsString}`;  }   /**   * Gera hash simples de uma string   */  private simpleHash(str: string): number {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash; // Convert to 32bit integer    }    return Math.abs(hash);  }   /**   * Extrai sumário (TOC)   */  extractTableOfContents(headings: Array<{    text: string;    level: number;    id: string;  }>): string {    if (headings.length === 0) {      return '';    }         let toc = '<ul class="toc">\n';    let currentLevel = 1;    const minLevel = Math.min(...headings.map(h => h.level));         headings.forEach(heading => {      const relativeLevel = heading.level - minLevel;             // Abrir listas aninhadas      while (currentLevel < relativeLevel) {        toc += '<ul>\n';        currentLevel++;      }             // Fechar listas aninhadas      while (currentLevel > relativeLevel) {        toc += '</ul>\n';        currentLevel--;      }             // Adicionar item      toc += `<li><a href="#${heading.id}">${heading.text}</a></li>\n`;    });         // Fechar listas restantes    while (currentLevel > 0) {      toc += '</ul>\n';      currentLevel--;    }         return toc;  }   /**   * Extrai primeira imagem como thumbnail   */  extractThumbnail(images: string[]): string | null {    return images.length > 0 ? images[0] : null;  }   /**   * Extrai resumo curto (primeira frase ou parágrafo)   */  extractSummary(markdown: string, maxLength: number = 150): string {    // Remover HTML, código e formatação    const plainText = markdown      .replace(/<[^>]*>/g, '')      .replace(/```[\s\S]*?```/g, '')      .replace(/`[^`]*`/g, '')      .replace(/#+\s+(.*)\n/g, '$1. ')      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')      .replace(/\*\*([^*]+)\*\*/g, '$1')      .replace(/\*([^*]+)\*/g, '$1')      .replace(/\n\s*\n/g, '. ')      .replace(/\s+/g, ' ')      .trim();         // Pegar primeiro parágrafo ou sentença    const firstSentence = plainText.split(/\.\s+/)[0] + '.';         // Truncar se necessário    return firstSentence.length > maxLength      ? firstSentence.substring(0, maxLength - 3) + '...'      : firstSentence;  } }``

### src/components/llm/provider-form/ParametersSection.tsx

``import React from "react"; import { Label } from "../../ui/label"; import { Input } from "../../ui/input"; import { Slider } from "../../ui/slider"; import { LLMProvider } from "@/types/llm"; interface ParametersSectionProps {   provider: LLMProvider;  onChange: (field: keyof LLMProvider, value: any) => void; } export function ParametersSection({ provider, onChange }: ParametersSectionProps) {   const handleParameterChange = (    parameter: keyof LLMProvider["parameters"],    value: number  ) => {    onChange("parameters", {      ...provider.parameters,      [parameter]: value,    });  };   return (    <div className="space-y-4">      <h3 className="text-sm font-semibold">Parâmetros Padrão</h3>       <div className="space-y-6">        <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`temperature-${provider.id}`}>              Temperatura ({provider.parameters?.defaultTemperature?.toFixed(1) || "0.7"})            </Label>            <span className="text-xs text-muted-foreground">              0.0 = Determinístico, 1.0 = Criativo            </span>          </div>          <Slider            id={`temperature-${provider.id}`}            min={0}            max={1}            step={0.1}            value={[provider.parameters?.defaultTemperature || 0.7]}            onValueChange={([value]) =>              handleParameterChange("defaultTemperature", value)            }          />        </div>         <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`max-tokens-${provider.id}`}>              Máximo de Tokens ({provider.parameters?.defaultMaxTokens || "1000"})            </Label>            <span className="text-xs text-muted-foreground">              Limite para resposta do modelo            </span>          </div>          <Input            id={`max-tokens-${provider.id}`}            type="number"            min={1}            max={4096}            value={provider.parameters?.defaultMaxTokens || 1000}            onChange={(e) =>              handleParameterChange(                "defaultMaxTokens",                parseInt(e.target.value, 10)              )            }          />        </div>         <div className="space-y-2">          <div className="flex justify-between items-center">            <Label htmlFor={`top-p-${provider.id}`}>              Top P ({provider.parameters?.defaultTopP?.toFixed(1) || "1.0"})            </Label>            <span className="text-xs text-muted-foreground">              Amostragem por núcleo            </span>          </div>          <Slider            id={`top-p-${provider.id}`}            min={0}            max={1}            step={0.1}            value={[provider.parameters?.defaultTopP || 1.0]}            onValueChange={([value]) =>              handleParameterChange("defaultTopP", value)            }          />        </div>      </div>    </div>  ); }``

### src/components/llm/provider-form/CapabilitiesSection.tsx

``import React from "react"; import { Checkbox } from "../../ui/checkbox"; import { Label } from "../../ui/label"; import { LLMProvider } from "@/types/llm"; interface CapabilitiesSectionProps {   provider: LLMProvider;  onChange: (field: keyof LLMProvider, value: any) => void; } export function CapabilitiesSection({ provider, onChange }: CapabilitiesSectionProps) {   const handleCapabilityChange = (    capability: keyof LLMProvider["capabilities"],    checked: boolean  ) => {    onChange("capabilities", {      ...provider.capabilities,      [capability]: checked,    });  };   return (    <div className="space-y-4">      <h3 className="text-sm font-semibold">Capacidades</h3>       <div className="space-y-2">        <div className="flex items-center space-x-2">          <Checkbox            id={`text-completion-${provider.id}`}            checked={provider.capabilities?.textCompletion}            onCheckedChange={(checked) =>              handleCapabilityChange("textCompletion", !!checked)            }          />          <Label            htmlFor={`text-completion-${provider.id}`}            className="text-sm font-normal"          >            Completamento de Texto          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`chat-completion-${provider.id}`}            checked={provider.capabilities?.chatCompletion}            onCheckedChange={(checked) =>              handleCapabilityChange("chatCompletion", !!checked)            }          />          <Label            htmlFor={`chat-completion-${provider.id}`}            className="text-sm font-normal"          >            Chat Completamento          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`embedding-${provider.id}`}            checked={provider.capabilities?.embedding}            onCheckedChange={(checked) =>              handleCapabilityChange("embedding", !!checked)            }          />          <Label            htmlFor={`embedding-${provider.id}`}            className="text-sm font-normal"          >            Embeddings          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`image-generation-${provider.id}`}            checked={provider.capabilities?.imageGeneration}            onCheckedChange={(checked) =>              handleCapabilityChange("imageGeneration", !!checked)            }          />          <Label            htmlFor={`image-generation-${provider.id}`}            className="text-sm font-normal"          >            Geração de Imagem          </Label>        </div>         <div className="flex items-center space-x-2">          <Checkbox            id={`audio-transcription-${provider.id}`}            checked={provider.capabilities?.audioTranscription}            onCheckedChange={(checked) =>              handleCapabilityChange("audioTranscription", !!checked)            }          />          <Label            htmlFor={`audio-transcription-${provider.id}`}            className="text-sm font-normal"          >            Transcrição de Áudio          </Label>        </div>      </div>    </div>  ); }``

### src/components/llm/monitoring/PerformanceChart.tsx

``import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { PieChart, Pie, Cell, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface PerformanceChartProps {   providerUsageData: Array<{    name: string;    requests: number;    tokens: number;    successRate: number;  }>; } export function PerformanceChart({ providerUsageData }: PerformanceChartProps) {   const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];     return (    <Card>      <CardHeader>        <CardTitle>Taxa de Sucesso</CardTitle>        <CardDescription>          Comparativo de desempenho entre provedores        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <PieChart>              <Pie                data={providerUsageData}                cx="50%"                cy="50%"                labelLine={false}                label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}                outerRadius={80}                fill="#8884d8"                dataKey="successRate"              >                {providerUsageData.map((entry, index) => (                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />                ))}              </Pie>              <Tooltip />              <Legend />            </PieChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }``

### src/components/llm/monitoring/TimelineChart.tsx

``import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface TimelineChartProps {   timelineData: Array<{    timestamp: string;    count: number;  }>; } export function TimelineChart({ timelineData }: TimelineChartProps) {   return (    <Card>      <CardHeader>        <CardTitle>Timeline de Requisições</CardTitle>        <CardDescription>          Histórico de requisições ao longo do tempo        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <LineChart              data={timelineData}              margin={{ top: 5, right: 30, left: 20, bottom: 5 }}            >              <CartesianGrid strokeDasharray="3 3" />              <XAxis                dataKey="timestamp"                tickFormatter={(value) => {                  const date = new Date(value);                  return `${date.getDate()}/${date.getMonth() + 1}`;                }}              />              <YAxis />              <Tooltip                labelFormatter={(value) => {                  const date = new Date(value);                  return date.toLocaleDateString();                }}              />              <Legend />              <Line                type="monotone"                dataKey="count"                name="Requisições"                stroke="#8884d8"                activeDot={{ r: 8 }}              />            </LineChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }``

### src/components/llm/monitoring/UsageChart.tsx

`import React from "react"; import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "../../ui/card"; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"; interface UsageChartProps {   providerUsageData: Array<{    name: string;    requests: number;    tokens: number;    successRate: number;  }>; } export function UsageChart({ providerUsageData }: UsageChartProps) {   return (    <Card>      <CardHeader>        <CardTitle>Uso por Provedor</CardTitle>        <CardDescription>          Comparativo de uso entre os diferentes provedores de LLM        </CardDescription>      </CardHeader>      <CardContent>        <div className="h-80">          <ResponsiveContainer width="100%" height="100%">            <BarChart              data={providerUsageData}              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}            >              <CartesianGrid strokeDasharray="3 3" />              <XAxis dataKey="name" />              <YAxis />              <Tooltip />              <Legend />              <Bar dataKey="requests" name="Requisições" fill="#8884d8" />              <Bar dataKey="tokens" name="Tokens (x100)" fill="#82ca9d" />            </BarChart>          </ResponsiveContainer>        </div>      </CardContent>    </Card>  ); }`

### src/hooks/llm/useCompletions.ts

`import { useState, useCallback } from 'react'; import { CompletionOptions, ChatMessage, ChatResponse } from '../../types/llm'; import { llmServiceInstance } from './llmServiceInstance'; export const useCompletions = () => {   const [isLoading, setIsLoading] = useState(false);  const [error, setError] = useState<string | null>(null);   const generateCompletion = useCallback(async (    prompt: string,    options?: CompletionOptions  ): Promise<string> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateCompletion(prompt, options);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   const generateChat = useCallback(async (    messages: ChatMessage[],    options?: CompletionOptions  ): Promise<ChatResponse> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateChat(messages, options);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   const generateEmbedding = useCallback(async (    text: string  ): Promise<number[]> => {    setIsLoading(true);    setError(null);         try {      const result = await llmServiceInstance.generateEmbedding(text);      return result;    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');      throw err;    } finally {      setIsLoading(false);    }  }, []);   return {    generateCompletion,    generateChat,    generateEmbedding,    isLoading,    error  }; };`

### src/hooks/useLLM.ts

`import { useState, useEffect, useCallback } from 'react'; import { llmServiceInstance } from './llm/llmServiceInstance'; import { LLMProvider, LLMPipeline } from '@/types/llm'; export function useLLM() {   const [providers, setProviders] = useState<LLMProvider[]>([]);  const [pipelines, setPipelines] = useState<LLMPipeline[]>([]);  const [defaultProvider, setDefaultProvider] = useState<string>('');  const [isLoading, setIsLoading] = useState(true);     useEffect(() => {    // Carregar provedores ao inicializar    const loadProviders = () => {      const allProviders = llmServiceInstance.listProviders();      const defaultProviderID = llmServiceInstance.getDefaultProvider();      const allPipelines = llmServiceInstance.listPipelines();             setProviders(allProviders);      setDefaultProvider(defaultProviderID);      setPipelines(allPipelines);      setIsLoading(false);    };         loadProviders();  }, []);     // Gerenciamento de provedores  const addProvider = useCallback((provider: LLMProvider) => {    llmServiceInstance.addProvider(provider);    setProviders(llmServiceInstance.listProviders());  }, []);     const updateProvider = useCallback((providerId: string, updates: Partial<LLMProvider>) => {    llmServiceInstance.updateProvider(providerId, updates);    setProviders(llmServiceInstance.listProviders());  }, []);     const removeProvider = useCallback((providerId: string) => {    llmServiceInstance.removeProvider(providerId);    setProviders(llmServiceInstance.listProviders());  }, []);     const changeDefaultProvider = useCallback((providerId: string) => {    llmServiceInstance.setDefaultProvider(providerId);    setDefaultProvider(providerId);  }, []);     // Gerenciamento de pipelines  const addPipeline = useCallback((pipeline: LLMPipeline) => {    llmServiceInstance.addPipeline(pipeline);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const updatePipeline = useCallback((pipelineId: string, updates: Partial<LLMPipeline>) => {    llmServiceInstance.updatePipeline(pipelineId, updates);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const removePipeline = useCallback((pipelineId: string) => {    llmServiceInstance.removePipeline(pipelineId);    setPipelines(llmServiceInstance.listPipelines());  }, []);     const executePipeline = useCallback((pipelineId: string, input: string) => {    return llmServiceInstance.executePipeline(pipelineId, input);  }, []);   // Métodos de geração  const generateCompletion = useCallback((prompt: string, options?: any) => {    return llmServiceInstance.generateCompletion(prompt, options);  }, []);     const generateChat = useCallback((messages: any[], options?: any) => {    return llmServiceInstance.generateChat(messages, options);  }, []);     const generateEmbedding = useCallback((text: string) => {    return llmServiceInstance.generateEmbedding(text);  }, []);   return {    // Estado    providers,    pipelines,    defaultProvider,    isLoading,         // Gerenciamento de provedores    addProvider,    updateProvider,    removeProvider,    changeDefaultProvider,         // Gerenciamento de pipelines    addPipeline,    updatePipeline,    removePipeline,    executePipeline,         // Métodos de geração    generateCompletion,    generateChat,    generateEmbedding  }; }`

### src/hooks/useDocumentProcessor.ts

``import { useState, useCallback } from 'react'; import { useCompletions } from './llm/useCompletions'; import { ProcessedDocument } from '@/types/knowledge'; export const useDocumentProcessor = () => {   const [content, setContent] = useState<string>('');  const [isProcessing, setIsProcessing] = useState<boolean>(false);  const [processingProgress, setProcessingProgress] = useState<number>(0);  const [result, setResult] = useState<ProcessedDocument | null>(null);  const [viewMode, setViewMode] = useState<'input' | 'output'>('input');     const { generateCompletion } = useCompletions();   const processStep = async (step: string, stepNumber: number, totalSteps: number) => {    setProcessingProgress(Math.floor((stepNumber / totalSteps) * 100));         // Lógica específica para cada passo    switch (step) {      case 'analysis':        return analyzeDocument(content);      case 'structure':        return extractStructure(content);      case 'validation':        return validateDocument(content);      case 'suggestions':        return generateSuggestions(content);      default:        return null;    }  };   const handleProcess = useCallback(async () => {    if (!content.trim()) return;         setIsProcessing(true);    setProcessingProgress(0);    setResult(null);         try {      // Definição dos passos      const steps = ['analysis', 'structure', 'validation', 'suggestions'];      const totalSteps = steps.length;             // Processar cada passo sequencialmente      const processedContent = { content, title: getDocumentTitle(content) };      const results: any = {};             for (let i = 0; i < steps.length; i++) {        const stepResult = await processStep(steps[i], i + 1, totalSteps);        results[steps[i]] = stepResult;      }             // Compilar resultado final      const processedDocument: ProcessedDocument = {        id: generateId(),        title: processedContent.title,        content: processedContent.content,        metadata: {          processedAt: new Date().toISOString(),          wordCount: countWords(content),          readingTime: calculateReadingTime(content),          category: detectCategory(content),          ...results.analysis?.metadata        },        structure: results.structure,        analysis: results.analysis,        validationResult: results.validation,        suggestions: results.suggestions,        processingDate: new Date().toISOString(),        status: 'processed'      };             setResult(processedDocument);      setProcessingProgress(100);      setViewMode('output');    } catch (error) {      console.error('Erro ao processar documento:', error);    } finally {      setIsProcessing(false);    }  }, [content, generateCompletion]);   const resetProcessor = useCallback(() => {    setContent('');    setResult(null);    setProcessingProgress(0);    setViewMode('input');  }, []);   // Funções auxiliares internas  const analyzeDocument = async (text: string) => {    const prompt = `      Analise o seguinte documento Markdown e extraia informações importantes:      1. Tópicos principais      2. Conceitos-chave      3. Complexidade (baixa, média, alta)      4. Palavras-chave      5. Categoria do documento             Formate a resposta como um JSON com as seguintes chaves:      {        "topics": ["Tópico 1", "Tópico 2", ...],        "concepts": ["Conceito 1", "Conceito 2", ...],        "complexity": "baixa|média|alta",        "keywords": ["palavra1", "palavra2", ...],        "category": "categoria do documento",        "summary": "Breve resumo do conteúdo (máx. 100 palavras)"      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de análise');    } catch (error) {      console.error('Erro na análise:', error);      return {        topics: [],        concepts: [],        complexity: 'média',        keywords: [],        category: 'Não determinado',        summary: 'Não foi possível gerar um resumo.'      };    }  };   const extractStructure = async (text: string) => {    const prompt = `      Analise o seguinte documento Markdown e extraia sua estrutura:      1. Headings (h1, h2, h3, etc.) com hierarquia      2. Principais seções      3. Elementos visuais (imagens, tabelas, etc.)      4. Listas e enumerações             Formate a resposta como um JSON com as seguintes chaves:      {        "headings": [          {"level": 1, "text": "Título principal", "children": [            {"level": 2, "text": "Subtítulo", "children": []}          ]}        ],        "sections": ["Seção 1", "Seção 2", ...],        "visualElements": ["Elemento 1", "Elemento 2", ...],        "lists": ["Lista 1", "Lista 2", ...]      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de estrutura');    } catch (error) {      console.error('Erro na extração de estrutura:', error);      return {        headings: [],        sections: [],        visualElements: [],        lists: []      };    }  };   const validateDocument = async (text: string) => {    const prompt = `      Valide o seguinte documento Markdown e identifique possíveis problemas:      1. Erros gramaticais ou ortográficos      2. Inconsistências de estilo ou formato      3. Links quebrados (URLs malformadas)      4. Problemas de organização ou estrutura             Formate a resposta como um JSON com as seguintes chaves:      {        "issues": [          {"type": "grammar|spelling|style|link|structure", "description": "Descrição do problema", "severity": "high|medium|low", "location": "Onde ocorre"}        ],        "score": X.X (pontuação de 0.0 a 10.0)      }             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de validação');    } catch (error) {      console.error('Erro na validação:', error);      return {        issues: [],        score: 5.0      };    }  };   const generateSuggestions = async (text: string) => {    const prompt = `      Com base no seguinte documento Markdown, forneça sugestões para melhorá-lo:      1. Clareza e legibilidade      2. Estrutura e organização      3. Completude do conteúdo      4. Formatação e apresentação             Formate a resposta como uma lista de sugestões no formato JSON:      [        {"title": "Título da sugestão", "description": "Descrição detalhada"}      ]             Documento:      ${text.substring(0, 3000)}...    `;         try {      const result = await generateCompletion(prompt, {        temperature: 0.5,        maxTokens: 1000      });             // Extrair JSON da resposta      const jsonMatch = result.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }             throw new Error('Formato inválido na resposta de sugestões');    } catch (error) {      console.error('Erro ao gerar sugestões:', error);      return [];    }  };   const getDocumentTitle = (text: string): string => {    // Buscar pelo primeiro heading (# Título)    const headingMatch = text.match(/^#\s+(.+)$/m);    if (headingMatch && headingMatch[1]) {      return headingMatch[1].trim();    }         // Se não encontrar, usar as primeiras palavras    const firstLine = text.split('\n')[0];    if (firstLine && firstLine.length > 0) {      return firstLine.length > 50        ? firstLine.substring(0, 47) + '...'        : firstLine;    }         return 'Documento sem título';  };   const generateId = (): string => {    return 'doc-' + Math.random().toString(36).substring(2, 9);  };   const countWords = (text: string): number => {    return text.split(/\s+/).filter(word => word.length > 0).length;  };   const calculateReadingTime = (text: string): number => {    const words = countWords(text);    // Tempo médio de leitura: 200 palavras por minuto    return Math.ceil(words / 200);  };   const detectCategory = (text: string): string => {    // Implementação simples baseada em palavras-chave    if (text.match(/\b(código|function|class|import|export|const|var|let)\b/i)) {      return 'Programação';    }         if (text.match(/\b(api|rest|http|endpoint|request|response)\b/i)) {      return 'API';    }         if (text.match(/\b(design|ui|ux|interface|usuário|experiência)\b/i)) {      return 'Design';    }         if (text.match(/\b(arquitetura|sistema|componente|módulo|serviço)\b/i)) {      return 'Arquitetura';    }         return 'Documentação Geral';  };   return {    content,    setContent,    isProcessing,    processingProgress,    result,    viewMode,    setViewMode,    handleProcess,    resetProcessor  }; };``

Ainda há vários outros módulos importantes a serem detalhados. Posso continuar descrevendo mais componentes e serviços da aplicação em uma nova conversa, continuando de onde paramos.

CONTINUE usando o maximo de caracteres que pode usar por conversa par incluir o maximo de modulos , comece DE ONDE PAROU AGORA E DESCREVA ABSOLUTAMENTE TODOS OS MODULOS COMO FICARAM OS CODIGOS FINAIS DA Estrutura Completa da Aplicação Estrutura de Diretórios e Arquivos COMECE DE ONDE PAROU E PROSSIGA, NÃO OMITA E NEM RESUMA ESCREVA NA INTEGRA, QUANDO CHEGAR AO FIM SE FALTAREM MODULOS ME AVIZE QUE POssO PARA CONTINUAR EM UMA NOVA CONVERSA DE ONDE PAROU e referencie em numeros quantos modulos faltam ainda

![lovable logo](https://lovable.dev/img/lovable-logo.svg)Lovable

14:15 on Mar 11, 2025

Continuarei descrevendo os módulos restantes da aplicação, seguindo de onde paramos anteriormente. Vamos prosseguir com mais componentes e serviços fundamentais.

### src/services/document/DocumentProcessor.ts

``import { Document, ProcessedDocument } from '@/types/knowledge'; import { OpenAIService } from '../ai/OpenAIService'; import { DocumentStructureService } from './DocumentStructureService'; import { DocumentValidationService } from './DocumentValidationService'; import { SuggestionService } from './SuggestionService'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class DocumentProcessor {   private openAIService: OpenAIService;  private structureService: DocumentStructureService;  private validationService: DocumentValidationService;  private suggestionService: SuggestionService;  private cacheService: CacheService<ProcessedDocument>;  private monitoringService: MonitoringService;   constructor(    openAIKey: string,    cacheService?: CacheService<ProcessedDocument>,    monitoringService?: MonitoringService  ) {    this.openAIService = OpenAIService.getInstance(openAIKey);    this.structureService = new DocumentStructureService(this.openAIService);    this.validationService = new DocumentValidationService(this.openAIService);    this.suggestionService = new SuggestionService(this.openAIService);    this.cacheService = cacheService || new CacheService<ProcessedDocument>();    this.monitoringService = monitoringService || MonitoringService.getInstance();  }   /**   * Processa um documento   */  async processDocument(document: Document): Promise<ProcessedDocument> {    try {      const startTime = Date.now();      this.logEvent('document_processing_start', { documentId: document.id });       // Verificar cache      const cacheKey = this.generateCacheKey(document);      const cached = await this.cacheService.get(cacheKey);      if (cached) {        this.logEvent('document_processing_cache_hit', { documentId: document.id });        return cached;      }       // Processar documento      const processedDocument = await this.processDocumentSteps(document);       // Armazenar em cache      await this.cacheService.set(cacheKey, processedDocument);       // Registrar métricas      const processingTime = Date.now() - startTime;      this.logEvent('document_processing_complete', {        documentId: document.id,        processingTime,        wordCount: this.countWords(document.content),        status: processedDocument.status      });       return processedDocument;    } catch (error) {      this.logEvent('document_processing_error', {        documentId: document.id,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Processa um documento em etapas   */  private async processDocumentSteps(document: Document): Promise<ProcessedDocument> {    // Etapa 1: Análise    const analysis = await this.analyzeDocument(document);     // Etapa 2: Estrutura    const structure = await this.structureService.extractStructure(document.content);     // Etapa 3: Validação    const validationResult = await this.validationService.validateDocument(document.content);     // Etapa 4: Sugestões    const suggestions = await this.suggestionService.generateSuggestions(document.content);     // Compilar resultado    return {      id: document.id || this.generateId(),      title: document.title || this.extractTitle(document.content),      content: document.content,      metadata: {        processedAt: new Date().toISOString(),        wordCount: this.countWords(document.content),        readingTime: this.calculateReadingTime(document.content),        category: analysis.category || 'Uncategorized',        ...analysis.metadata      },      analysis,      structure,      validationResult,      suggestions,      processingDate: new Date().toISOString(),      status: 'processed'    };  }   /**   * Analisa o documento para extrair informações   */  private async analyzeDocument(document: Document): Promise<{    topics: string[];    concepts: Array<{ name: string; importance: number }>;    complexity: string;    keywords: string[];    category: string;    summary: string;    metadata?: Record<string, any>;  }> {    try {      const prompt = `        Analise o seguinte documento e extraia informações importantes:        1. Tópicos principais (3-7 tópicos)        2. Conceitos-chave (3-10 conceitos com nível de importância de 0.0 a 1.0)        3. Complexidade (baixa, média, alta)        4. Palavras-chave (5-15 palavras)        5. Categoria do documento        6. Resumo (max. 150 palavras)                 Formate a resposta como um JSON:        {          "topics": ["Tópico 1", "Tópico 2", ...],          "concepts": [            {"name": "Conceito 1", "importance": 0.9},            {"name": "Conceito 2", "importance": 0.7},            ...          ],          "complexity": "baixa|média|alta",          "keywords": ["palavra1", "palavra2", ...],          "category": "categoria do documento",          "summary": "Resumo do conteúdo..."        }                 Documento:        ${document.content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-4-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para análise');    } catch (error) {      console.error('Erro ao analisar documento:', error);      return {        topics: [],        concepts: [],        complexity: 'média',        keywords: [],        category: 'Não determinado',        summary: 'Não foi possível gerar um resumo.'      };    }  }   /**   * Extrai título do conteúdo   */  private extractTitle(content: string): string {    // Buscar pelo primeiro heading (# Título)    const headingMatch = content.match(/^#\s+(.+)$/m);    if (headingMatch && headingMatch[1]) {      return headingMatch[1].trim();    }     // Se não encontrar, usar as primeiras palavras    const firstLine = content.split('\n')[0];    if (firstLine && firstLine.length > 0) {      return firstLine.length > 50        ? firstLine.substring(0, 47) + '...'        : firstLine;    }     return 'Documento sem título';  }   /**   * Gera um ID para o documento   */  private generateId(): string {    return 'doc-' + Math.random().toString(36).substring(2, 9);  }   /**   * Conta palavras em um texto   */  private countWords(text: string): number {    return text.split(/\s+/).filter(word => word.length > 0).length;  }   /**   * Calcula tempo de leitura em minutos   */  private calculateReadingTime(text: string): number {    const words = this.countWords(text);    // Tempo médio de leitura: 200 palavras por minuto    return Math.ceil(words / 200);  }   /**   * Gera chave de cache   */  private generateCacheKey(document: Document): string {    return `doc-${document.id}-${this.simpleHash(document.content)}`;  }   /**   * Gera hash simples   */  private simpleHash(str: string): number {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash; // Convert to 32bit integer    }    return Math.abs(hash);  }   /**   * Registra evento   */  private logEvent(type: string, data: any): void {    this.monitoringService.logEvent({      type: `document_processor:${type}`,      data    });  } }``

### src/services/document/DocumentStructureService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface DocumentStructure {   headings: Array<{    level: number;    text: string;    children?: Array<{      level: number;      text: string;      children?: any[];    }>;  }>;  sections: string[];  visualElements: string[];  lists: string[]; } export class DocumentStructureService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Extrai estrutura de um documento   */  async extractStructure(content: string): Promise<DocumentStructure> {    try {      const prompt = `        Analise o seguinte documento e extraia sua estrutura:        1. Headings (h1, h2, h3, etc.) com hierarquia        2. Principais seções        3. Elementos visuais (imagens, tabelas, etc.)        4. Listas e enumerações                 Formate a resposta como um JSON:        {          "headings": [            {"level": 1, "text": "Título principal", "children": [              {"level": 2, "text": "Subtítulo", "children": []}            ]}          ],          "sections": ["Seção 1", "Seção 2", ...],          "visualElements": ["Elemento 1", "Elemento 2", ...],          "lists": ["Lista 1", "Lista 2", ...]        }                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para estrutura');    } catch (error) {      console.error('Erro ao extrair estrutura:', error);      return {        headings: [],        sections: [],        visualElements: [],        lists: []      };    }  }   /**   * Extrai estrutura de headings usando expressões regulares   */  extractHeadingsWithRegex(content: string): Array<{    level: number;    text: string;  }> {    const headings: Array<{      level: number;      text: string;    }> = [];         // Expressão regular para headings Markdown    const headingRegex = /^(#{1,6})\s+(.+)$/gm;    let match;         while ((match = headingRegex.exec(content)) !== null) {      const level = match[1].length;      const text = match[2].trim();             headings.push({        level,        text      });    }         return headings;  }   /**   * Constrói hierarquia de headings   */  buildHeadingHierarchy(headings: Array<{    level: number;    text: string;  }>): Array<{    level: number;    text: string;    children: any[];  }> {    if (headings.length === 0) {      return [];    }         const result: Array<{      level: number;      text: string;      children: any[];    }> = [];    let currentLevel1: any = null;    let currentLevel2: any = null;    let currentLevel3: any = null;         for (const heading of headings) {      const node = {        level: heading.level,        text: heading.text,        children: []      };             switch (heading.level) {        case 1:          currentLevel1 = node;          result.push(currentLevel1);          currentLevel2 = null;          currentLevel3 = null;          break;        case 2:          currentLevel2 = node;          if (currentLevel1) {            currentLevel1.children.push(currentLevel2);          } else {            result.push(currentLevel2);          }          currentLevel3 = null;          break;        case 3:          currentLevel3 = node;          if (currentLevel2) {            currentLevel2.children.push(currentLevel3);          } else if (currentLevel1) {            currentLevel1.children.push(currentLevel3);          } else {            result.push(currentLevel3);          }          break;        default:          // Níveis mais profundos          if (currentLevel3) {            currentLevel3.children.push(node);          } else if (currentLevel2) {            currentLevel2.children.push(node);          } else if (currentLevel1) {            currentLevel1.children.push(node);          } else {            result.push(node);          }      }    }         return result;  }   /**   * Extrai listas usando expressões regulares   */  extractListsWithRegex(content: string): string[] {    const lists: string[] = [];         // Expressão regular para listas não ordenadas    const ulRegex = /^(\s*[-*+]\s+.+\n)+/gm;    let ulMatch;         while ((ulMatch = ulRegex.exec(content)) !== null) {      lists.push(ulMatch[0].trim());    }         // Expressão regular para listas ordenadas    const olRegex = /^(\s*\d+\.\s+.+\n)+/gm;    let olMatch;         while ((olMatch = olRegex.exec(content)) !== null) {      lists.push(olMatch[0].trim());    }         return lists;  }   /**   * Extrai elementos visuais usando expressões regulares   */  extractVisualElementsWithRegex(content: string): string[] {    const visualElements: string[] = [];         // Expressão regular para imagens    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/gm;    let imgMatch;         while ((imgMatch = imageRegex.exec(content)) !== null) {      const altText = imgMatch[1];      const url = imgMatch[2];      visualElements.push(`Imagem: ${altText || 'Sem descrição'} (${url})`);    }         // Expressão regular para tabelas simplificadas    const tableRegex = /^\|(.+\|)+\n\|(\s*[-:]+\s*\|)+\n(\|.+\|(\n|$))+/gm;    let tableMatch;         while ((tableMatch = tableRegex.exec(content)) !== null) {      visualElements.push(`Tabela: ${tableMatch[0].split('\n')[0]}`);    }         return visualElements;  }   /**   * Gera tabela de conteúdo (TOC)   */  generateTableOfContents(headings: Array<{    level: number;    text: string;  }>): string {    if (headings.length === 0) {      return '';    }         let toc = '';    let previousLevel = 0;         for (const heading of headings) {      const slug = heading.text.toLowerCase()        .replace(/[^\w\s-]/g, '')        .replace(/\s+/g, '-');             // Ajustar indentação      if (heading.level > previousLevel) {        for (let i = 0; i < heading.level - previousLevel; i++) {          toc += '\n';        }      }             // Adicionar item      toc += '  '.repeat(heading.level - 1);      toc += `- [${heading.text}](#${slug})\n`;             previousLevel = heading.level;    }         return toc;  } }``

### src/services/document/DocumentValidationService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface ValidationResult {   issues: Array<{    type: 'grammar' | 'spelling' | 'style' | 'link' | 'structure';    description: string;    severity: 'high' | 'medium' | 'low';    location: string;  }>;  score: number; } export class DocumentValidationService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Valida um documento   */  async validateDocument(content: string): Promise<ValidationResult> {    try {      const prompt = `        Valide o seguinte documento e identifique possíveis problemas:        1. Erros gramaticais ou ortográficos        2. Inconsistências de estilo ou formato        3. Links quebrados (URLs malformadas)        4. Problemas de organização ou estrutura                 Formate a resposta como um JSON:        {          "issues": [            {"type": "grammar|spelling|style|link|structure", "description": "Descrição do problema", "severity": "high|medium|low", "location": "Onde ocorre"}          ],          "score": X.X (pontuação de 0.0 a 10.0)        }                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.3,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para validação');    } catch (error) {      console.error('Erro ao validar documento:', error);      return {        issues: [],        score: 5.0      };    }  }   /**   * Realiza verificações básicas no documento   */  performBasicChecks(content: string): ValidationResult {    const issues: Array<{      type: 'grammar' | 'spelling' | 'style' | 'link' | 'structure';      description: string;      severity: 'high' | 'medium' | 'low';      location: string;    }> = [];         // Verificar links quebrados    const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;    let match;         while ((match = linkRegex.exec(content)) !== null) {      const linkText = match[1];      const url = match[2];             if (!this.isValidUrl(url)) {        issues.push({          type: 'link',          description: `Link potencialmente malformado: "${url}"`,          severity: 'medium',          location: `Link: ${linkText}`        });      }    }         // Verificar headings vazios    const emptyHeadingRegex = /^#+\s*$/gm;         while ((match = emptyHeadingRegex.exec(content)) !== null) {      issues.push({        type: 'structure',        description: 'Heading vazio',        severity: 'medium',        location: `Linha: ${this.getLineNumber(content, match.index)}`      });    }         // Verificar parágrafos muito longos    const paragraphs = content.split(/\n\s*\n/);    for (let i = 0; i < paragraphs.length; i++) {      const paragraph = paragraphs[i];      if (paragraph.length > 500) {        issues.push({          type: 'style',          description: 'Parágrafo muito longo (>500 caracteres)',          severity: 'low',          location: `Parágrafo ${i + 1}`        });      }    }         // Calcular pontuação    const score = 10 - (issues.length * 0.5);    const normalizedScore = Math.max(0, Math.min(10, score));         return {      issues,      score: normalizedScore    };  }   /**   * Verifica se uma URL é válida   */  private isValidUrl(url: string): boolean {    try {      new URL(url);      return true;    } catch (e) {      // Aceitar links relativos      return /^[/#][a-zA-Z0-9-_/]*$/.test(url);    }  }   /**   * Obtém número da linha para um índice   */  private getLineNumber(content: string, index: number): number {    const lines = content.slice(0, index).split('\n');    return lines.length;  }   /**   * Detecta inconsistências de formatação   */  detectFormattingInconsistencies(content: string): Array<{    type: 'style';    description: string;    severity: 'low';    location: string;  }> {    const issues: Array<{      type: 'style';      description: string;      severity: 'low';      location: string;    }> = [];         // Verificar inconsistências em listas    const ulFormats = new Set();    const ulItems = content.match(/^(\s*)[-*+]\s+.+$/gm);         if (ulItems) {      ulItems.forEach(item => {        const marker = item.match(/^(\s*)([*\-+])/)?.[2];        if (marker) {          ulFormats.add(marker);        }      });             if (ulFormats.size > 1) {        issues.push({          type: 'style',          description: `Inconsistência nos marcadores de lista não ordenada: ${Array.from(ulFormats).join(', ')}`,          severity: 'low',          location: 'Listas não ordenadas'        });      }    }         // Verificar inconsistências em headings    const headingStyles = new Set();    const headings = content.match(/^(#+)\s+.+$/gm);         if (headings) {      headings.forEach(heading => {        const hasSpace = /^#+\s+/.test(heading);        headingStyles.add(hasSpace ? 'com espaço' : 'sem espaço');      });             if (headingStyles.size > 1) {        issues.push({          type: 'style',          description: 'Inconsistência na formatação de headings (com/sem espaço após #)',          severity: 'low',          location: 'Headings'        });      }    }         return issues;  } }``

### src/services/document/SuggestionService.ts

``import { OpenAIService } from '../ai/OpenAIService'; export interface Suggestion {   title: string;  description: string; } export class SuggestionService {   private openAIService: OpenAIService;   constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }   /**   * Gera sugestões para um documento   */  async generateSuggestions(content: string): Promise<Suggestion[]> {    try {      const prompt = `        Com base no seguinte documento, forneça sugestões para melhorá-lo:        1. Clareza e legibilidade        2. Estrutura e organização        3. Completude do conteúdo        4. Formatação e apresentação                 Formate a resposta como uma lista de sugestões no formato JSON:        [          {"title": "Título da sugestão", "description": "Descrição detalhada"}        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.5,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para sugestões');    } catch (error) {      console.error('Erro ao gerar sugestões:', error);      return [];    }  }   /**   * Gera exemplos de melhoria para um documento   */  async generateExamples(content: string): Promise<Array<{    original: string;    improved: string;    explanation: string;  }>> {    try {      const prompt = `        Com base no seguinte documento, forneça 3 exemplos de melhorias específicas:                 Formate a resposta como JSON:        [          {            "original": "Trecho original",            "improved": "Versão melhorada",            "explanation": "Explicação da melhoria"          }        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-4-turbo',        temperature: 0.5,        maxTokens: 1000      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para exemplos');    } catch (error) {      console.error('Erro ao gerar exemplos:', error);      return [];    }  }   /**   * Gera sugestões específicas para um tipo de problema   */  async generateSpecificSuggestions(    content: string,    aspect: 'clarity' | 'structure' | 'completeness' | 'formatting'  ): Promise<Suggestion[]> {    try {      let aspectPrompt = '';             switch (aspect) {        case 'clarity':          aspectPrompt = 'melhorar a clareza e legibilidade';          break;        case 'structure':          aspectPrompt = 'aprimorar a estrutura e organização';          break;        case 'completeness':          aspectPrompt = 'aumentar a completude do conteúdo';          break;        case 'formatting':          aspectPrompt = 'melhorar a formatação e apresentação';          break;      }             const prompt = `        Com base no seguinte documento, forneça sugestões específicas para ${aspectPrompt}:                 Formate a resposta como uma lista de sugestões no formato JSON:        [          {"title": "Título da sugestão", "description": "Descrição detalhada"}        ]                 Documento:        ${content.substring(0, 3000)}...      `;       const response = await this.openAIService.generateCompletion(prompt, {        model: 'gpt-3.5-turbo',        temperature: 0.5,        maxTokens: 800      });       // Extrair JSON da resposta      const jsonMatch = response.match(/\[[\s\S]*\]/);      if (jsonMatch) {        return JSON.parse(jsonMatch[0]);      }       throw new Error('Formato de resposta inválido para sugestões específicas');    } catch (error) {      console.error(`Erro ao gerar sugestões para ${aspect}:`, error);      return [];    }  } }``

### src/plugins/MarkdownAnalyzerPlugin.ts

``import { Plugin } from '@/types/plugin'; export interface AnalysisResult {   headings: Array<{    level: number;    text: string;    position: {      start: number;      end: number;    };  }>;  links: Array<{    text: string;    url: string;    position: {      start: number;      end: number;    };  }>;  images: Array<{    altText: string;    url: string;    position: {      start: number;      end: number;    };  }>;  codeBlocks: Array<{    language: string;    code: string;    position: {      start: number;      end: number;    };  }>;  lists: Array<{    type: 'ordered' | 'unordered';    items: string[];    position: {      start: number;      end: number;    };  }>;  statistics: {    wordCount: number;    charCount: number;    paragraphCount: number;  }; } export class MarkdownAnalyzerPlugin implements Plugin {   id = 'markdown-analyzer';  name = 'Markdown Analyzer';  description = 'Analisa documentos Markdown para extrair estrutura e metadados';  version = '1.0.0';  author = 'System';   /**   * Analisa um documento Markdown   */  analyze(content: string): AnalysisResult {    // Extrair headings    const headings = this.extractHeadings(content);         // Extrair links    const links = this.extractLinks(content);         // Extrair imagens    const images = this.extractImages(content);         // Extrair blocos de código    const codeBlocks = this.extractCodeBlocks(content);         // Extrair listas    const lists = this.extractLists(content);         // Calcular estatísticas    const statistics = this.calculateStatistics(content);         return {      headings,      links,      images,      codeBlocks,      lists,      statistics    };  }   /**   * Extrai headings do Markdown   */  private extractHeadings(content: string): Array<{    level: number;    text: string;    position: {      start: number;      end: number;    };  }> {    const headings: Array<{      level: number;      text: string;      position: {        start: number;        end: number;      };    }> = [];         const headingRegex = /^(#{1,6})\s+(.+)$/gm;    let match;         while ((match = headingRegex.exec(content)) !== null) {      const level = match[1].length;      const text = match[2].trim();      const start = match.index;      const end = match.index + match[0].length;             headings.push({        level,        text,        position: {          start,          end        }      });    }         return headings;  }   /**   * Extrai links do Markdown   */  private extractLinks(content: string): Array<{    text: string;    url: string;    position: {      start: number;      end: number;    };  }> {    const links: Array<{      text: string;      url: string;      position: {        start: number;        end: number;      };    }> = [];         const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;    let match;         while ((match = linkRegex.exec(content)) !== null) {      const text = match[1];      const url = match[2];      const start = match.index;      const end = match.index + match[0].length;             links.push({        text,        url,        position: {          start,          end        }      });    }         return links;  }   /**   * Extrai imagens do Markdown   */  private extractImages(content: string): Array<{    altText: string;    url: string;    position: {      start: number;      end: number;    };  }> {    const images: Array<{      altText: string;      url: string;      position: {        start: number;        end: number;      };    }> = [];         const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;    let match;         while ((match = imageRegex.exec(content)) !== null) {      const altText = match[1];      const url = match[2];      const start = match.index;      const end = match.index + match[0].length;             images.push({        altText,        url,        position: {          start,          end        }      });    }         return images;  }   /**   * Extrai blocos de código do Markdown   */  private extractCodeBlocks(content: string): Array<{    language: string;    code: string;    position: {      start: number;      end: number;    };  }> {    const codeBlocks: Array<{      language: string;      code: string;      position: {        start: number;        end: number;      };    }> = [];         const codeBlockRegex = /```([a-zA-Z0-9]*)\n([\s\S]*?)```/g;    let match;         while ((match = codeBlockRegex.exec(content)) !== null) {      const language = match[1] || 'text';      const code = match[2];      const start = match.index;      const end = match.index + match[0].length;             codeBlocks.push({        language,        code,        position: {          start,          end        }      });    }         return codeBlocks;  }   /**   * Extrai listas do Markdown   */  private extractLists(content: string): Array<{    type: 'ordered' | 'unordered';    items: string[];    position: {      start: number;      end: number;    };  }> {    const lists: Array<{      type: 'ordered' | 'unordered';      items: string[];      position: {        start: number;        end: number;      };    }> = [];         // Listas não ordenadas    const ulRegex = /^(\s*[-*+]\s+.+\n)+/gm;    let ulMatch;         while ((ulMatch = ulRegex.exec(content)) !== null) {      const listText = ulMatch[0];      const start = ulMatch.index;      const end = ulMatch.index + listText.length;             // Extrair itens      const items = listText        .split('\n')        .filter(line => line.trim().length > 0)        .map(line => line.replace(/^\s*[-*+]\s+/, '').trim());             lists.push({        type: 'unordered',        items,        position: {          start,          end        }      });    }         // Listas ordenadas    const olRegex = /^(\s*\d+\.\s+.+\n)+/gm;    let olMatch;         while ((olMatch = olRegex.exec(content)) !== null) {      const listText = olMatch[0];      const start = olMatch.index;      const end = olMatch.index + listText.length;             // Extrair itens      const items = listText        .split('\n')        .filter(line => line.trim().length > 0)        .map(line => line.replace(/^\s*\d+\.\s+/, '').trim());             lists.push({        type: 'ordered',        items,        position: {          start,          end        }      });    }         return lists;  }   /**   * Calcula estatísticas do Markdown   */  private calculateStatistics(content: string): {    wordCount: number;    charCount: number;    paragraphCount: number;  } {    // Remover blocos de código    const contentWithoutCode = content.replace(/```[\s\S]*?```/g, '');         // Remover marcações básicas (links, ênfase, etc.)    const plainText = contentWithoutCode      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // links      .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1') // imagens      .replace(/[*_]{1,2}([^*_]+)[*_]{1,2}/g, '$1') // ênfase      .replace(/`([^`]+)`/g, '$1'); // código inline         // Contar caracteres    const charCount = plainText.length;         // Contar palavras    const wordCount = plainText      .split(/\s+/)      .filter(word => word.length > 0)      .length;         // Contar parágrafos    const paragraphCount = plainText      .split(/\n\s*\n/)      .filter(p => p.trim().length > 0)      .length;         return {      wordCount,      charCount,      paragraphCount    };  }   /**   * Gera tabela de conteúdo (TOC) a partir de headings   */  generateTableOfContents(    headings: Array<{      level: number;      text: string;    }>  ): string {    if (headings.length === 0) {      return '';    }         let toc = '';    const minLevel = Math.min(...headings.map(h => h.level));         for (const heading of headings) {      const slug = heading.text.toLowerCase()        .replace(/[^\w\s-]/g, '')        .replace(/\s+/g, '-');             const indent = '  '.repeat(heading.level - minLevel);      toc += `${indent}- [${heading.text}](#${slug})\n`;    }         return toc;  } }``


### src/services/ai/OpenAIService.ts

``import { CompletionOptions, ChatMessage, ChatResponse } from '@/types/llm'; import { MonitoringService } from '../monitoring/MonitoringService'; /**  * Serviço para integração com a API da OpenAI */ export class OpenAIService {   private static instance: OpenAIService;  private apiKey: string;  private monitoringService: MonitoringService;   private constructor(apiKey: string) {    this.apiKey = apiKey;    this.monitoringService = MonitoringService.getInstance();  }   /**   * Obtém instância única (Singleton)   */  public static getInstance(apiKey?: string): OpenAIService {    if (!OpenAIService.instance) {      if (!apiKey) {        throw new Error('API key is required to initialize OpenAIService');      }      OpenAIService.instance = new OpenAIService(apiKey);    }    return OpenAIService.instance;  }   /**   * Gera completamento de texto   */  async generateCompletion(prompt: string, options: CompletionOptions = {}): Promise<string> {    const startTime = Date.now();         try {      const response = await fetch('https://api.openai.com/v1/chat/completions', {        method: 'POST',        headers: {          'Content-Type': 'application/json',          'Authorization': `Bearer ${this.apiKey}`        },        body: JSON.stringify({          model: options.model || 'gpt-3.5-turbo',          messages: [            { role: 'system', content: options.systemPrompt || 'You are a helpful assistant.' },            { role: 'user', content: prompt }          ],          temperature: options.temperature ?? 0.7,          max_tokens: options.maxTokens ?? 1000,          top_p: options.topP ?? 1.0,          frequency_penalty: options.frequencyPenalty ?? 0.0,          presence_penalty: options.presencePenalty ?? 0.0        })      });       if (!response.ok) {        const error = await response.json();        throw new Error(`OpenAI API error: ${error.error?.message || 'Unknown error'}`);      }       const data = await response.json();      const result = data.choices[0].message.content;       // Registrar métricas      const endTime = Date.now();      this.monitoringService.logEvent({        type: 'openai_completion',        data: {          model: options.model || 'gpt-3.5-turbo',          tokens: {            prompt: this.estimateTokenCount(prompt),            completion: this.estimateTokenCount(result),            total: data.usage?.total_tokens          },          latency: endTime - startTime,          success: true        }      });       return result;    } catch (error) {      // Registrar erro      this.monitoringService.logEvent({        type: 'openai_completion_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error',          model: options.model || 'gpt-3.5-turbo',          prompt: prompt.substring(0, 100) + '...'        }      });             throw error;    }  }   /**   * Gera chat completion   */  async generateChat(messages: ChatMessage[], options: CompletionOptions = {}): Promise<ChatResponse> {    const startTime = Date.now();         try {      // Adicionar mensagem do sistema se não existir      if (!messages.some(m => m.role === 'system')) {        messages = [          { role: 'system', content: options.systemPrompt || 'You are a helpful assistant.' },          ...messages        ];      }       const response = await fetch('https://api.openai.com/v1/chat/completions', {        method: 'POST',        headers: {          'Content-Type': 'application/json',          'Authorization': `Bearer ${this.apiKey}`        },        body: JSON.stringify({          model: options.model || 'gpt-3.5-turbo',          messages,          temperature: options.temperature ?? 0.7,          max_tokens: options.maxTokens ?? 1000,          top_p: options.topP ?? 1.0,          frequency_penalty: options.frequencyPenalty ?? 0.0,          presence_penalty: options.presencePenalty ?? 0.0        })      });       if (!response.ok) {        const error = await response.json();        throw new Error(`OpenAI API error: ${error.error?.message || 'Unknown error'}`);      }       const data = await response.json();      const result = {        id: data.id,        content: data.choices[0].message.content,        role: data.choices[0].message.role,        usage: data.usage      };       // Registrar métricas      const endTime = Date.now();      this.monitoringService.logEvent({        type: 'openai_chat',        data: {          model: options.model || 'gpt-3.5-turbo',          tokens: {            prompt: this.estimateTokenCountForMessages(messages),            completion: this.estimateTokenCount(result.content),            total: data.usage?.total_tokens          },          latency: endTime - startTime,          success: true        }      });       return result;    } catch (error) {      // Registrar erro      this.monitoringService.logEvent({        type: 'openai_chat_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error',          model: options.model || 'gpt-3.5-turbo'        }      });             throw error;    }  }   /**   * Gera embedding para texto   */  async generateEmbedding(text: string): Promise<number[]> {    const startTime = Date.now();         try {      const response = await fetch('https://api.openai.com/v1/embeddings', {        method: 'POST',        headers: {          'Content-Type': 'application/json',          'Authorization': `Bearer ${this.apiKey}`        },        body: JSON.stringify({          model: 'text-embedding-ada-002',          input: text        })      });       if (!response.ok) {        const error = await response.json();        throw new Error(`OpenAI API error: ${error.error?.message || 'Unknown error'}`);      }       const data = await response.json();      const embedding = data.data[0].embedding;       // Registrar métricas      const endTime = Date.now();      this.monitoringService.logEvent({        type: 'openai_embedding',        data: {          model: 'text-embedding-ada-002',          tokens: data.usage?.total_tokens,          latency: endTime - startTime,          success: true        }      });       return embedding;    } catch (error) {      // Registrar erro      this.monitoringService.logEvent({        type: 'openai_embedding_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error',          model: 'text-embedding-ada-002'        }      });             throw error;    }  }   /**   * Gera imagem a partir de um prompt   */  async generateImage(prompt: string, options: {    size?: '256x256' | '512x512' | '1024x1024';    n?: number;  } = {}): Promise<string[]> {    const startTime = Date.now();         try {      const response = await fetch('https://api.openai.com/v1/images/generations', {        method: 'POST',        headers: {          'Content-Type': 'application/json',          'Authorization': `Bearer ${this.apiKey}`        },        body: JSON.stringify({          prompt,          n: options.n || 1,          size: options.size || '1024x1024'        })      });       if (!response.ok) {        const error = await response.json();        throw new Error(`OpenAI API error: ${error.error?.message || 'Unknown error'}`);      }       const data = await response.json();      const urls = data.data.map((item: any) => item.url);       // Registrar métricas      const endTime = Date.now();      this.monitoringService.logEvent({        type: 'openai_image',        data: {          prompt: prompt.substring(0, 100) + '...',          size: options.size || '1024x1024',          count: options.n || 1,          latency: endTime - startTime,          success: true        }      });       return urls;    } catch (error) {      // Registrar erro      this.monitoringService.logEvent({        type: 'openai_image_error',        data: {          error: error instanceof Error ? error.message : 'Unknown error',          prompt: prompt.substring(0, 100) + '...'        }      });             throw error;    }  }   /**   * Estima contagem de tokens   * Nota: Esta é uma estimativa simples, não uma contagem precisa   */  private estimateTokenCount(text: string): number {    if (!text) return 0;    // Aproximadamente 4 caracteres por token    return Math.ceil(text.length / 4);  }   /**   * Estima contagem de tokens para mensagens de chat   */  private estimateTokenCountForMessages(messages: ChatMessage[]): number {    return messages.reduce((total, message) => {      return total + this.estimateTokenCount(message.content);    }, 0);  }   /**   * Atualiza a chave de API   */  setApiKey(apiKey: string): void {    this.apiKey = apiKey;  } }``

### src/components/media/MediaProcessor.tsx

`import React, { useState, useCallback } from 'react'; import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '../ui/card'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'; import { Progress } from '../ui/progress'; import { Button } from '../ui/button'; import { Info, FileImage, Music, Video, FileText, UploadCloud, RefreshCw } from 'lucide-react'; import { useMediaProcessor } from '@/hooks/useMediaProcessor'; import { MediaUploader } from '../upload/MediaUploader'; import { MediaStatistics } from './MediaStatistics'; import { ProcessingMetrics } from './ProcessingMetrics'; export function MediaProcessor() {   const [activeTab, setActiveTab] = useState<string>('upload');  const {    currentFile,    isProcessing,    processingProgress,    processingResult,    processFile,    resetProcessor,    error  } = useMediaProcessor();   const handleProcessFile = useCallback(async () => {    if (!currentFile) return;         await processFile();    setActiveTab('result');  }, [currentFile, processFile]);   const handleReset = useCallback(() => {    resetProcessor();    setActiveTab('upload');  }, [resetProcessor]);   const getMediaIcon = (type?: string) => {    if (!type) return <Info className="w-5 h-5" />;         if (type.startsWith('image')) return <FileImage className="w-5 h-5" />;    if (type.startsWith('audio')) return <Music className="w-5 h-5" />;    if (type.startsWith('video')) return <Video className="w-5 h-5" />;    return <FileText className="w-5 h-5" />;  };   return (    <Card className="w-full">      <CardHeader>        <CardTitle className="flex items-center gap-2">          <UploadCloud className="w-6 h-6" />          Processador de Mídia        </CardTitle>        <CardDescription>          Faça upload de arquivos de mídia (imagem, áudio, vídeo) para análise por IA        </CardDescription>      </CardHeader>             <CardContent>        <Tabs value={activeTab} onValueChange={setActiveTab}>          <TabsList className="grid w-full grid-cols-3">            <TabsTrigger value="upload">Upload</TabsTrigger>            <TabsTrigger value="result" disabled={!processingResult}>Resultado</TabsTrigger>            <TabsTrigger value="stats" disabled={!processingResult}>Estatísticas</TabsTrigger>          </TabsList>                     <TabsContent value="upload" className="pt-4">            <div className="space-y-4">              <MediaUploader />                             {currentFile && (                <div className="flex items-center justify-between p-3 border rounded-md">                  <div className="flex items-center gap-3">                    {getMediaIcon(currentFile.type)}                    <div>                      <p className="font-medium">{currentFile.name}</p>                      <p className="text-sm text-muted-foreground">                        {(currentFile.size / 1024).toFixed(1)} KB                      </p>                    </div>                  </div>                                     <Button                    onClick={handleProcessFile}                    disabled={isProcessing}                  >                    {isProcessing ? (                      <>                        <RefreshCw className="mr-2 h-4 w-4 animate-spin" />                        Processando                      </>                    ) : (                      'Processar'                    )}                  </Button>                </div>              )}                             {isProcessing && (                <div className="space-y-2">                  <p className="text-sm text-muted-foreground">                    Processando arquivo...                  </p>                  <Progress value={processingProgress} />                </div>              )}                             {error && (                <div className="p-3 text-sm rounded-md bg-destructive/10 text-destructive">                  {error}                </div>              )}            </div>          </TabsContent>                     <TabsContent value="result" className="pt-4">            {processingResult && (              <div className="space-y-4">                <div className="flex flex-col gap-2 p-4 border rounded-md">                  <h3 className="text-lg font-semibold">Resultado da Análise</h3>                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">                    <div>                      <h4 className="text-sm font-medium mb-2">Detalhes</h4>                      <ul className="space-y-1 text-sm">                        <li>Tipo: {processingResult.type}</li>                        <li>Arquivo: {processingResult.fileName}</li>                        <li>Tamanho: {(processingResult.fileSize / 1024).toFixed(1)} KB</li>                        <li>Processado em: {new Date(processingResult.processedAt).toLocaleString()}</li>                      </ul>                    </div>                                         {processingResult.metadata && (                      <div>                        <h4 className="text-sm font-medium mb-2">Metadados</h4>                        <ul className="space-y-1 text-sm">                          {Object.entries(processingResult.metadata).map(([key, value]) => (                            <li key={key}>                              {key}: {typeof value === 'object' ? JSON.stringify(value) : value}                            </li>                          ))}                        </ul>                      </div>                    )}                  </div>                </div>                                 <div className="p-4 border rounded-md">                  <h3 className="text-lg font-semibold mb-3">Análise</h3>                  <div className="whitespace-pre-wrap text-sm">                    {typeof processingResult.analysis === 'string'                      ? processingResult.analysis                      : JSON.stringify(processingResult.analysis, null, 2)}                  </div>                </div>                                 {processingResult.content && (                  <div className="p-4 border rounded-md">                    <h3 className="text-lg font-semibold mb-3">Conteúdo</h3>                    <div className="whitespace-pre-wrap text-sm">                      {processingResult.content}                    </div>                  </div>                )}              </div>            )}          </TabsContent>                     <TabsContent value="stats" className="pt-4">            {processingResult && (              <div className="space-y-4">                <ProcessingMetrics result={processingResult} />                <MediaStatistics result={processingResult} />              </div>            )}          </TabsContent>        </Tabs>      </CardContent>             <CardFooter className="flex justify-between">        <Button variant="outline" onClick={handleReset}>          Reiniciar        </Button>                 {processingResult && (          <Button>            Exportar Resultados          </Button>        )}      </CardFooter>    </Card>  ); }`

### src/components/llm/pipelines/PipelineTester.tsx

`import React, { useState, useCallback } from 'react'; import { Button } from '../../ui/button'; import { Textarea } from '../../ui/textarea'; import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '../../ui/card'; import { Alert, AlertDescription } from '../../ui/alert'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'; import { Badge } from '../../ui/badge'; import { useLLM } from '@/hooks/useLLM'; import { LLMPipeline } from '@/types/llm'; import { Loader2, Zap } from 'lucide-react'; interface PipelineTesterProps {   pipeline: LLMPipeline; } export function PipelineTester({ pipeline }: PipelineTesterProps) {   const [input, setInput] = useState<string>('');  const [activeTab, setActiveTab] = useState<string>('input');  const [result, setResult] = useState<string>('');  const [isProcessing, setIsProcessing] = useState<boolean>(false);  const [steps, setSteps] = useState<Array<{    stepId: string;    input: string;    output: string;    provider: string;  }>>([]);  const [error, setError] = useState<string | null>(null);     const { processThroughPipeline } = useLLM();     const handleExecute = useCallback(async () => {    if (!input.trim()) return;         setIsProcessing(true);    setError(null);         try {      const { result, steps: processSteps } = await processThroughPipeline(pipeline.id, input);             setResult(result);      setSteps(processSteps);      setActiveTab('result');    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');    } finally {      setIsProcessing(false);    }  }, [input, pipeline.id, processThroughPipeline]);     const handleReset = useCallback(() => {    setInput('');    setResult('');    setSteps([]);    setError(null);    setActiveTab('input');  }, []);   return (    <Card className="mt-6">      <CardHeader>        <CardTitle className="flex items-center gap-2">          <Zap className="h-5 w-5" />          Testar Pipeline        </CardTitle>      </CardHeader>             <CardContent>        <Tabs value={activeTab} onValueChange={setActiveTab}>          <TabsList>            <TabsTrigger value="input">Entrada</TabsTrigger>            <TabsTrigger value="result" disabled={!result}>Resultado</TabsTrigger>            <TabsTrigger value="steps" disabled={steps.length === 0}>Passos</TabsTrigger>          </TabsList>                     <TabsContent value="input" className="space-y-4 pt-4">            <div className="space-y-2">              <Textarea                placeholder="Digite o texto de entrada para testar o pipeline..."                value={input}                onChange={(e) => setInput(e.target.value)}                rows={8}                className="resize-none"              />            </div>                         {error && (              <Alert variant="destructive">                <AlertDescription>{error}</AlertDescription>              </Alert>            )}          </TabsContent>                     <TabsContent value="result" className="space-y-4 pt-4">            <div className="p-4 border rounded-md whitespace-pre-wrap">              {result}            </div>          </TabsContent>                     <TabsContent value="steps" className="space-y-4 pt-4">            {steps.map((step, index) => (              <div key={step.stepId} className="border rounded-md">                <div className="flex items-center justify-between px-4 py-2 bg-muted">                  <div className="flex items-center gap-2">                    <Badge variant="outline">Passo {index + 1}</Badge>                    <span className="text-sm font-medium">{pipeline.steps.find(s => s.id === step.stepId)?.role}</span>                  </div>                  <Badge variant="secondary">{step.provider}</Badge>                </div>                                 <div className="p-4">                  <div className="mb-2">                    <span className="text-xs font-medium text-muted-foreground">Entrada:</span>                    <div className="p-2 mt-1 text-sm bg-muted rounded-md whitespace-pre-wrap">                      {step.input}                    </div>                  </div>                                     <div>                    <span className="text-xs font-medium text-muted-foreground">Saída:</span>                    <div className="p-2 mt-1 text-sm bg-muted rounded-md whitespace-pre-wrap">                      {step.output}                    </div>                  </div>                </div>              </div>            ))}          </TabsContent>        </Tabs>      </CardContent>             <CardFooter className="flex justify-between">        <Button variant="outline" onClick={handleReset}>          Limpar        </Button>                 <Button          onClick={handleExecute}          disabled={!input.trim() || isProcessing}        >          {isProcessing ? (            <>              <Loader2 className="mr-2 h-4 w-4 animate-spin" />              Processando            </>          ) : (            'Executar Pipeline'          )}        </Button>      </CardFooter>    </Card>  ); }`

### src/hooks/useMediaProcessor.ts

`import { useState, useCallback } from 'react'; import { MediaProcessingResult } from '@/types/media'; import { MediaProcessor } from '@/services/media/MediaProcessor'; export const useMediaProcessor = () => {   const [currentFile, setCurrentFile] = useState<File | null>(null);  const [isProcessing, setIsProcessing] = useState(false);  const [processingProgress, setProcessingProgress] = useState(0);  const [processingResult, setProcessingResult] = useState<MediaProcessingResult | null>(null);  const [error, setError] = useState<string | null>(null);     const mediaProcessor = new MediaProcessor();     const processFile = useCallback(async () => {    if (!currentFile) {      setError('Nenhum arquivo selecionado');      return;    }         setIsProcessing(true);    setProcessingProgress(0);    setError(null);         try {      // Simular progresso (não temos feedback real de progresso da API)      const progressInterval = setInterval(() => {        setProcessingProgress(prev => {          const newProgress = prev + 5;          return newProgress > 90 ? 90 : newProgress;        });      }, 200);             // Processar o arquivo com o tipo correspondente      let result: MediaProcessingResult;             if (currentFile.type.startsWith('image')) {        result = await mediaProcessor.processImage(currentFile);      } else if (currentFile.type.startsWith('audio')) {        result = await mediaProcessor.processAudio(currentFile);      } else if (currentFile.type.startsWith('video')) {        result = await mediaProcessor.processVideo(currentFile);      } else {        throw new Error('Tipo de arquivo não suportado');      }             clearInterval(progressInterval);      setProcessingProgress(100);      setProcessingResult(result);    } catch (err) {      setError(err instanceof Error ? err.message : 'Erro desconhecido');    } finally {      setIsProcessing(false);    }  }, [currentFile, mediaProcessor]);     const resetProcessor = useCallback(() => {    setCurrentFile(null);    setIsProcessing(false);    setProcessingProgress(0);    setProcessingResult(null);    setError(null);  }, []);     const uploadFile = useCallback((file: File) => {    setCurrentFile(file);    setProcessingResult(null);    setError(null);  }, []);   return {    currentFile,    isProcessing,    processingProgress,    processingResult,    error,    uploadFile,    processFile,    resetProcessor  }; };`

### src/services/llm/LLMService.ts

``import { ChatMessage, ChatResponse, CompletionOptions, LLMProvider, LLMPipeline, PipelineStep } from '@/types/llm'; import { OpenAIService } from '../ai/OpenAIService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class LLMService {   private static instance: LLMService;  private providers: Map<string, LLMProvider>;  private pipelines: Map<string, LLMPipeline>;  private defaultProviderId: string | null;  private monitoringService: MonitoringService;   private constructor() {    this.providers = new Map();    this.pipelines = new Map();    this.defaultProviderId = null;    this.monitoringService = MonitoringService.getInstance();         // Carregar do localStorage, se disponível    this.loadProviders();    this.loadPipelines();    this.loadDefaultProvider();  }   /**   * Obtém instância única (Singleton)   */  public static getInstance(): LLMService {    if (!LLMService.instance) {      LLMService.instance = new LLMService();    }    return LLMService.instance;  }   /**   * Carrega provedores do armazenamento local   */  private loadProviders(): void {    try {      const savedProviders = localStorage.getItem('llm_providers');      if (savedProviders) {        const providers = JSON.parse(savedProviders) as LLMProvider[];        providers.forEach(provider => {          this.providers.set(provider.id, provider);        });      }    } catch (error) {      console.error('Erro ao carregar provedores:', error);    }  }   /**   * Carrega pipelines do armazenamento local   */  private loadPipelines(): void {    try {      const savedPipelines = localStorage.getItem('llm_pipelines');      if (savedPipelines) {        const pipelines = JSON.parse(savedPipelines) as LLMPipeline[];        pipelines.forEach(pipeline => {          this.pipelines.set(pipeline.id, pipeline);        });      }    } catch (error) {      console.error('Erro ao carregar pipelines:', error);    }  }   /**   * Carrega provedor padrão do armazenamento local   */  private loadDefaultProvider(): void {    try {      const defaultProvider = localStorage.getItem('llm_default_provider');      if (defaultProvider) {        this.defaultProviderId = defaultProvider;      }    } catch (error) {      console.error('Erro ao carregar provedor padrão:', error);    }  }   /**   * Salva provedores no armazenamento local   */  private saveProviders(): void {    try {      const providers = Array.from(this.providers.values());      localStorage.setItem('llm_providers', JSON.stringify(providers));    } catch (error) {      console.error('Erro ao salvar provedores:', error);    }  }   /**   * Salva pipelines no armazenamento local   */  private savePipelines(): void {    try {      const pipelines = Array.from(this.pipelines.values());      localStorage.setItem('llm_pipelines', JSON.stringify(pipelines));    } catch (error) {      console.error('Erro ao salvar pipelines:', error);    }  }   /**   * Salva provedor padrão no armazenamento local   */  private saveDefaultProvider(): void {    try {      if (this.defaultProviderId) {        localStorage.setItem('llm_default_provider', this.defaultProviderId);      } else {        localStorage.removeItem('llm_default_provider');      }    } catch (error) {      console.error('Erro ao salvar provedor padrão:', error);    }  }   /**   * Adiciona um novo provedor   */  addProvider(provider: LLMProvider): void {    this.providers.set(provider.id, provider);    this.saveProviders();         // Se for o primeiro provedor, defini-lo como padrão    if (this.providers.size === 1 && !this.defaultProviderId) {      this.defaultProviderId = provider.id;      this.saveDefaultProvider();    }  }   /**   * Atualiza um provedor existente   */  updateProvider(providerId: string, updates: Partial<LLMProvider>): void {    const provider = this.providers.get(providerId);    if (!provider) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         const updatedProvider = { ...provider, ...updates };    this.providers.set(providerId, updatedProvider);    this.saveProviders();  }   /**   * Remove um provedor   */  removeProvider(providerId: string): void {    if (!this.providers.has(providerId)) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         this.providers.delete(providerId);    this.saveProviders();         // Se o provedor removido era o padrão, escolher outro    if (this.defaultProviderId === providerId) {      const providers = Array.from(this.providers.values());      this.defaultProviderId = providers.length > 0 ? providers[0].id : null;      this.saveDefaultProvider();    }         // Atualizar pipelines que usam este provedor    for (const pipeline of this.pipelines.values()) {      let updated = false;      const updatedSteps = pipeline.steps.map(step => {        if (step.providerId === providerId) {          updated = true;          return {            ...step,            providerId: this.defaultProviderId || ''          };        }        return step;      });             if (updated) {        this.pipelines.set(pipeline.id, {          ...pipeline,          steps: updatedSteps        });      }    }         if (this.pipelines.size > 0) {      this.savePipelines();    }  }   /**   * Lista todos os provedores   */  listProviders(): LLMProvider[] {    return Array.from(this.providers.values());  }   /**   * Define um provedor como padrão   */  setDefaultProvider(providerId: string): void {    if (!this.providers.has(providerId)) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         this.defaultProviderId = providerId;    this.saveDefaultProvider();  }   /**   * Obtém o ID do provedor padrão   */  getDefaultProvider(): string {    if (!this.defaultProviderId) {      const providers = Array.from(this.providers.values());      return providers.length > 0 ? providers[0].id : '';    }    return this.defaultProviderId;  }   /**   * Adiciona um novo pipeline   */  addPipeline(pipeline: LLMPipeline): void {    this.pipelines.set(pipeline.id, pipeline);    this.savePipelines();  }   /**   * Atualiza um pipeline existente   */  updatePipeline(pipelineId: string, updates: Partial<LLMPipeline>): void {    const pipeline = this.pipelines.get(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline não encontrado: ${pipelineId}`);    }         const updatedPipeline = { ...pipeline, ...updates };    this.pipelines.set(pipelineId, updatedPipeline);    this.savePipelines();  }   /**   * Remove um pipeline   */  removePipeline(pipelineId: string): void {    if (!this.pipelines.has(pipelineId)) {      throw new Error(`Pipeline não encontrado: ${pipelineId}`);    }         this.pipelines.delete(pipelineId);    this.savePipelines();  }   /**   * Obtém um pipeline pelo ID   */  getPipeline(pipelineId: string): LLMPipeline | undefined {    return this.pipelines.get(pipelineId);  }   /**   * Lista todos os pipelines   */  listPipelines(): LLMPipeline[] {    return Array.from(this.pipelines.values());  }   /**   * Executa um texto através de um pipeline   */  async executePipeline(pipelineId: string, input: string): Promise<{    result: string;    steps: Array<{      stepId: string;      input: string;      output: string;      provider: string;    }>;  }> {    const pipeline = this.pipelines.get(pipelineId);    if (!pipeline) {      throw new Error(`Pipeline não encontrado: ${pipelineId}`);    }         if (pipeline.steps.length === 0) {      throw new Error('Pipeline sem passos definidos');    }         const steps: Array<{      stepId: string;      input: string;      output: string;      provider: string;    }> = [];         // Ordenar passos por ordem    const orderedSteps = [...pipeline.steps].sort((a, b) => a.order - b.order);         let currentInput = input;    let finalOutput = '';         // Executar cada passo sequencialmente    for (const step of orderedSteps) {      const provider = this.providers.get(step.providerId);      if (!provider) {        throw new Error(`Provedor não encontrado para o passo: ${step.id}`);      }             // Executar passo      const output = await this.executeStep(step, currentInput, provider);             // Registrar passo      steps.push({        stepId: step.id,        input: currentInput,        output,        provider: provider.name      });             // Atualizar input para o próximo passo      currentInput = output;      finalOutput = output;    }         return {      result: finalOutput,      steps    };  }   /**   * Executa um único passo de pipeline   */  private async executeStep(    step: PipelineStep,    input: string,    provider: LLMProvider  ): Promise<string> {    try {      // Configurar serviço apropriado para o provedor      const service = this.getServiceForProvider(provider);             // Configurar opções com base no provedor      const options: CompletionOptions = {        systemPrompt: step.systemPrompt || 'Você é um assistente útil.',        temperature: provider.parameters?.defaultTemperature || 0.7,        maxTokens: provider.parameters?.defaultMaxTokens || 1000,        topP: provider.parameters?.defaultTopP || 1.0      };             // Executar com base no papel do passo      if (step.role === 'input') {        // Passo de entrada: gerar prompt a partir do input        return await service.generateCompletion(input, options);      } else if (step.role === 'processor') {        // Passo de processamento: transformar o input        return await service.generateCompletion(input, options);      } else if (step.role === 'output') {        // Passo de saída: formatar o resultado final        return await service.generateCompletion(input, options);      }             throw new Error(`Papel de passo inválido: ${step.role}`);    } catch (error) {      console.error(`Erro ao executar passo ${step.id}:`, error);      throw error;    }  }   /**   * Obtém o serviço apropriado para um provedor   */  private getServiceForProvider(provider: LLMProvider): {    generateCompletion: (prompt: string, options?: CompletionOptions) => Promise<string>;    generateChat: (messages: ChatMessage[], options?: CompletionOptions) => Promise<ChatResponse>;    generateEmbedding: (text: string) => Promise<number[]>;  } {    // Por enquanto, apenas suportamos OpenAI    // No futuro, podemos adicionar mais adaptadores    if (provider.type === 'openai' || provider.type === 'azure-openai') {      const openAIService = OpenAIService.getInstance(provider.apiKey);      return openAIService;    }         throw new Error(`Tipo de provedor não suportado: ${provider.type}`);  }   /**   * Gera um completamento de texto   */  async generateCompletion(    prompt: string,    options?: CompletionOptions & { providerId?: string }  ): Promise<string> {    // Determinar o provedor a ser usado    const providerId = options?.providerId || this.defaultProviderId;    if (!providerId) {      throw new Error('Nenhum provedor definido');    }         const provider = this.providers.get(providerId);    if (!provider) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         // Obter o serviço apropriado    const service = this.getServiceForProvider(provider);         // Mesclar opções do provedor com as opções fornecidas    const mergedOptions: CompletionOptions = {      systemPrompt: options?.systemPrompt || 'Você é um assistente útil.',      temperature: options?.temperature || provider.parameters?.defaultTemperature || 0.7,      maxTokens: options?.maxTokens || provider.parameters?.defaultMaxTokens || 1000,      topP: options?.topP || provider.parameters?.defaultTopP || 1.0,      model: options?.model || provider.parameters?.defaultModel || 'gpt-3.5-turbo'    };         // Gerar completamento    return await service.generateCompletion(prompt, mergedOptions);  }   /**   * Gera um chat completion   */  async generateChat(    messages: ChatMessage[],    options?: CompletionOptions & { providerId?: string }  ): Promise<ChatResponse> {    // Determinar o provedor a ser usado    const providerId = options?.providerId || this.defaultProviderId;    if (!providerId) {      throw new Error('Nenhum provedor definido');    }         const provider = this.providers.get(providerId);    if (!provider) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         // Obter o serviço apropriado    const service = this.getServiceForProvider(provider);         // Mesclar opções do provedor com as opções fornecidas    const mergedOptions: CompletionOptions = {      systemPrompt: options?.systemPrompt || 'Você é um assistente útil.',      temperature: options?.temperature || provider.parameters?.defaultTemperature || 0.7,      maxTokens: options?.maxTokens || provider.parameters?.defaultMaxTokens || 1000,      topP: options?.topP || provider.parameters?.defaultTopP || 1.0,      model: options?.model || provider.parameters?.defaultModel || 'gpt-3.5-turbo'    };         // Gerar chat completion    return await service.generateChat(messages, mergedOptions);  }   /**   * Gera um embedding   */  async generateEmbedding(    text: string,    options?: { providerId?: string }  ): Promise<number[]> {    // Determinar o provedor a ser usado    const providerId = options?.providerId || this.defaultProviderId;    if (!providerId) {      throw new Error('Nenhum provedor definido');    }         const provider = this.providers.get(providerId);    if (!provider) {      throw new Error(`Provedor não encontrado: ${providerId}`);    }         // Obter o serviço apropriado    const service = this.getServiceForProvider(provider);         // Gerar embedding    return await service.generateEmbedding(text);  } }``

### src/services/media/MediaProcessor.ts

``import { MediaType, MediaProcessingResult } from '@/types/media'; import { ImageProcessor } from './ImageProcessor'; import { AudioProcessor } from './AudioProcessor'; import { VideoProcessor } from './VideoProcessor'; import { CacheService } from '../cache/CacheService'; import { MonitoringService } from '../monitoring/MonitoringService'; export class MediaProcessor {   private imageProcessor: ImageProcessor;  private audioProcessor: AudioProcessor;  private videoProcessor: VideoProcessor;  private cacheService: CacheService<MediaProcessingResult>;  private monitoringService: MonitoringService;   constructor(    openAIKey?: string,    cacheService?: CacheService<MediaProcessingResult>,    monitoringService?: MonitoringService  ) {    const apiKey = openAIKey || import.meta.env.VITE_OPENAI_API_KEY;    if (!apiKey) {      throw new Error('OpenAI API key is required');    }         this.imageProcessor = new ImageProcessor(apiKey);    this.audioProcessor = new AudioProcessor(apiKey);    this.videoProcessor = new VideoProcessor(apiKey);    this.cacheService = cacheService || new CacheService<MediaProcessingResult>();    this.monitoringService = monitoringService || MonitoringService.getInstance();  }   /**   * Processa um arquivo de imagem   */  async processImage(file: File): Promise<MediaProcessingResult> {    try {      const startTime = Date.now();      this.logEvent('image_processing_start', { fileName: file.name });       // Verificar cache      const cacheKey = `image-${file.name}-${file.size}`;      const cached = await this.cacheService.get(cacheKey);      if (cached) {        this.logEvent('image_processing_cache_hit', { fileName: file.name });        return cached;      }       // Processar imagem      const result = await this.imageProcessor.process(file);       // Adicionar metadados      const processedResult: MediaProcessingResult = {        ...result,        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'image',        metadata: {          name: file.name,          size: file.size,          type: file.type,          ...result.metadata        }      };       // Armazenar em cache      await this.cacheService.set(cacheKey, processedResult);       // Registrar métricas      const processingTime = Date.now() - startTime;      this.logEvent('image_processing_complete', {        fileName: file.name,        fileSize: file.size,        processingTime      });       return processedResult;    } catch (error) {      this.logEvent('image_processing_error', {        fileName: file.name,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Processa um arquivo de áudio   */  async processAudio(file: File): Promise<MediaProcessingResult> {    try {      const startTime = Date.now();      this.logEvent('audio_processing_start', { fileName: file.name });       // Verificar cache      const cacheKey = `audio-${file.name}-${file.size}`;      const cached = await this.cacheService.get(cacheKey);      if (cached) {        this.logEvent('audio_processing_cache_hit', { fileName: file.name });        return cached;      }       // Processar áudio      const result = await this.audioProcessor.process(file);       // Adicionar metadados      const processedResult: MediaProcessingResult = {        ...result,        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'audio',        metadata: {          name: file.name,          size: file.size,          type: file.type,          ...result.metadata        }      };       // Armazenar em cache      await this.cacheService.set(cacheKey, processedResult);       // Registrar métricas      const processingTime = Date.now() - startTime;      this.logEvent('audio_processing_complete', {        fileName: file.name,        fileSize: file.size,        processingTime      });       return processedResult;    } catch (error) {      this.logEvent('audio_processing_error', {        fileName: file.name,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Processa um arquivo de vídeo   */  async processVideo(file: File): Promise<MediaProcessingResult> {    try {      const startTime = Date.now();      this.logEvent('video_processing_start', { fileName: file.name });       // Verificar cache      const cacheKey = `video-${file.name}-${file.size}`;      const cached = await this.cacheService.get(cacheKey);      if (cached) {        this.logEvent('video_processing_cache_hit', { fileName: file.name });        return cached;      }       // Processar vídeo      const result = await this.videoProcessor.process(file);       // Adicionar metadados      const processedResult: MediaProcessingResult = {        ...result,        fileName: file.name,        fileSize: file.size,        fileType: file.type,        processedAt: new Date().toISOString(),        type: 'video',        metadata: {          name: file.name,          size: file.size,          type: file.type,          ...result.metadata        }      };       // Armazenar em cache      await this.cacheService.set(cacheKey, processedResult);       // Registrar métricas      const processingTime = Date.now() - startTime;      this.logEvent('video_processing_complete', {        fileName: file.name,        fileSize: file.size,        processingTime      });       return processedResult;    } catch (error) {      this.logEvent('video_processing_error', {        fileName: file.name,        error: error instanceof Error ? error.message : 'Unknown error'      });      throw error;    }  }   /**   * Processa um arquivo com base em seu tipo   */  async processFile(file: File): Promise<MediaProcessingResult> {    const fileType = this.detectFileType(file);         switch (fileType) {      case 'image':        return this.processImage(file);      case 'audio':        return this.processAudio(file);      case 'video':        return this.processVideo(file);      default:        throw new Error(`Tipo de arquivo não suportado: ${file.type}`);    }  }   /**   * Detecta o tipo de mídia com base no tipo MIME   */  private detectFileType(file: File): MediaType {    if (file.type.startsWith('image/')) {      return 'image';    } else if (file.type.startsWith('audio/')) {      return 'audio';    } else if (file.type.startsWith('video/')) {      return 'video';    } else if (file.type === 'text/markdown' || file.name.endsWith('.md')) {      return 'markdown';    } else if (file.type.startsWith('text/')) {      return 'text';    }         // Tentar inferir pelo nome do arquivo    const extension = file.name.split('.').pop()?.toLowerCase();    if (extension) {      if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(extension)) {        return 'image';      } else if (['mp3', 'wav', 'ogg', 'aac', 'm4a'].includes(extension)) {        return 'audio';      } else if (['mp4', 'webm', 'mov', 'avi', 'mkv'].includes(extension)) {        return 'video';      } else if (['md', 'markdown'].includes(extension)) {        return 'markdown';      } else if (['txt', 'html', 'css', 'js', 'json'].includes(extension)) {        return 'text';      }    }         throw new Error(`Tipo de arquivo não suportado: ${file.type}`);  }   /**   * Registra evento   */  private logEvent(type: string, data: any): void {    this.monitoringService.logEvent({      type: `media_processor:${type}`,      data    });  } }``

### src/services/media/ImageProcessor.ts

``import { OpenAIService } from '../ai/OpenAIService'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class ImageProcessor extends BaseMediaProcessor {   private openAIService: OpenAIService;   constructor(apiKey: string) {    super();    this.openAIService = OpenAIService.getInstance(apiKey);  }   /**   * Processa um arquivo de imagem   */  async process(file: File): Promise<{    analysis: string;    metadata?: any;  }> {    try {      // Converter arquivo para base64      const base64Data = await this.fileToBase64(file);             // Analisar a imagem usando visão da OpenAI      const messages = [        {          role: 'system',          content: `Você é um assistente especializado em análise de imagens.                    Analise a imagem fornecida e descreva detalhadamente seu conteúdo,                    incluindo objetos, pessoas, cenário, cores, ações, e qualquer texto visível.                    Seja detalhado, mas conciso.                    Inclua também estimativas das dimensões e qualidade da imagem.`        },        {          role: 'user',          content: [            {              type: 'text',              text: 'Analise esta imagem em detalhes.'            },            {              type: 'image_url',              image_url: {                url: base64Data              }            }          ]        }      ];       // Chamar a API da OpenAI para analisar a imagem      const response = await this.openAIService.generateChat(messages, {        model: 'gpt-4-vision-preview'      });       // Extrair dimensões da imagem      const dimensions = await this.getImageDimensions(file);             return {        analysis: response.content,        metadata: {          dimensions,          format: file.type.split('/')[1]        }      };    } catch (error) {      console.error('Erro ao processar imagem:', error);      throw new Error(`Falha ao processar imagem: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);    }  }   /**   * Converte um arquivo para formato base64   */  private async fileToBase64(file: File): Promise<string> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.readAsDataURL(file);      reader.onload = () => resolve(reader.result as string);      reader.onerror = error => reject(error);    });  }   /**   * Extrai as dimensões de uma imagem   */  private getImageDimensions(file: File): Promise<{ width: number; height: number }> {    return new Promise((resolve, reject) => {      const img = new Image();      img.onload = () => {        resolve({          width: img.width,          height: img.height        });      };      img.onerror = () => {        reject(new Error('Falha ao carregar imagem para obter dimensões'));      };      img.src = URL.createObjectURL(file);    });  } }``

### src/services/media/AudioProcessor.ts

``import { OpenAIService } from '../ai/OpenAIService'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class AudioProcessor extends BaseMediaProcessor {   private openAIService: OpenAIService;   constructor(apiKey: string) {    super();    this.openAIService = OpenAIService.getInstance(apiKey);  }   /**   * Processa um arquivo de áudio   */  async process(file: File): Promise<{    analysis: string;    transcript?: string;    metadata?: any;  }> {    try {      // Na implementação completa, aqui faria upload do arquivo e usaria Whisper API      // Para a versão de demonstração, vamos simular a transcrição             // Gerar uma análise simulada      const transcript = await this.simulateTranscription(file);             // Analisar o conteúdo transcrito      const analysis = await this.analyzeTranscript(transcript);             // Extrair metadados do áudio (duração, etc.)      const metadata = await this.extractAudioMetadata(file);             return {        analysis,        transcript,        metadata      };    } catch (error) {      console.error('Erro ao processar áudio:', error);      throw new Error(`Falha ao processar áudio: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);    }  }   /**   * Simula a transcrição de um arquivo de áudio   * Nota: Em uma implementação real, usaria a API Whisper da OpenAI   */  private async simulateTranscription(file: File): Promise<string> {    // Simulação: gerar uma descrição do arquivo    const prompt = `      Você é um assistente especializado em gerar transcrições simuladas.      Simule uma transcrição para um arquivo de áudio com as seguintes características:      - Nome do arquivo: ${file.name}      - Tamanho: ${(file.size / 1024).toFixed(2)} KB      - Tipo MIME: ${file.type}             Crie uma transcrição fictícia que poderia representar o conteúdo deste arquivo.      A transcrição deve ter pelo menos 3 parágrafos e ser realista.    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.7,      maxTokens: 500    });         return response;  }   /**   * Analisa o conteúdo transcrito para gerar insights   */  private async analyzeTranscript(transcript: string): Promise<string> {    const prompt = `      Analise a seguinte transcrição de áudio e forneça insights detalhados:      1. Resumo do conteúdo principal      2. Identificação de tópicos principais      3. Tom e estilo da fala      4. Possíveis falantes      5. Qualidade e clareza estimada             Transcrição:      ${transcript}    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.3,      maxTokens: 800    });         return response;  }   /**   * Extrai metadados do arquivo de áudio   */  private async extractAudioMetadata(file: File): Promise<{    format: string;    duration?: number;    estimatedQuality?: string;  }> {    // Em uma implementação real, usaríamos a Web Audio API    // Para esta versão, simulamos os metadados         // Extrair formato do tipo MIME    const format = file.type.split('/')[1] || 'desconhecido';         // Estimar duração com base no tamanho do arquivo (muito aproximado)    // Considerando ~100KB por minuto para MP3 de qualidade média    const estimatedDurationMinutes = file.size / (100 * 1024);    const duration = Math.round(estimatedDurationMinutes * 60); // em segundos         // Estimar qualidade com base no tamanho    let estimatedQuality = 'média';    const sizePerSecond = file.size / duration;         if (sizePerSecond > 15 * 1024) { // > 15KB/s      estimatedQuality = 'alta';    } else if (sizePerSecond < 5 * 1024) { // < 5KB/s      estimatedQuality = 'baixa';    }         return {      format,      duration,      estimatedQuality    };  } }``

### src/services/media/VideoProcessor.ts

``import { OpenAIService } from '../ai/OpenAIService'; import { BaseMediaProcessor } from './BaseMediaProcessor'; export class VideoProcessor extends BaseMediaProcessor {   private openAIService: OpenAIService;   constructor(apiKey: string) {    super();    this.openAIService = OpenAIService.getInstance(apiKey);  }   /**   * Processa um arquivo de vídeo   */  async process(file: File): Promise<{    analysis: string;    scenes?: Array<{ time: string; description: string }>;    transcript?: string;    metadata?: any;  }> {    try {      // Na implementação completa, aqui faria extração de frames e transcrição de áudio      // Para a versão de demonstração, vamos simular             // Simular análise de frames-chave      const scenes = await this.simulateSceneAnalysis(file);             // Simular transcrição de áudio      const transcript = await this.simulateTranscription(file);             // Gerar análise completa combinando informações      const analysis = await this.generateCompleteAnalysis(file, scenes, transcript);             // Extrair metadados do vídeo      const metadata = await this.extractVideoMetadata(file);             return {        analysis,        scenes,        transcript,        metadata      };    } catch (error) {      console.error('Erro ao processar vídeo:', error);      throw new Error(`Falha ao processar vídeo: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);    }  }   /**   * Simula a análise de cenas em um vídeo   */  private async simulateSceneAnalysis(file: File): Promise<Array<{    time: string;    description: string;  }>> {    // Estimar duração do vídeo com base no tamanho    // Considerando ~1MB por minuto para vídeo de qualidade média    const estimatedDurationMinutes = file.size / (1024 * 1024);    const durationSeconds = Math.round(estimatedDurationMinutes * 60);         // Gerar entre 3 e 8 cenas, dependendo da duração    const numScenes = Math.max(3, Math.min(8, Math.floor(estimatedDurationMinutes) + 2));         // Gerar tempos distribuídos ao longo do vídeo    const times: number[] = [];    for (let i = 0; i < numScenes; i++) {      times.push(Math.floor((i / numScenes) * durationSeconds));    }         // Simular descrições para cada tempo    const prompt = `      Você é um assistente especializado em análise de vídeo.      Simule descrições para ${numScenes} cenas diferentes de um vídeo fictício      chamado "${file.name}", que tem duração estimada de ${Math.round(estimatedDurationMinutes)} minutos.      Cada descrição deve ser concisa (máximo 100 caracteres) e descrever o que poderia estar acontecendo na cena.      Formate a resposta como uma lista numerada.    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.7,      maxTokens: 500    });         // Extrair descrições da resposta    const descriptionLines = response      .split('\n')      .filter(line => /^\d+\./.test(line))      .map(line => line.replace(/^\d+\.\s*/, '').trim());         // Combinar tempos e descrições    return times.map((time, index) => ({      time: this.formatTime(time),      description: descriptionLines[index] || `Cena ${index + 1}`    }));  }   /**   * Simula a transcrição do áudio de um vídeo   */  private async simulateTranscription(file: File): Promise<string> {    const prompt = `      Você é um assistente especializado em gerar transcrições simuladas.      Simule uma transcrição para o áudio de um vídeo com as seguintes características:      - Nome do arquivo: ${file.name}      - Tamanho: ${(file.size / (1024 * 1024)).toFixed(2)} MB      - Tipo MIME: ${file.type}             Crie uma transcrição fictícia que poderia representar o áudio deste vídeo.      A transcrição deve ter pelo menos 3 parágrafos e incluir diálogos fictícios se apropriado.    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.7,      maxTokens: 500    });         return response;  }   /**   * Gera análise completa do vídeo   */  private async generateCompleteAnalysis(    file: File,    scenes: Array<{ time: string; description: string }>,    transcript: string  ): Promise<string> {    const prompt = `      Analise um vídeo fictício com as seguintes características:      - Nome: ${file.name}      - Tamanho: ${(file.size / (1024 * 1024)).toFixed(2)} MB      - Tipo: ${file.type}             Cenas detectadas:      ${scenes.map(scene => `- ${scene.time}: ${scene.description}`).join('\n')}             Transcrição do áudio:      ${transcript}             Com base nessas informações, forneça:      1. Resumo geral do conteúdo do vídeo      2. Tema ou tópico principal      3. Análise do fluxo narrativo e ritmo      4. Qualidade técnica estimada      5. Público-alvo provável    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.3,      maxTokens: 1000    });         return response;  }   /**   * Extrai metadados do arquivo de vídeo   */  private async extractVideoMetadata(file: File): Promise<{    format: string;    duration?: number;    resolution?: string;    estimatedQuality?: string;  }> {    // Em uma implementação real, usaríamos a MediaInfo API    // Para esta versão, simulamos os metadados         // Extrair formato do tipo MIME    const format = file.type.split('/')[1] || 'desconhecido';         // Estimar duração com base no tamanho do arquivo    // Considerando ~1MB por minuto para vídeo de qualidade média    const estimatedDurationMinutes = file.size / (1024 * 1024);    const duration = Math.round(estimatedDurationMinutes * 60); // em segundos         // Estimar resolução com base no tamanho    let resolution = '720p';    const sizeMB = file.size / (1024 * 1024);         if (sizeMB / estimatedDurationMinutes > 15) { // >15MB por minuto      resolution = '1080p';    } else if (sizeMB / estimatedDurationMinutes < 5) { // <5MB por minuto      resolution = '480p';    }         // Estimar qualidade com base no tamanho por minuto    let estimatedQuality = 'média';    const sizePerMinute = sizeMB / estimatedDurationMinutes;         if (sizePerMinute > 15) {      estimatedQuality = 'alta';    } else if (sizePerMinute < 5) {      estimatedQuality = 'baixa';    }         return {      format,      duration,      resolution,      estimatedQuality    };  }   /**   * Formata tempo em segundos para formato MM:SS   */  private formatTime(seconds: number): string {    const minutes = Math.floor(seconds / 60);    const remainingSeconds = seconds % 60;         return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;  } }``

### src/services/media/BaseMediaProcessor.ts

`/**  * Classe base para processadores de mídia */ export abstract class BaseMediaProcessor {   /**   * Método abstrato que deve ser implementado por classes filhas   */  abstract process(file: File): Promise<{    analysis: string;    metadata?: any;  }>;   /**   * Converte um File para Data URL (Base64)   */  protected async fileToDataURL(file: File): Promise<string> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as string);      reader.onerror = error => reject(error);      reader.readAsDataURL(file);    });  }   /**   * Converte um File para ArrayBuffer   */  protected async fileToArrayBuffer(file: File): Promise<ArrayBuffer> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as ArrayBuffer);      reader.onerror = error => reject(error);      reader.readAsArrayBuffer(file);    });  }   /**   * Converte um File para texto   */  protected async fileToText(file: File): Promise<string> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as string);      reader.onerror = error => reject(error);      reader.readAsText(file);    });  }   /**   * Gera um hash simplificado para um arquivo   */  protected async generateFileHash(file: File): Promise<string> {    // Usar primeiros 1024 bytes + nome + tamanho para gerar um "hash" simples    const buffer = await this.getPartialArrayBuffer(file, 1024);    const array = new Uint8Array(buffer);         // Função hash simples    let hash = 0;    for (let i = 0; i < array.length; i++) {      hash = ((hash << 5) - hash) + array[i];      hash |= 0; // Converter para inteiro de 32 bits    }         // Combinar com nome e tamanho    hash = hash ^ file.name.length;    hash = hash ^ file.size;         // Converter para string hexadecimal    return hash.toString(16).replace('-', '');  }   /**   * Obtém os primeiros N bytes de um arquivo   */  private async getPartialArrayBuffer(file: File, bytes: number): Promise<ArrayBuffer> {    return new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onload = () => resolve(reader.result as ArrayBuffer);      reader.onerror = error => reject(error);      reader.readAsArrayBuffer(file.slice(0, bytes));    });  } }`

### src/services/messaging/MessageBus.ts

``type MessageCallback = (data: any) => void; /**  * Serviço para comunicação entre componentes */ export class MessageBus {   private static instance: MessageBus;  private subscriptions: Map<string, Set<MessageCallback>>;   private constructor() {    this.subscriptions = new Map();  }   /**   * Obtém instância única (Singleton)   */  public static getInstance(): MessageBus {    if (!MessageBus.instance) {      MessageBus.instance = new MessageBus();    }    return MessageBus.instance;  }   /**   * Publica uma mensagem em um canal   */  publish(channel: string, data: any): void {    if (!this.subscriptions.has(channel)) {      return;    }     const callbacks = this.subscriptions.get(channel)!;    callbacks.forEach(callback => {      try {        callback(data);      } catch (error) {        console.error(`Erro ao processar callback para canal ${channel}:`, error);      }    });  }   /**   * Assina um canal para receber mensagens   */  subscribe(channel: string, callback: MessageCallback): () => void {    if (!this.subscriptions.has(channel)) {      this.subscriptions.set(channel, new Set());    }     const callbacks = this.subscriptions.get(channel)!;    callbacks.add(callback);     // Retorna função para cancelar a assinatura    return () => {      this.unsubscribe(channel, callback);    };  }   /**   * Cancela uma assinatura   */  unsubscribe(channel: string, callback: MessageCallback): void {    if (!this.subscriptions.has(channel)) {      return;    }     const callbacks = this.subscriptions.get(channel)!;    callbacks.delete(callback);     if (callbacks.size === 0) {      this.subscriptions.delete(channel);    }  }   /**   * Cancela todas as assinaturas de um canal   */  clearChannel(channel: string): void {    this.subscriptions.delete(channel);  }   /**   * Cancela todas as assinaturas   */  clear(): void {    this.subscriptions.clear();  }   /**   * Verifica se um canal tem assinantes   */  hasSubscribers(channel: string): boolean {    return this.subscriptions.has(channel) && this.subscriptions.get(channel)!.size > 0;  }   /**   * Retorna o número de assinantes de um canal   */  subscriberCount(channel: string): number {    if (!this.subscriptions.has(channel)) {      return 0;    }    return this.subscriptions.get(channel)!.size;  }   /**   * Lista todos os canais ativos   */  listChannels(): string[] {    return Array.from(this.subscriptions.keys());  } }``

### src/services/cache/CacheService.ts

`type CacheItem<T> = {   value: T;  expiry?: number; }; /**  * Serviço para gerenciamento de cache */ export class CacheService<T = any> {   private cache: Map<string, CacheItem<T>>;  private defaultTTL: number;  private storageKey?: string;   constructor(options: {    defaultTTL?: number;    storageKey?: string;  } = {}) {    this.cache = new Map();    this.defaultTTL = options.defaultTTL || 3600000; // 1 hora em ms    this.storageKey = options.storageKey;         if (this.storageKey) {      this.loadFromStorage();    }  }   /**   * Armazena um item no cache   */  async set(key: string, value: T, ttl?: number): Promise<void> {    const expiry = ttl ? Date.now() + ttl : ttl === 0 ? undefined : Date.now() + this.defaultTTL;         this.cache.set(key, {      value,      expiry    });         if (this.storageKey) {      this.saveToStorage();    }  }   /**   * Recupera um item do cache   */  async get(key: string): Promise<T | null> {    if (!this.cache.has(key)) {      return null;    }         const item = this.cache.get(key)!;         // Verificar expiração    if (item.expiry && item.expiry < Date.now()) {      this.cache.delete(key);      if (this.storageKey) {        this.saveToStorage();      }      return null;    }         return item.value;  }   /**   * Remove um item do cache   */  async delete(key: string): Promise<boolean> {    const result = this.cache.delete(key);         if (result && this.storageKey) {      this.saveToStorage();    }         return result;  }   /**   * Limpa todo o cache   */  async clear(): Promise<void> {    this.cache.clear();         if (this.storageKey) {      this.saveToStorage();    }  }   /**   * Verifica se um item existe no cache e não está expirado   */  async has(key: string): Promise<boolean> {    if (!this.cache.has(key)) {      return false;    }         const item = this.cache.get(key)!;         // Verificar expiração    if (item.expiry && item.expiry < Date.now()) {      this.cache.delete(key);      if (this.storageKey) {        this.saveToStorage();      }      return false;    }         return true;  }   /**   * Atualiza o tempo de expiração de um item   */  async touch(key: string, ttl?: number): Promise<boolean> {    if (!this.cache.has(key)) {      return false;    }         const item = this.cache.get(key)!;    const expiry = ttl ? Date.now() + ttl : ttl === 0 ? undefined : Date.now() + this.defaultTTL;         this.cache.set(key, {      ...item,      expiry    });         if (this.storageKey) {      this.saveToStorage();    }         return true;  }   /**   * Remove itens expirados do cache   */  async cleanup(): Promise<number> {    const now = Date.now();    let count = 0;         for (const [key, item] of this.cache.entries()) {      if (item.expiry && item.expiry < now) {        this.cache.delete(key);        count++;      }    }         if (count > 0 && this.storageKey) {      this.saveToStorage();    }         return count;  }   /**   * Salva o cache no armazenamento local   */  private saveToStorage(): void {    if (!this.storageKey) return;         try {      const serialized = JSON.stringify(Array.from(this.cache.entries()));      localStorage.setItem(this.storageKey, serialized);    } catch (error) {      console.error('Erro ao salvar cache no armazenamento local:', error);    }  }   /**   * Carrega o cache do armazenamento local   */  private loadFromStorage(): void {    if (!this.storageKey) return;         try {      const serialized = localStorage.getItem(this.storageKey);      if (serialized) {        const entries = JSON.parse(serialized) as [string, CacheItem<T>][];        this.cache = new Map(entries);                 // Limpar itens expirados        this.cleanup();      }    } catch (error) {      console.error('Erro ao carregar cache do armazenamento local:', error);    }  }   /**   * Obtém estatísticas do cache   */  getStats(): {    total: number;    expired: number;    permanent: number;    temporary: number;  } {    const now = Date.now();    let expired = 0;    let permanent = 0;    let temporary = 0;         for (const item of this.cache.values()) {      if (item.expiry) {        if (item.expiry < now) {          expired++;        } else {          temporary++;        }      } else {        permanent++;      }    }         return {      total: this.cache.size,      expired,      permanent,      temporary    };  } }`

### src/services/monitoring/MonitoringService.ts

`/**  * Interface para eventos de monitoramento */ export interface MonitoringEvent {   type: string;  timestamp?: number;  data?: any; } /**  * Serviço para monitoramento e registro de eventos */ export class MonitoringService {   private static instance: MonitoringService;  private events: MonitoringEvent[];  private subscribers: Set<(event: MonitoringEvent) => void>;  private maxEvents: number;  private isLocalStorageEnabled: boolean;  private storageKey = 'monitoring_events';   private constructor(options: {    maxEvents?: number;    enableLocalStorage?: boolean;  } = {}) {    this.events = [];    this.subscribers = new Set();    this.maxEvents = options.maxEvents || 1000;    this.isLocalStorageEnabled = options.enableLocalStorage ?? true;         if (this.isLocalStorageEnabled) {      this.loadEventsFromStorage();    }  }   /**   * Obtém instância única (Singleton)   */  public static getInstance(options?: {    maxEvents?: number;    enableLocalStorage?: boolean;  }): MonitoringService {    if (!MonitoringService.instance) {      MonitoringService.instance = new MonitoringService(options);    }    return MonitoringService.instance;  }   /**   * Registra um evento   */  logEvent(event: Omit<MonitoringEvent, 'timestamp'>): void {    const fullEvent: MonitoringEvent = {      ...event,      timestamp: Date.now()    };         this.events.push(fullEvent);         // Limitar número de eventos armazenados    if (this.events.length > this.maxEvents) {      this.events = this.events.slice(this.events.length - this.maxEvents);    }         // Notificar assinantes    this.subscribers.forEach(subscriber => {      try {        subscriber(fullEvent);      } catch (error) {        console.error('Erro ao notificar assinante:', error);      }    });         // Salvar no armazenamento local, se habilitado    if (this.isLocalStorageEnabled) {      this.saveEventsToStorage();    }  }   /**   * Obtém todos os eventos   */  getEvents(): MonitoringEvent[] {    return [...this.events];  }   /**   * Filtra eventos por tipo   */  getEventsByType(type: string): MonitoringEvent[] {    return this.events.filter(event => event.type === type);  }   /**   * Filtra eventos por período   */  getEventsByTimeRange(startTime: number, endTime: number): MonitoringEvent[] {    return this.events.filter(event => {      const timestamp = event.timestamp || 0;      return timestamp >= startTime && timestamp <= endTime;    });  }   /**   * Assina eventos   */  subscribe(callback: (event: MonitoringEvent) => void): () => void {    this.subscribers.add(callback);         // Retorna função para cancelar assinatura    return () => {      this.unsubscribe(callback);    };  }   /**   * Cancela assinatura   */  unsubscribe(callback: (event: MonitoringEvent) => void): void {    this.subscribers.delete(callback);  }   /**   * Limpa todos os eventos   */  clearEvents(): void {    this.events = [];         if (this.isLocalStorageEnabled) {      localStorage.removeItem(this.storageKey);    }  }   /**   * Salva eventos no armazenamento local   */  private saveEventsToStorage(): void {    try {      const eventsToSave = this.events.slice(-100); // Salvar apenas os 100 mais recentes      localStorage.setItem(this.storageKey, JSON.stringify(eventsToSave));    } catch (error) {      console.error('Erro ao salvar eventos no armazenamento local:', error);    }  }   /**   * Carrega eventos do armazenamento local   */  private loadEventsFromStorage(): void {    try {      const storedEvents = localStorage.getItem(this.storageKey);      if (storedEvents) {        this.events = JSON.parse(storedEvents);      }    } catch (error) {      console.error('Erro ao carregar eventos do armazenamento local:', error);    }  }   /**   * Gera relatório de eventos   */  generateReport(): {    totalEvents: number;    eventsByType: Record<string, number>;    averageEventsPerMinute: number;    peakEventsPerMinute: number;    timeRanges: {      start: number;      end: number;      count: number;    }[];  } {    // Contagem por tipo    const eventsByType: Record<string, number> = {};    this.events.forEach(event => {      eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;    });         // Calcular eventos por minuto    const eventsByMinute: Record<number, number> = {};    this.events.forEach(event => {      if (!event.timestamp) return;             const minute = Math.floor(event.timestamp / 60000);      eventsByMinute[minute] = (eventsByMinute[minute] || 0) + 1;    });         // Calcular média e pico    const minutes = Object.keys(eventsByMinute).map(Number);    const counts = Object.values(eventsByMinute);         const totalMinutes = minutes.length;    const totalEvents = this.events.length;         const averageEventsPerMinute = totalMinutes > 0      ? totalEvents / totalMinutes      : 0;         const peakEventsPerMinute = counts.length > 0      ? Math.max(...counts)      : 0;         // Agrupar em períodos de 10 minutos    const timeRanges: {      start: number;      end: number;      count: number;    }[] = [];         if (minutes.length > 0) {      const periodSize = 10; // minutos      const startMinute = Math.min(...minutes);      const endMinute = Math.max(...minutes);             for (let period = startMinute; period <= endMinute; period += periodSize) {        const rangeStart = period * 60000;        const rangeEnd = (period + periodSize) * 60000;                 const eventsInRange = this.events.filter(event => {          const timestamp = event.timestamp || 0;          return timestamp >= rangeStart && timestamp < rangeEnd;        });                 if (eventsInRange.length > 0) {          timeRanges.push({            start: rangeStart,            end: rangeEnd,            count: eventsInRange.length          });        }      }    }         return {      totalEvents,      eventsByType,      averageEventsPerMinute,      peakEventsPerMinute,      timeRanges    };  } }`

### src/components/markdown-editor/MarkdownEditor.tsx

``import React, { useState, useEffect, useCallback } from 'react'; import { Editor } from '@monaco-editor/react'; import { Card, CardContent } from '../ui/card'; import { Button } from '../ui/button'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'; import ReactMarkdown from 'react-markdown'; import rehypeRaw from 'rehype-raw'; import rehypeHighlight from 'rehype-highlight'; import remarkGfm from 'remark-gfm'; import remarkFrontmatter from 'remark-frontmatter'; import { useDocumentProcessor } from '@/hooks/useDocumentProcessor'; import { EditorToolbar } from '../editor/EditorToolbar'; import { PreviewPane } from '../editor/PreviewPane'; import { EditorStats } from '../layout/EditorStats'; interface MarkdownEditorProps {   initialContent?: string;  onSave?: (content: string) => void;  showToolbar?: boolean;  showPreview?: boolean;  showStats?: boolean;  readOnly?: boolean; } export function MarkdownEditor({   initialContent = '',  onSave,  showToolbar = true,  showPreview = true,  showStats = true,  readOnly = false }: MarkdownEditorProps) {   const [content, setContent] = useState(initialContent);  const [activeTab, setActiveTab] = useState<string>('edit');  const [isSaving, setIsSaving] = useState(false);  const [wordCount, setWordCount] = useState(0);  const [charCount, setCharCount] = useState(0);     const { processDocument, isProcessing } = useDocumentProcessor();     // Atualizar contagens quando o conteúdo muda  useEffect(() => {    // Contar palavras    const words = content      .replace(/\s+/g, ' ')      .split(' ')      .filter(word => word.length > 0);    setWordCount(words.length);         // Contar caracteres (sem espaços)    const chars = content.replace(/\s+/g, '');    setCharCount(chars.length);  }, [content]);     // Salvar conteúdo  const handleSave = useCallback(async () => {    if (onSave) {      setIsSaving(true);      try {        await onSave(content);      } finally {        setIsSaving(false);      }    }  }, [content, onSave]);     // Processar documento  const handleProcess = useCallback(async () => {    try {      const result = await processDocument({        content,        title: 'Documento',        id: `doc-${Date.now()}`      });             console.log('Resultado do processamento:', result);    } catch (error) {      console.error('Erro ao processar documento:', error);    }  }, [content, processDocument]);     // Atalhos de teclado  useEffect(() => {    const handleKeyDown = (e: KeyboardEvent) => {      // Ctrl+S ou Cmd+S      if ((e.ctrlKey || e.metaKey) && e.key === 's') {        e.preventDefault();        handleSave();      }    };         window.addEventListener('keydown', handleKeyDown);    return () => window.removeEventListener('keydown', handleKeyDown);  }, [handleSave]);   return (    <div className="flex flex-col h-full">      {showToolbar && (        <EditorToolbar          onSave={handleSave}          onProcess={handleProcess}          isSaving={isSaving}          isProcessing={isProcessing}          readOnly={readOnly}        />      )}             <div className="flex-1 overflow-hidden">        {showPreview ? (          <Tabs value={activeTab} onValueChange={setActiveTab} className="h-full">            <TabsList className="grid w-full grid-cols-2">              <TabsTrigger value="edit">Editor</TabsTrigger>              <TabsTrigger value="preview">Visualização</TabsTrigger>            </TabsList>                         <TabsContent value="edit" className="h-[calc(100%-42px)] overflow-hidden">              <Card className="h-full border-0">                <CardContent className="p-0 h-full">                  <Editor                    height="100%"                    defaultLanguage="markdown"                    value={content}                    onChange={value => setContent(value || '')}                    options={{                      minimap: { enabled: false },                      wordWrap: 'on',                      lineNumbers: 'on',                      readOnly                    }}                    theme="vs-dark"                  />                </CardContent>              </Card>            </TabsContent>                         <TabsContent value="preview" className="h-[calc(100%-42px)] overflow-auto">              <PreviewPane content={content} />            </TabsContent>          </Tabs>        ) : (          <Card className="h-full border-0">            <CardContent className="p-0 h-full">              <Editor                height="100%"                defaultLanguage="markdown"                value={content}                onChange={value => setContent(value || '')}                options={{                  minimap: { enabled: false },                  wordWrap: 'on',                  lineNumbers: 'on',                  readOnly                }}                theme="vs-dark"              />            </CardContent>          </Card>        )}      </div>             {showStats && (        <EditorStats          wordCount={wordCount}          charCount={charCount}        />      )}    </div>  ); }``

Ainda há vários outros módulos importantes a serem descritos. Estimo que faltam aproximadamente 10 módulos para completar toda a estrutura da aplicação. Posso continuar descrevendo mais componentes e serviços em uma próxima conversa, continuando de onde paramos.

CONTINUE usando o maximo de caracteres que pode usar por conversa par incluir o maximo de modulos , comece DE ONDE PAROU AGORA E DESCREVA ABSOLUTAMENTE TODOS OS MODULOS COMO FICARAM OS CODIGOS FINAIS DA Estrutura Completa da Aplicação Estrutura de Diretórios e Arquivos COMECE DE ONDE PAROU E PROSSIGA, NÃO OMITA E NEM RESUMA ESCREVA NA INTEGRA, QUANDO CHEGAR AO FIM SE FALTAREM MODULOS ME AVIZE QUE POssO PARA CONTINUAR EM UMA NOVA CONVERSA DE ONDE PAROU e referencie em numeros quantos modulos faltam ainda

![lovable logo](https://lovable.dev/img/lovable-logo.svg)Lovable

14:38 on Mar 11, 2025

Continuarei descrevendo os módulos restantes da aplicação, seguindo de onde paramos anteriormente. Vamos prosseguir com mais componentes e serviços fundamentais.

### src/components/editor/EditorToolbar.tsx

`import React from 'react'; import { Button } from '../ui/button'; import { Separator } from '../ui/separator'; import { Save, Play, Bold, Italic, List, ListOrdered, Link, Image, RotateCcw, RotateCw, Heading1, Heading2, Heading3 } from 'lucide-react'; import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip'; interface EditorToolbarProps {   onSave?: () => void;  onProcess?: () => void;  isSaving?: boolean;  isProcessing?: boolean;  readOnly?: boolean;  onFormatClick?: (format: string) => void; } export function EditorToolbar({   onSave,  onProcess,  isSaving = false,  isProcessing = false,  readOnly = false,  onFormatClick }: EditorToolbarProps) {   const handleFormatClick = (format: string) => {    if (onFormatClick) {      onFormatClick(format);    }  };   return (    <TooltipProvider>      <div className="flex items-center p-2 bg-muted/40 border-b">        <div className="flex items-center space-x-1 mr-4">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly || isSaving}                onClick={onSave}              >                <Save className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Salvar (Ctrl+S)</TooltipContent>          </Tooltip>                     {onProcess && (            <Tooltip>              <TooltipTrigger asChild>                <Button                  variant="ghost"                  size="icon"                  disabled={isProcessing}                  onClick={onProcess}                >                  <Play className="h-4 w-4" />                </Button>              </TooltipTrigger>              <TooltipContent>Processar documento</TooltipContent>            </Tooltip>          )}        </div>                 <Separator orientation="vertical" className="h-6 mx-2" />                 <div className="flex items-center space-x-1">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('bold')}              >                <Bold className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Negrito (Ctrl+B)</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('italic')}              >                <Italic className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Itálico (Ctrl+I)</TooltipContent>          </Tooltip>        </div>                 <Separator orientation="vertical" className="h-6 mx-2" />                 <div className="flex items-center space-x-1">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('heading1')}              >                <Heading1 className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Título 1</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('heading2')}              >                <Heading2 className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Título 2</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('heading3')}              >                <Heading3 className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Título 3</TooltipContent>          </Tooltip>        </div>                 <Separator orientation="vertical" className="h-6 mx-2" />                 <div className="flex items-center space-x-1">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('bulletList')}              >                <List className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Lista com marcadores</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('numberedList')}              >                <ListOrdered className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Lista numerada</TooltipContent>          </Tooltip>        </div>                 <Separator orientation="vertical" className="h-6 mx-2" />                 <div className="flex items-center space-x-1">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('link')}              >                <Link className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Inserir link</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('image')}              >                <Image className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Inserir imagem</TooltipContent>          </Tooltip>        </div>                 <Separator orientation="vertical" className="h-6 mx-2" />                 <div className="flex items-center space-x-1">          <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('undo')}              >                <RotateCcw className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Desfazer (Ctrl+Z)</TooltipContent>          </Tooltip>                     <Tooltip>            <TooltipTrigger asChild>              <Button                variant="ghost"                size="icon"                disabled={readOnly}                onClick={() => handleFormatClick('redo')}              >                <RotateCw className="h-4 w-4" />              </Button>            </TooltipTrigger>            <TooltipContent>Refazer (Ctrl+Y)</TooltipContent>          </Tooltip>        </div>                 <div className="flex-1" />                 <div className="text-xs text-muted-foreground">          {isSaving && "Salvando..."}          {isProcessing && "Processando..."}        </div>      </div>    </TooltipProvider>  ); }`

### src/components/editor/PreviewPane.tsx

`import React from 'react'; import ReactMarkdown from 'react-markdown'; import rehypeRaw from 'rehype-raw'; import rehypeHighlight from 'rehype-highlight'; import remarkGfm from 'remark-gfm'; import remarkFrontmatter from 'remark-frontmatter'; import { Card, CardContent } from '../ui/card'; interface PreviewPaneProps {   content: string; } export function PreviewPane({ content }: PreviewPaneProps) {   return (    <Card className="h-full">      <CardContent className="p-6 h-full overflow-auto">        <div className="prose prose-sm dark:prose-invert max-w-none">          <ReactMarkdown            rehypePlugins={[rehypeRaw, rehypeHighlight]}            remarkPlugins={[remarkGfm, remarkFrontmatter]}          >            {content}          </ReactMarkdown>        </div>      </CardContent>    </Card>  ); }`

### src/components/layout/EditorStats.tsx

`import React from 'react'; interface EditorStatsProps {   wordCount: number;  charCount: number;  readingTime?: number; } export function EditorStats({   wordCount,  charCount,  readingTime }: EditorStatsProps) {   // Estimar tempo de leitura (175 palavras por minuto em média)  const estimatedReadingTime = readingTime || Math.ceil(wordCount / 175);     return (    <div className="flex items-center justify-between text-xs text-muted-foreground p-2 border-t">      <div>        <span>{wordCount} palavras</span>        <span className="mx-2">|</span>        <span>{charCount} caracteres</span>      </div>      <div>        <span>Tempo de leitura: {estimatedReadingTime} min</span>      </div>    </div>  ); }`

### src/components/explorer/FileExplorer.tsx

`import React, { useState, useCallback } from 'react'; import { useFileStore } from '@/store/fileStore'; import { FileTreeItem } from './FileTreeItem'; import { Input } from '../ui/input'; import { Button } from '../ui/button'; import { ScrollArea } from '../ui/scroll-area'; import { FileType } from '@/types/file'; import { Search, FolderPlus, FilePlus } from 'lucide-react'; import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '../ui/dialog'; import { Label } from '../ui/label'; export function FileExplorer() {   const { files, createFile, createFolder } = useFileStore();  const [searchQuery, setSearchQuery] = useState('');  const [isNewFileDialogOpen, setIsNewFileDialogOpen] = useState(false);  const [isNewFolderDialogOpen, setIsNewFolderDialogOpen] = useState(false);  const [newFileName, setNewFileName] = useState('');  const [newFolderName, setNewFolderName] = useState('');  const [selectedParentId, setSelectedParentId] = useState<string | null>(null);     // Filtrar arquivos por busca  const filteredFiles = searchQuery.trim()    ? files.filter(file =>        file.name.toLowerCase().includes(searchQuery.toLowerCase()) ||        (file.content && typeof file.content === 'string' &&         file.content.toLowerCase().includes(searchQuery.toLowerCase()))      )    : files;     // Obter arquivos de nível raiz  const rootFiles = filteredFiles.filter(file => !file.parentId);     // Manipular clique em novo arquivo  const handleNewFileClick = useCallback((parentId: string | null = null) => {    setSelectedParentId(parentId);    setNewFileName('');    setIsNewFileDialogOpen(true);  }, []);     // Manipular clique em nova pasta  const handleNewFolderClick = useCallback((parentId: string | null = null) => {    setSelectedParentId(parentId);    setNewFolderName('');    setIsNewFolderDialogOpen(true);  }, []);     // Criar novo arquivo  const handleCreateFile = useCallback(() => {    if (newFileName.trim()) {      createFile({        name: newFileName,        type: 'markdown',        content: '',        parentId: selectedParentId      });      setIsNewFileDialogOpen(false);      setNewFileName('');    }  }, [newFileName, selectedParentId, createFile]);     // Criar nova pasta  const handleCreateFolder = useCallback(() => {    if (newFolderName.trim()) {      createFolder({        name: newFolderName,        parentId: selectedParentId      });      setIsNewFolderDialogOpen(false);      setNewFolderName('');    }  }, [newFolderName, selectedParentId, createFolder]);   return (    <div className="h-full flex flex-col">      <div className="p-2 space-y-2">        <div className="relative">          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />          <Input            placeholder="Buscar arquivos..."            value={searchQuery}            onChange={e => setSearchQuery(e.target.value)}            className="pl-8"          />        </div>                 <div className="flex space-x-2">          <Button            variant="outline"            size="sm"            className="flex-1"            onClick={() => handleNewFileClick(null)}          >            <FilePlus className="h-4 w-4 mr-2" />            Novo Arquivo          </Button>                     <Button            variant="outline"            size="sm"            className="flex-1"            onClick={() => handleNewFolderClick(null)}          >            <FolderPlus className="h-4 w-4 mr-2" />            Nova Pasta          </Button>        </div>      </div>             <ScrollArea className="flex-1">        <div className="p-2">          {rootFiles.length === 0 ? (            <div className="p-4 text-center text-muted-foreground">              {searchQuery ? 'Nenhum arquivo encontrado' : 'Nenhum arquivo ou pasta criado'}            </div>          ) : (            <div className="space-y-1">              {rootFiles.map(file => (                <FileTreeItem                  key={file.id}                  file={file}                  files={filteredFiles}                  onNewFile={handleNewFileClick}                  onNewFolder={handleNewFolderClick}                />              ))}            </div>          )}        </div>      </ScrollArea>             {/* Dialog para novo arquivo */}      <Dialog open={isNewFileDialogOpen} onOpenChange={setIsNewFileDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Novo Arquivo</DialogTitle>          </DialogHeader>          <div className="space-y-4 py-2">            <div className="space-y-2">              <Label htmlFor="fileName">Nome do arquivo</Label>              <Input                id="fileName"                value={newFileName}                onChange={e => setNewFileName(e.target.value)}                placeholder="documento.md"              />            </div>          </div>          <DialogFooter>            <Button variant="outline" onClick={() => setIsNewFileDialogOpen(false)}>              Cancelar            </Button>            <Button onClick={handleCreateFile}>Criar</Button>          </DialogFooter>        </DialogContent>      </Dialog>             {/* Dialog para nova pasta */}      <Dialog open={isNewFolderDialogOpen} onOpenChange={setIsNewFolderDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Nova Pasta</DialogTitle>          </DialogHeader>          <div className="space-y-4 py-2">            <div className="space-y-2">              <Label htmlFor="folderName">Nome da pasta</Label>              <Input                id="folderName"                value={newFolderName}                onChange={e => setNewFolderName(e.target.value)}                placeholder="Nova Pasta"              />            </div>          </div>          <DialogFooter>            <Button variant="outline" onClick={() => setIsNewFolderDialogOpen(false)}>              Cancelar            </Button>            <Button onClick={handleCreateFolder}>Criar</Button>          </DialogFooter>        </DialogContent>      </Dialog>    </div>  ); }`

### src/components/explorer/FileTreeItem.tsx

``import React, { useState, useCallback } from 'react'; import { useFileStore } from '@/store/fileStore'; import { FileType } from '@/types/file'; import { Button } from '../ui/button'; import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator } from '../ui/dropdown-menu'; import { ChevronRight, ChevronDown, MoreHorizontal, File, FileText, Folder, FolderOpen, Trash, Edit, FilePlus, FolderPlus } from 'lucide-react'; import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '../ui/dialog'; import { Input } from '../ui/input'; import { Label } from '../ui/label'; import { cn } from '@/lib/utils'; interface FileTreeItemProps {   file: FileType;  files: FileType[];  level?: number;  onNewFile: (parentId: string) => void;  onNewFolder: (parentId: string) => void; } export function FileTreeItem({   file,  files,  level = 0,  onNewFile,  onNewFolder }: FileTreeItemProps) {   const { selectFile, deleteFile, renameFile } = useFileStore();  const [isExpanded, setIsExpanded] = useState(true);  const [isRenameDialogOpen, setIsRenameDialogOpen] = useState(false);  const [newName, setNewName] = useState(file.name);     // Encontrar arquivos filhos  const childFiles = files.filter(f => f.parentId === file.id);  const hasChildren = childFiles.length > 0;     // Toggle expansão  const toggleExpand = useCallback(() => {    if (file.type === 'folder') {      setIsExpanded(!isExpanded);    }  }, [file.type, isExpanded]);     // Selecionar arquivo  const handleSelect = useCallback(() => {    if (file.type !== 'folder') {      selectFile(file.id);    } else {      toggleExpand();    }  }, [file.id, file.type, selectFile, toggleExpand]);     // Renomear arquivo  const handleRename = useCallback(() => {    if (newName.trim() && newName !== file.name) {      renameFile(file.id, newName);    }    setIsRenameDialogOpen(false);  }, [file.id, file.name, newName, renameFile]);     // Excluir arquivo  const handleDelete = useCallback(() => {    deleteFile(file.id);  }, [file.id, deleteFile]);     // Renderizar ícone apropriado  const renderIcon = () => {    if (file.type === 'folder') {      return isExpanded ? <FolderOpen className="h-4 w-4" /> : <Folder className="h-4 w-4" />;    } else if (file.type === 'markdown') {      return <FileText className="h-4 w-4" />;    } else {      return <File className="h-4 w-4" />;    }  };   return (    <div>      <div        className={cn(          "flex items-center py-1 px-2 rounded-md hover:bg-muted/50 cursor-pointer",          level > 0 && `ml-${level * 2}`        )}        style={{ marginLeft: level * 12 }}      >        {file.type === 'folder' && (          <Button variant="ghost" size="icon" className="h-5 w-5 mr-1 p-0" onClick={toggleExpand}>            {isExpanded ? (              <ChevronDown className="h-4 w-4" />            ) : (              <ChevronRight className="h-4 w-4" />            )}          </Button>        )}                 {file.type !== 'folder' && <div className="w-5 mr-1" />}                 <div          className="flex items-center flex-1 rounded-md hover:bg-muted/50 py-1 px-2"          onClick={handleSelect}        >          <span className="mr-2">{renderIcon()}</span>          <span className="text-sm truncate">{file.name}</span>        </div>                 <DropdownMenu>          <DropdownMenuTrigger asChild>            <Button variant="ghost" size="icon" className="h-8 w-8">              <MoreHorizontal className="h-4 w-4" />            </Button>          </DropdownMenuTrigger>          <DropdownMenuContent align="end">            <DropdownMenuItem onClick={() => setIsRenameDialogOpen(true)}>              <Edit className="h-4 w-4 mr-2" />              Renomear            </DropdownMenuItem>                         {file.type === 'folder' && (              <>                <DropdownMenuItem onClick={() => onNewFile(file.id)}>                  <FilePlus className="h-4 w-4 mr-2" />                  Novo Arquivo                </DropdownMenuItem>                                 <DropdownMenuItem onClick={() => onNewFolder(file.id)}>                  <FolderPlus className="h-4 w-4 mr-2" />                  Nova Pasta                </DropdownMenuItem>              </>            )}                         <DropdownMenuSeparator />                         <DropdownMenuItem className="text-destructive" onClick={handleDelete}>              <Trash className="h-4 w-4 mr-2" />              Excluir            </DropdownMenuItem>          </DropdownMenuContent>        </DropdownMenu>      </div>             {/* Renderizar filhos se expandido */}      {hasChildren && isExpanded && (        <div>          {childFiles.map(childFile => (            <FileTreeItem              key={childFile.id}              file={childFile}              files={files}              level={level + 1}              onNewFile={onNewFile}              onNewFolder={onNewFolder}            />          ))}        </div>      )}             {/* Dialog para renomear */}      <Dialog open={isRenameDialogOpen} onOpenChange={setIsRenameDialogOpen}>        <DialogContent>          <DialogHeader>            <DialogTitle>Renomear {file.type === 'folder' ? 'Pasta' : 'Arquivo'}</DialogTitle>          </DialogHeader>          <div className="space-y-4 py-2">            <div className="space-y-2">              <Label htmlFor="newName">Novo nome</Label>              <Input                id="newName"                value={newName}                onChange={e => setNewName(e.target.value)}              />            </div>          </div>          <DialogFooter>            <Button variant="outline" onClick={() => setIsRenameDialogOpen(false)}>              Cancelar            </Button>            <Button onClick={handleRename}>Renomear</Button>          </DialogFooter>        </DialogContent>      </Dialog>    </div>  ); }``

### src/store/fileStore/fileStore.ts

`import { create } from 'zustand'; import { persist } from 'zustand/middleware'; import { v4 as uuidv4 } from 'uuid'; import { FileType, FileStoreState } from '@/types/file'; import { fileOperations } from './fileOperations'; export const useFileStore = create<FileStoreState>()(   persist(    (set, get) => ({      files: [],      selectedFileId: null,             // Selecionar arquivo      selectFile: (fileId: string) => {        set({ selectedFileId: fileId });      },             // Criar arquivo      createFile: (fileData: Omit<FileType, 'id' | 'createdAt' | 'updatedAt'>) => {        const newFile: FileType = {          id: uuidv4(),          ...fileData,          createdAt: new Date().toISOString(),          updatedAt: new Date().toISOString()        };                 set(state => ({          files: [...state.files, newFile],          selectedFileId: newFile.id        }));      },             // Criar pasta      createFolder: (folderData: { name: string; parentId?: string | null }) => {        const newFolder: FileType = {          id: uuidv4(),          name: folderData.name,          type: 'folder',          parentId: folderData.parentId || null,          content: null,          createdAt: new Date().toISOString(),          updatedAt: new Date().toISOString()        };                 set(state => ({          files: [...state.files, newFolder]        }));      },             // Atualizar arquivo      updateFile: (fileId: string, content: string) => {        set(state => ({          files: state.files.map(file =>            file.id === fileId              ? {                  ...file,                  content,                  updatedAt: new Date().toISOString()                }              : file          )        }));      },             // Renomear arquivo      renameFile: (fileId: string, newName: string) => {        set(state => ({          files: state.files.map(file =>            file.id === fileId              ? {                  ...file,                  name: newName,                  updatedAt: new Date().toISOString()                }              : file          )        }));      },             // Mover arquivo      moveFile: (fileId: string, newParentId: string | null) => {        set(state => ({          files: state.files.map(file =>            file.id === fileId              ? {                  ...file,                  parentId: newParentId,                  updatedAt: new Date().toISOString()                }              : file          )        }));      },             // Excluir arquivo      deleteFile: (fileId: string) => {        // Primeiro, encontrar todos os filhos (recursivamente)        const childIds = fileOperations.findAllChildIds(fileId, get().files);        const allIds = [fileId, ...childIds];                 set(state => {          // Filtrar arquivos a serem excluídos          const updatedFiles = state.files.filter(file => !allIds.includes(file.id));                     // Atualizar seleção se necessário          const newSelectedFileId = state.selectedFileId === fileId ? null : state.selectedFileId;                     return {            files: updatedFiles,            selectedFileId: newSelectedFileId          };        });      },             // Importar arquivos      importFiles: (files: FileType[]) => {        set(state => ({          files: [...state.files, ...files]        }));      },             // Exportar arquivos      exportFiles: () => {        return get().files;      },             // Obter arquivo selecionado      getSelectedFile: () => {        const { files, selectedFileId } = get();        return files.find(file => file.id === selectedFileId) || null;      }    }),    {      name: 'file-store'    }  ) );`

### src/store/fileStore/fileOperations.ts

`import { FileType } from '@/types/file'; /**  * Utilidades para operações com arquivos */ export const fileOperations = {   /**   * Encontra todos os ids de arquivos filhos (recursivamente)   */  findAllChildIds: (parentId: string, files: FileType[]): string[] => {    const childIds: string[] = [];         // Encontrar filhos diretos    const directChildren = files.filter(file => file.parentId === parentId);         // Adicionar ids de filhos diretos    directChildren.forEach(child => {      childIds.push(child.id);             // Adicionar ids de filhos recursivamente      const grandchildIds = fileOperations.findAllChildIds(child.id, files);      childIds.push(...grandchildIds);    });         return childIds;  },     /**   * Converte estrutura de arquivos em árvore   */  buildFileTree: (files: FileType[]): FileType[] => {    // Primeiro, encontrar todos os arquivos de nível raiz    const rootFiles = files.filter(file => !file.parentId);         // Função para adicionar filhos recursivamente    const addChildren = (file: FileType): FileType => {      const children = files        .filter(f => f.parentId === file.id)        .map(child => addChildren(child));             return {        ...file,        children      };    };         // Construir árvore completa    return rootFiles.map(rootFile => addChildren(rootFile));  },     /**   * Exporta arquivos para formato JSON   */  exportToJson: (files: FileType[]): string => {    return JSON.stringify(files, null, 2);  },     /**   * Exporta arquivo markdown para texto   */  exportMarkdownToText: (file: FileType): string => {    if (file.type !== 'markdown' || typeof file.content !== 'string') {      throw new Error('Arquivo não é markdown válido');    }         return file.content;  },     /**   * Procura arquivos por termo de busca   */  searchFiles: (files: FileType[], searchTerm: string): FileType[] => {    if (!searchTerm.trim()) {      return files;    }         const lowerCaseSearchTerm = searchTerm.toLowerCase();         return files.filter(file => {      // Procurar no nome      if (file.name.toLowerCase().includes(lowerCaseSearchTerm)) {        return true;      }             // Procurar no conteúdo (se for string)      if (typeof file.content === 'string' &&          file.content.toLowerCase().includes(lowerCaseSearchTerm)) {        return true;      }             return false;    });  },     /**   * Calcula estatísticas dos arquivos   */  calculateStats: (files: FileType[]): {    totalFiles: number;    totalFolders: number;    totalMarkdown: number;    totalSize: number;    avgFileSize: number;    lastUpdated: string | null;  } => {    const stats = {      totalFiles: 0,      totalFolders: 0,      totalMarkdown: 0,      totalSize: 0,      avgFileSize: 0,      lastUpdated: null as string | null    };         if (files.length === 0) {      return stats;    }         let lastUpdatedDate = new Date(0);         for (const file of files) {      if (file.type === 'folder') {        stats.totalFolders++;      } else {        stats.totalFiles++;                 if (file.type === 'markdown') {          stats.totalMarkdown++;        }                 // Estimar tamanho do conteúdo        if (typeof file.content === 'string') {          stats.totalSize += file.content.length;        }      }             // Atualizar data da última modificação      if (file.updatedAt) {        const updatedDate = new Date(file.updatedAt);        if (updatedDate > lastUpdatedDate) {          lastUpdatedDate = updatedDate;          stats.lastUpdated = file.updatedAt;        }      }    }         // Calcular tamanho médio    if (stats.totalFiles > 0) {      stats.avgFileSize = stats.totalSize / stats.totalFiles;    }         return stats;  } };`

### src/store/editorStore.ts

`import { create } from 'zustand'; import { useFileStore } from './fileStore'; interface EditorHistoryItem {   fileId: string;  content: string;  timestamp: number; } interface EditorState {   // Estado do editor  currentContent: string;  savedContent: string;  isEditorReady: boolean;  isDirty: boolean;     // Configurações  isPreviewVisible: boolean;  isToolbarVisible: boolean;  editorTheme: 'vs-dark' | 'vs-light';     // Histórico  history: EditorHistoryItem[];  maxHistoryItems: number;     // Ações  setContent: (content: string) => void;  saveContent: () => void;  resetContent: () => void;  setEditorReady: (isReady: boolean) => void;  togglePreview: () => void;  toggleToolbar: () => void;  toggleTheme: () => void;  addToHistory: (fileId: string, content: string) => void;  clearHistory: () => void; } export const useEditorStore = create<EditorState>((set, get) => ({   // Estado inicial  currentContent: '',  savedContent: '',  isEditorReady: false,  isDirty: false,  isPreviewVisible: true,  isToolbarVisible: true,  editorTheme: 'vs-dark',  history: [],  maxHistoryItems: 50,     // Setar conteúdo  setContent: (content: string) => {    set(state => ({      currentContent: content,      isDirty: content !== state.savedContent    }));  },     // Salvar conteúdo  saveContent: () => {    const { currentContent } = get();    const { selectedFileId, updateFile } = useFileStore.getState();         if (selectedFileId) {      updateFile(selectedFileId, currentContent);             set({        savedContent: currentContent,        isDirty: false      });             // Adicionar ao histórico      get().addToHistory(selectedFileId, currentContent);    }  },     // Resetar conteúdo  resetContent: () => {    set({      currentContent: '',      savedContent: '',      isDirty: false    });  },     // Definir estado de prontidão do editor  setEditorReady: (isReady: boolean) => {    set({ isEditorReady: isReady });  },     // Alternar visibilidade da visualização  togglePreview: () => {    set(state => ({ isPreviewVisible: !state.isPreviewVisible }));  },     // Alternar visibilidade da barra de ferramentas  toggleToolbar: () => {    set(state => ({ isToolbarVisible: !state.isToolbarVisible }));  },     // Alternar tema  toggleTheme: () => {    set(state => ({      editorTheme: state.editorTheme === 'vs-dark' ? 'vs-light' : 'vs-dark'    }));  },     // Adicionar ao histórico  addToHistory: (fileId: string, content: string) => {    set(state => {      const newHistoryItem: EditorHistoryItem = {        fileId,        content,        timestamp: Date.now()      };             const existingItems = state.history.filter(item => item.fileId !== fileId);             // Adicionar novo item e limitar tamanho      const newHistory = [newHistoryItem, ...existingItems].slice(0, state.maxHistoryItems);             return { history: newHistory };    });  },     // Limpar histórico  clearHistory: () => {    set({ history: [] });  } }));`

### src/types/file.ts

`export type FileType = {   id: string;  name: string;  type: 'markdown' | 'folder' | 'image' | 'other';  content: string | null;  parentId: string | null;  createdAt: string;  updatedAt: string;  children?: FileType[]; }; export interface FileStoreState {   files: FileType[];  selectedFileId: string | null;     selectFile: (fileId: string) => void;  createFile: (file: Omit<FileType, 'id' | 'createdAt' | 'updatedAt'>) => void;  createFolder: (folder: { name: string; parentId?: string | null }) => void;  updateFile: (fileId: string, content: string) => void;  renameFile: (fileId: string, newName: string) => void;  moveFile: (fileId: string, newParentId: string | null) => void;  deleteFile: (fileId: string) => void;  importFiles: (files: FileType[]) => void;  exportFiles: () => FileType[];  getSelectedFile: () => FileType | null; }`

### src/types/llm.ts

`export interface LLMCapabilities {   textCompletion: boolean;  chatCompletion: boolean;  embedding: boolean;  imageGeneration: boolean;  audioTranscription: boolean; } export interface LLMParameters {   defaultTemperature: number;  defaultMaxTokens: number;  defaultTopP: number;  defaultModel?: string; } export interface LLMUsage {   requestCount: number;  tokensUsed: number;  lastUsed: string; } export interface LLMProvider {   id: string;  name: string;  type: 'openai' | 'anthropic' | 'azure-openai' | 'custom';  apiKey: string;  models: string[];  capabilities: LLMCapabilities;  parameters?: LLMParameters;  usage?: LLMUsage; } export interface LLMServiceConfig {   defaultProvider: string;  providers: Record<string, LLMProvider>;  settings: {    maxConcurrentRequests: number;    retryAttempts: number;    timeout: number;  }; } export interface LLMStats {   requestCount: number;  successRate: number;  averageLatency: number;  costPerRequest: number;  tokensUsed: {    prompt: number;    completion: number;    total: number;  };  requestsPerDay: Record<string, number>; } export interface PipelineStep {   id: string;  providerId: string;  model?: string;  role: 'input' | 'processor' | 'output';  order: number;  systemPrompt?: string;  options?: CompletionOptions; } export interface LLMPipeline {   id: string;  name: string;  description?: string;  steps: PipelineStep[];  createdAt: string;  updatedAt: string; } export interface CompletionOptions {   model?: string;  systemPrompt?: string;  temperature?: number;  maxTokens?: number;  topP?: number;  frequencyPenalty?: number;  presencePenalty?: number; } export interface ChatMessage {   role: 'system' | 'user' | 'assistant';  content: string; } export interface ChatResponse {   id?: string;  content: string;  role?: string;  usage?: {    promptTokens: number;    completionTokens: number;    totalTokens: number;  }; }`

### src/types/media.ts

`export type MediaType = 'image' | 'audio' | 'video' | 'text' | 'markdown'; export interface MediaProcessingResult {   id?: string;  fileName?: string;  fileSize: number;  fileType: string;  processedAt: string;  type: MediaType;  analysis: string;  metadata?: {    name: string;    size: number;    type: string;    dimensions?: {      width: number;      height: number;    };    format?: string;    duration?: number;    language?: string;    resolution?: string;  };  content?: string;  transcript?: string;  sentiment?: 'positive' | 'negative' | 'neutral';  speakers?: number | string[];  objects?: string[];  tags?: string[];  description?: string;  scenes?: Array<{ time: string; description: string }>;  statistics?: {    processingTime: number;    confidenceScore: number;    complexityScore: number;    elementCount: number;    qualityScore: number;    categoryDistribution?: {      categories: Array<{        name: string;        percentage: number;      }>;      dominantCategory: string;    };    insights?: {      summary: string;      keyPoints: string[];      technicalQuality: string;      suggestedImprovements?: string[];      contentRelevance?: string;    };    performance: {      resourceUtilization: number;      efficiencyScore: number;      loadTime: number;    };  }; } export interface MediaUploaderProps {   onFileSelect?: (file: File) => void;  allowedTypes?: string[];  maxFileSize?: number;  className?: string; } export interface MediaProcessorProps {   file?: File;  onProcessingComplete?: (result: MediaProcessingResult) => void; }`

### src/hooks/useDocumentProcessor.ts

`import { useState, useCallback } from 'react'; import { Document } from '@/types/knowledge'; import { DocumentProcessor } from '@/services/document/DocumentProcessor'; import { toast } from 'sonner'; export function useDocumentProcessor() {   const [isProcessing, setIsProcessing] = useState(false);  const [processingProgress, setProcessingProgress] = useState(0);  const [currentResult, setCurrentResult] = useState<any | null>(null);  const [error, setError] = useState<string | null>(null);     const documentProcessor = new DocumentProcessor();     const processDocument = useCallback(async (    document: Document,    options?: {      includeStructure?: boolean;      includeValidation?: boolean;      includeSuggestions?: boolean;    }  ) => {    setIsProcessing(true);    setProcessingProgress(0);    setError(null);         try {      // Configurar callback de progresso      const onProgress = (progress: number) => {        setProcessingProgress(progress);      };             // Iniciar processamento      const result = await documentProcessor.process(document, {        ...options,        onProgress      });             setCurrentResult(result);      setProcessingProgress(100);             toast.success('Documento processado com sucesso');             return result;    } catch (error) {      const errorMessage = error instanceof Error        ? error.message        : 'Erro desconhecido ao processar documento';             setError(errorMessage);      toast.error('Erro ao processar documento', {        description: errorMessage      });             throw error;    } finally {      setIsProcessing(false);    }  }, [documentProcessor]);     const resetProcessor = useCallback(() => {    setIsProcessing(false);    setProcessingProgress(0);    setCurrentResult(null);    setError(null);  }, []);     return {    processDocument,    resetProcessor,    isProcessing,    processingProgress,    currentResult,    error  }; }`

### src/services/document/DocumentProcessor.ts

``import { Document, ProcessedDocument } from '@/types/knowledge'; import { DocumentStructureService } from './DocumentStructureService'; import { DocumentValidationService } from './DocumentValidationService'; import { SuggestionService } from './SuggestionService'; import { MonitoringService } from '../monitoring/MonitoringService'; import { OpenAIService } from '../ai/OpenAIService'; export class DocumentProcessor {   private structureService: DocumentStructureService;  private validationService: DocumentValidationService;  private suggestionService: SuggestionService;  private monitoringService: MonitoringService;  private openAIService: OpenAIService;     constructor() {    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;    if (!apiKey) {      throw new Error('OpenAI API key is required');    }         this.openAIService = OpenAIService.getInstance(apiKey);    this.structureService = new DocumentStructureService(this.openAIService);    this.validationService = new DocumentValidationService(this.openAIService);    this.suggestionService = new SuggestionService(this.openAIService);    this.monitoringService = MonitoringService.getInstance();  }     /**   * Processa um documento   */  async process(    document: Document,    options?: {      includeStructure?: boolean;      includeValidation?: boolean;      includeSuggestions?: boolean;      onProgress?: (progress: number) => void;    }  ): Promise<ProcessedDocument> {    // Valores padrão    const includeStructure = options?.includeStructure ?? true;    const includeValidation = options?.includeValidation ?? true;    const includeSuggestions = options?.includeSuggestions ?? true;    const onProgress = options?.onProgress || (() => {});         // Registrar início    this.monitoringService.logEvent({      type: 'document_processing_start',      data: {        documentId: document.id,        documentSize: document.content.length      }    });         try {      // Iniciar processamento      const result: ProcessedDocument = {        id: document.id,        title: document.title,        content: document.content,        processedAt: new Date().toISOString()      };             // Analisar estrutura      if (includeStructure) {        onProgress(20);        result.structure = await this.structureService.analyzeStructure(document.content);      }             // Validar documento      if (includeValidation) {        onProgress(50);        result.validation = await this.validationService.validate(document.content);      }             // Gerar sugestões      if (includeSuggestions) {        onProgress(80);        result.suggestions = await this.suggestionService.generateSuggestions(document.content);      }             // Gerar resumo      onProgress(90);      result.summary = await this.generateSummary(document.content);             // Extrair tópicos      result.topics = await this.extractTopics(document.content);             // Finalizar      onProgress(100);             // Registrar conclusão      this.monitoringService.logEvent({        type: 'document_processing_complete',        data: {          documentId: document.id,          documentSize: document.content.length,          processingTime: Date.now() - new Date(result.processedAt).getTime()        }      });             return result;    } catch (error) {      // Registrar erro      this.monitoringService.logEvent({        type: 'document_processing_error',        data: {          documentId: document.id,          error: error instanceof Error ? error.message : 'Unknown error'        }      });             throw error;    }  }     /**   * Gera resumo do documento   */  private async generateSummary(content: string): Promise<string> {    const prompt = `      Resumo o seguinte documento em um parágrafo conciso:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens    `;         return await this.openAIService.generateCompletion(prompt, {      temperature: 0.3,      maxTokens: 250    });  }     /**   * Extrai tópicos principais do documento   */  private async extractTopics(content: string): Promise<string[]> {    const prompt = `      Extraia os 3-5 tópicos ou temas principais do seguinte documento.      Retorne apenas os tópicos, um por linha, sem numeração ou marcadores:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens    `;         const response = await this.openAIService.generateCompletion(prompt, {      temperature: 0.3,      maxTokens: 250    });         // Dividir a resposta em linhas e remover linhas vazias    return response      .split('\n')      .map(line => line.trim())      .filter(line => line.length > 0);  } }``

### src/services/document/DocumentStructureService.ts

``import { DocumentStructure } from '@/types/knowledge'; import { OpenAIService } from '../ai/OpenAIService'; export class DocumentStructureService {   private openAIService: OpenAIService;     constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }     /**   * Analisa a estrutura de um documento   */  async analyzeStructure(content: string): Promise<DocumentStructure> {    const prompt = `      Analise a estrutura do seguinte documento markdown:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens             Forneça uma análise detalhada da estrutura do documento nos seguintes aspectos:      1. Título principal      2. Seções (nível e título)      3. Quantidade de parágrafos por seção      4. Listas (tipo e quantidade de itens)      5. Elementos especiais (tabelas, código, citações)      6. Relação hierárquica das seções             Responda em formato JSON estruturado seguindo este modelo:      {        "title": "Título principal",        "sections": [          {            "level": 1,            "title": "Título da seção",            "paragraphs": 3,            "lists": [              {                "type": "bullet",                "items": 5              }            ],            "specialElements": ["table", "code"]          }        ],        "hierarchy": [0, 1, 1, 2, 2, 1]      }    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.2,        maxTokens: 1000      });             // Extrair apenas o JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (!jsonMatch) {        throw new Error('Falha ao extrair estrutura do documento');      }             const jsonString = jsonMatch[0];      const structure = JSON.parse(jsonString) as DocumentStructure;             return structure;    } catch (error) {      console.error('Erro ao analisar estrutura:', error);             // Retornar estrutura básica em caso de erro      return {        title: 'Não foi possível determinar o título',        sections: [],        hierarchy: []      };    }  }     /**   * Gera um índice a partir da estrutura   */  generateTableOfContents(structure: DocumentStructure): string {    let toc = '# Índice\n\n';         if (structure.sections.length === 0) {      return toc + '*Documento sem seções*';    }         structure.sections.forEach(section => {      const indent = '  '.repeat(section.level - 1);      toc += `${indent}* ${section.title}\n`;    });         return toc;  }     /**   * Avalia o equilíbrio da estrutura do documento   */  evaluateStructureBalance(structure: DocumentStructure): {    isBalanced: boolean;    issues: string[];  } {    const issues: string[] = [];         // Verificar se há seções muito longas    structure.sections.forEach(section => {      if (section.paragraphs > 5) {        issues.push(`A seção "${section.title}" contém muitos parágrafos (${section.paragraphs})`);      }    });         // Verificar profundidade excessiva    const maxLevel = Math.max(...structure.sections.map(s => s.level));    if (maxLevel > 3) {      issues.push(`O documento tem muitos níveis de profundidade (${maxLevel})`);    }         // Verificar equilíbrio entre seções    if (structure.sections.length > 1) {      const avgParagraphs = structure.sections.reduce((sum, s) => sum + s.paragraphs, 0) / structure.sections.length;             structure.sections.forEach(section => {        if (section.paragraphs > avgParagraphs * 2) {          issues.push(`A seção "${section.title}" é desproporcionalmente longa`);        }      });    }         return {      isBalanced: issues.length === 0,      issues    };  } }``

### src/services/document/DocumentValidationService.ts

``import { DocumentValidation } from '@/types/knowledge'; import { OpenAIService } from '../ai/OpenAIService'; export class DocumentValidationService {   private openAIService: OpenAIService;     constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }     /**   * Valida um documento   */  async validate(content: string): Promise<DocumentValidation> {    const prompt = `      Analise o seguinte documento e forneça uma avaliação detalhada nos seguintes aspectos:             1. GRAMÁTICA: Identifique erros gramaticais e de pontuação.      2. COERÊNCIA: Avalie a coerência e fluidez do texto.      3. ESTRUTURA: Avalie a estrutura organizacional do documento.      4. COMPLETUDE: Identifique lacunas de informação ou explicações incompletas.             Documento:      ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens             Responda em formato JSON estruturado seguindo este modelo:      {        "grammar": {          "score": 0.85,          "issues": ["Erro 1", "Erro 2"]        },        "coherence": {          "score": 0.75,          "issues": ["Problema 1", "Problema 2"]        },        "structure": {          "score": 0.9,          "issues": ["Melhoria 1", "Melhoria 2"]        },        "completeness": {          "score": 0.7,          "issues": ["Lacuna 1", "Lacuna 2"]        },        "overallScore": 0.8,        "summary": "Resumo da avaliação"      }             Forneça avaliações detalhadas e construtivas, incluindo exemplos específicos do texto.    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.2,        maxTokens: 1000      });             // Extrair apenas o JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (!jsonMatch) {        throw new Error('Falha ao extrair validação do documento');      }             const jsonString = jsonMatch[0];      const validation = JSON.parse(jsonString) as DocumentValidation;             return validation;    } catch (error) {      console.error('Erro ao validar documento:', error);             // Retornar validação básica em caso de erro      return {        grammar: { score: 0, issues: ['Não foi possível validar gramática'] },        coherence: { score: 0, issues: ['Não foi possível validar coerência'] },        structure: { score: 0, issues: ['Não foi possível validar estrutura'] },        completeness: { score: 0, issues: ['Não foi possível validar completude'] },        overallScore: 0,        summary: 'Falha ao validar documento'      };    }  }     /**   * Corrige erros gramaticais no documento   */  async correctGrammar(content: string): Promise<string> {    const prompt = `      Corrija os erros gramaticais, ortográficos e de pontuação no seguinte texto,      mantendo o estilo e conteúdo originais:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.0,        maxTokens: 4000      });             return response;    } catch (error) {      console.error('Erro ao corrigir gramática:', error);      return content; // Retornar conteúdo original em caso de erro    }  }     /**   * Melhora a coerência do documento   */  async improveCoherence(content: string): Promise<string> {    const prompt = `      Melhore a coerência e fluidez do seguinte texto, adicionando transições      e conectivos onde necessário, mantendo o conteúdo original:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.3,        maxTokens: 4000      });             return response;    } catch (error) {      console.error('Erro ao melhorar coerência:', error);      return content; // Retornar conteúdo original em caso de erro    }  } }``

### src/services/document/SuggestionService.ts

``import { DocumentSuggestions } from '@/types/knowledge'; import { OpenAIService } from '../ai/OpenAIService'; export class SuggestionService {   private openAIService: OpenAIService;     constructor(openAIService: OpenAIService) {    this.openAIService = openAIService;  }     /**   * Gera sugestões para melhorar o documento   */  async generateSuggestions(content: string): Promise<DocumentSuggestions> {    const prompt = `      Analise o seguinte documento e forneça sugestões para melhorá-lo:             ${content.substring(0, 4000)}  // Limitar para evitar exceder limites de tokens             Forneça sugestões nas seguintes categorias:      1. CONTEÚDO: Sugestões para adicionar, remover ou modificar conteúdo.      2. CLAREZA: Sugestões para melhorar a clareza e compreensão.      3. ESTRUTURA: Sugestões para melhorar a organização e estrutura.      4. ESTILO: Sugestões para melhorar o estilo e tom do documento.             Responda em formato JSON estruturado seguindo este modelo:      {        "content": [          {            "suggestion": "Adicionar explicação sobre X",            "reason": "Motivo da sugestão",            "example": "Exemplo de implementação, se aplicável"          }        ],        "clarity": [...],        "structure": [...],        "style": [...]      }             Forneça 2-3 sugestões específicas e acionáveis para cada categoria.    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.4,        maxTokens: 1000      });             // Extrair apenas o JSON da resposta      const jsonMatch = response.match(/\{[\s\S]*\}/);      if (!jsonMatch) {        throw new Error('Falha ao extrair sugestões para o documento');      }             const jsonString = jsonMatch[0];      const suggestions = JSON.parse(jsonString) as DocumentSuggestions;             return suggestions;    } catch (error) {      console.error('Erro ao gerar sugestões:', error);             // Retornar sugestões vazias em caso de erro      return {        content: [],        clarity: [],        structure: [],        style: []      };    }  }     /**   * Aplica uma sugestão específica ao documento   */  async applySuggestion(    content: string,    suggestionType: 'content' | 'clarity' | 'structure' | 'style',    suggestionIndex: number  ): Promise<string> {    // Primeiro, gerar sugestões    const suggestions = await this.generateSuggestions(content);         // Verificar se a sugestão existe    if (!suggestions[suggestionType] ||        !suggestions[suggestionType][suggestionIndex]) {      throw new Error('Sugestão não encontrada');    }         const suggestion = suggestions[suggestionType][suggestionIndex];         // Aplicar a sugestão    const prompt = `      Aplique a seguinte sugestão ao documento:             DOCUMENTO:      ${content.substring(0, 4000)}             SUGESTÃO:      ${suggestion.suggestion}             RAZÃO:      ${suggestion.reason}             ${suggestion.example ? `EXEMPLO: ${suggestion.example}` : ''}             Por favor, retorne o documento completo modificado com a sugestão aplicada.      Mantenha todo o restante do conteúdo intacto.    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.2,        maxTokens: 4000      });             return response;    } catch (error) {      console.error('Erro ao aplicar sugestão:', error);      return content; // Retornar conteúdo original em caso de erro    }  }     /**   * Expande uma seção específica do documento   */  async expandSection(content: string, sectionTitle: string): Promise<string> {    const prompt = `      Expanda e desenvolva a seção "${sectionTitle}" no seguinte documento:             ${content.substring(0, 4000)}             Adicione mais detalhes, exemplos e explicações para enriquecer esta seção.      Retorne o documento completo com a seção expandida.      Mantenha todo o restante do conteúdo intacto.    `;         try {      const response = await this.openAIService.generateCompletion(prompt, {        temperature: 0.4,        maxTokens: 4000      });             return response;    } catch (error) {      console.error('Erro ao expandir seção:', error);      return content; // Retornar conteúdo original em caso de erro    }  } }``

### src/types/knowledge.ts

`export interface Document {   id: string;  title: string;  content: string;  tags?: string[];  createdAt?: string;  updatedAt?: string;  metadata?: Record<string, any>; } export interface ProcessedDocument extends Document {   processedAt: string;  structure?: DocumentStructure;  validation?: DocumentValidation;  suggestions?: DocumentSuggestions;  summary?: string;  topics?: string[]; } export interface DocumentStructure {   title: string;  sections: Array<{    level: number;    title: string;    paragraphs: number;    lists?: Array<{      type: 'bullet' | 'numbered';      items: number;    }>;    specialElements?: string[];  }>;  hierarchy: number[]; } export interface DocumentValidation {   grammar: {    score: number;    issues: string[];  };  coherence: {    score: number;    issues: string[];  };  structure: {    score: number;    issues: string[];  };  completeness: {    score: number;    issues: string[];  };  overallScore: number;  summary: string; } export interface DocumentSuggestions {   content: Array<{    suggestion: string;    reason: string;    example?: string;  }>;  clarity: Array<{    suggestion: string;    reason: string;    example?: string;  }>;  structure: Array<{    suggestion: string;    reason: string;    example?: string;  }>;  style: Array<{    suggestion: string;    reason: string;    example?: string;  }>; } export interface SchemaProperty {   id: string;  name: string;  type: 'string' | 'number' | 'boolean' | 'date' | 'enum' | 'array' | 'object';  description?: string;  required?: boolean;  defaultValue?: any;  enumValues?: string[];  properties?: SchemaProperty[]; // Para tipo 'object'  itemType?: string; // Para tipo 'array' } export interface PropertySchema {   id: string;  name: string;  description?: string;  properties: SchemaProperty[]; } export interface CustomKnowledge {   id: string;  name: string;  description?: string;  content: string;  tags?: string[];  properties?: Record<string, any>;  schemaId?: string;  createdAt: string;  updatedAt: string; }`