

Vou analisar a nova versão do projeto JestFly em profundidade para garantir que todas as informações estejam atualizadas e que os prompts para correção e conclusão do app sejam 100% precisos. Assim que terminar a análise, irei listar cada etapa necessária para finalizar o aplicativo com sucesso.

## Estrutura de Pastas e Arquivos

- **Root do Projeto:** Contém arquivos de configuração e dependências do projeto, por exemplo:
    - `package.json` (definição de dependências e scripts), `package-lock.json` (lock de versões), `tsconfig.json` (configuração TypeScript), `vite.config.ts` (configuração do bundler Vite), `tailwind.config.ts` (configuração do Tailwind CSS), entre outros arquivos de configuração como `.gitignore` e `eslint.config.js`.
    - `index.html` no root, servindo de página HTML principal onde o aplicativo React é montado.
- **Public/**: Arquivos estáticos públicos (ex.: `favicon.ico`, imagens como `og-image.png`, `placeholder.svg`) que podem ser referenciados diretamente.
- **src/**: Código-fonte principal da aplicação React/TypeScript.
    - **pages/**: Páginas de alto nível da aplicação, cada arquivo .tsx representa uma tela/rota. Exemplos: `Login.tsx`, `Register.tsx`, `Profile.tsx`, `Community.tsx`, `Store.tsx`, `NFTGallery.tsx`, etc. Estas páginas geralmente compõem os componentes de UI e lógica necessários para cada funcionalidade principal.
    - **components/**: Componentes reutilizáveis ou específicos de seções da aplicação, organizados por área funcional:
        - _layout/_ (layout geral, ex.: barra de navegação, rodapé, etc.),
        - _auth/_ (componentes de login/registro),
        - _community/_ (componentes de posts, comentários, feed da comunidade),
        - _store/_ (componentes da loja e carrinho),
        - _nft/_ (cartões NFT, modais de ação NFT, visores de NFT),
        - _streaming/_ (player de vídeo, chat, doações durante lives),
        - _booking/_ (formulário de agendamento, lista de bookings),
        - _canvas/_ (componentes do planejamento de carreira, ex.: lista de projetos, toolbar do canvas),
        - _admin/_ (interface de administração: gerenciamento de produtos, pedidos, usuários, etc.),
        - entre outros (como _demo/_, _wallet/_, _analytics/_, _ui/_). **Nota:** _ui/_ contém componentes genéricos básicos (botão, input, modal, etc.), possivelmente baseados em uma biblioteca (ShadCN/Radix UI).
    - **context/**: Fornece _React Contexts_ para estado global:
        - `AuthContext.tsx` gerencia estado de autenticação do usuário (usuário logado, perfil, roles).
        - `CartContext.tsx` gerencia o estado do carrinho de compras.
        - `WalletContext.tsx` gerencia dados da carteira JestCoin do usuário.
        - _auth/_ dentro de context: hooks utilitários (`useLogin`, `useRegister`, etc.) e serviços para autenticação (interagem com Supabase).
        - _canvas/_ dentro de context: provê contexto para o canvas de carreira (projetos, nós e arestas selecionados, etc. usando React Flow).
    - **hooks/**: Hooks customizados React para funcionalidades comuns, ex.: `use-toast` (exibe notificações toast), `use-error-handler` (tratamento de erro global), etc.
    - **lib/**: Biblioteca interna com serviços/funcionalidades de domínio:
        - Subpastas correspondem a domínios: _analytics_, _booking_, _community_, _demo_, _payments_, _rewards_, _store_, _streaming_, _supabase_, _wallet_, etc. Por exemplo, `lib/community/postService.ts` contém funções para criar/listar posts usando o Supabase; `lib/store/cartStore.ts` gerencia itens do carrinho; `lib/payments/paymentService.ts` integra pagamentos (via funções Supabase/Stripe); `lib/wallet/walletApi.ts` acessa dados de carteira no banco, etc.
        - Esta pasta concentra lógica de negócio relacionada a cada módulo, separando do nível de componentes.
    - **services/**: Outra pasta de serviços lógicos, possivelmente uma refatoração em andamento da **lib**. Contém código de domínio também (ex.: _nft/_, _canvas/_, _checkout/_, _store/_, etc.) com funções parecidas às da lib. Por exemplo, `services/nft/nftService.ts` para buscar NFTs, `services/canvas/*` para operações do canvas. **Observação:** A presença de `lib` e `services` indica duplicação de camadas lógicas – possivelmente código legado na lib e novos serviços em paralelo.
    - **types/**: Definições TypeScript de tipos usados no app (ex.: `types.ts`, ou subpastas como `types/nft.ts`, `types/streaming.ts`, etc.), estruturando formas de dados (ex.: interface `UserProfile`, `Post`, `NFT`, `LiveStream`, etc).
    - **utils/**: Funções utilitárias genéricas, ex.: `error-utils.ts` (tratamento de erros com try/catch), possivelmente funções de formatação, etc.
    - **integrations/**: Código de integração com serviços externos. Neste projeto há _integrations/supabase/_ com `client.ts` (configuração do cliente Supabase) e possivelmente tipos relacionados. Poderiam existir outras integrações se necessárias (ex.: com APIs de terceiros), mas no momento foca no Supabase.
    - **main.tsx** e **App.tsx**: Pontos de entrada da aplicação React. `main.tsx` monta o App no DOM, enquanto `App.tsx` configura provedores globais (AuthProvider, WalletProvider, QueryClientProvider para React Query, HelmetProvider para gerenciar ) e define as rotas usando React Router (`<Routes>` com cada `<Route>` apontando para um componente de página).
    - **index.css / App.css**: Estilos globais e resets, incluindo import do Tailwind CSS base e estilos personalizados.
    - **docs/**: Provavelmente contém documentações auxiliares ou notas de desenvolvimento (se presente).
    - **README.md** (dentro de src): Pode ser documentação específica do código (talvez desatualizada se README principal foi movido).
- **supabase/**: Contém recursos relacionados ao backend do Supabase:
    - `config.toml`: Configurações do Supabase (ex.: definindo funções Edge).
    - **functions/**: Funções serverless (Edge Functions) escritas em TypeScript para rodar no ambiente Supabase (Deno runtime). No projeto há funções como:
        - `create-payment-intent`: cria um PaymentIntent no Stripe para iniciar um pagamento.
        - `confirm-payment`: confirma o status de um PaymentIntent (consulta o Stripe para ver se pagamento foi concluído).
        - `webhook-stripe`: um webhook para receber eventos do Stripe (ex.: confirmação de pagamento bem-sucedido ou falhado, para atualizar status de pedidos no banco).
        - `create-demo-users`: popula o banco com usuários demo (provavelmente para ambiente de demonstração, usando uma chave secreta admin).
    - Essas funções interagem com Stripe (via API key segura) e com o Supabase (usando a service_role key), realizando lógica sensível de backend fora do cliente (importante para segurança de pagamentos e operações administrativas).
- **Outros arquivos importantes**:
    - `components.json`: Possivelmente um arquivo de configuração para geração/instalação de componentes UI (por ex., pode estar relacionado ao ShadCN UI para registrar quais componentes Radix foram usados).
    - `postcss.config.js`: Configuração do PostCSS (usado pelo Tailwind CSS).
    - `tsconfig.app.json` e `tsconfig.node.json`: Configurações TypeScript específicas para aplicação e Node (talvez não muito usadas se o projeto roda inteiramente no browser, a não ser para distinguir compilações).
    - `bun.lockb`: Arquivo de lock do gerenciador **Bun** – sugere que em algum momento usaram Bun para instalar ou rodar o projeto. Entretanto, o uso concomitante de `package-lock.json` indica que Node/npm também é usado. Provavelmente o projeto pode ser rodado com Node (Vite) e bun.lockb ficou obsoleto ou é opcional.

## Propósito de Cada Módulo e Funcionalidade Implementada

- **Autenticação (Auth)**: Permite cadastro e login de usuários (perfis de artista, fã, colaborador, admin). Implementado via Supabase Auth – o usuário pode registrar-se com email/senha, login, e reset de senha. O `AuthContext` mantém o estado do usuário logado e suas informações de perfil (como tipo de perfil para permissões). Componentes como `Login.tsx`, `Register.tsx`, `ResetPassword.tsx` fornecem as telas de autenticação. Hooks utilitários (`useLogin`, `useRegister`, `useLogout`, etc.) chamam funções em `lib/supabase/auth.ts` que usam `supabase.auth` internamente. **Funcionalidades**: login/logout, registro de conta com dados adicionais (nome de usuário, tipo de perfil), recuperação de senha via email. Provavelmente suporta verificação de email padrão do Supabase. Atualmente, o sistema de autenticação básica está funcionando usando credenciais tradicionais (e-mail e senha) e guarda o usuário atual no contexto global.
- **Comunidade (Community)**: Módulo de interação social entre usuários (artistas e fãs). Inclui:
    - **Posts e Feed:** Usuários (especialmente artistas) podem criar posts (atualizações, notícias, etc.). Os fãs podem visualizar um feed de posts na página `Community.tsx` e detalhar um post em `CommunityPost.tsx`. Os componentes (`CreatePostModal`, `PostList`, `PostItem`) permitem criar novos posts e listar posts existentes.
    - **Comentários e Curtidas:** Em cada post, fãs podem comentar (há componente `CommentList` e formulário) e curtir posts. Serviços em `lib/community/` como `postService.ts`, `commentService.ts`, `likesService.ts` gerenciam operações no Supabase (inserir um post na tabela posts, inserir/remover curtida na tabela post_likes, adicionar comentário na tabela comments, etc.). Essas funções retornam dados atualizados para re-renderizar a UI.
    - **Seguir usuários:** Provavelmente permite que fãs sigam artistas ou vice-versa, via `followService.ts` (inserindo registros em tabela user_follows). Isso pode influenciar o feed (ex.: ver posts apenas de artistas seguidos, ou notificar novos posts).
    - **Notificações da Comunidade:** Existe página `CommunityNotifications.tsx` possivelmente exibindo notificações (novos seguidores, curtidas ou comentários em seus posts, etc.). O `notificationService.ts` centraliza envio/recebimento de notificações (pode inserir notificação no DB quando há interações, embora a implementação exata dependa de como Supabase triggers ou lógica no client foram feitas).
    - **Explorar comunidade:** Página `CommunityExplore.tsx` possivelmente permite descobrir novos artistas ou posts populares, com busca (há componentes de busca da comunidade).
    - **Perfil da comunidade:** `CommunityProfile.tsx` pode mostrar o perfil público de um usuário (artista ou fã), incluindo seus posts, seguidores, etc.
    - A funcionalidade de comunidade está **parcialmente implementada**: criação de posts, comentários e curtidas via supabase está funcional. A assinatura em tempo real (`subscribeToPostUpdates` via Supabase Realtime) sugere que os posts novos possam aparecer em tempo real no feed (ou requer refresh manual, dependendo da implementação). O básico de seguir usuários existe. Notificações podem estar simples (talvez apenas listadas se usuário checar, sem push).
- **Envio de Demos (Demo Submission)**: Uma plataforma onde fãs enviam material (músicas demo) para artistas avaliarem:
    - A página `DemoSubmission.tsx` parece ser onde um fã pode enviar uma música demo a um artista para feedback. Deve haver um formulário (`DemoBasicInfo`, `ArtistProfile` etc. dentro de `components/demo/form/`) coletando detalhes da música (título, gênero, link ou upload de arquivo de áudio via Supabase Storage), e possivelmente uma seleção de artista de destino.
    - Artistas podem então ouvir e dar feedback. Há componentes de **feedback** (ex.: `FeedbackForm.tsx` onde o artista pode escrever uma resposta ou avaliação). O demo pode passar por status (pendente, em avaliação, aprovado, rejeitado) — esse workflow é mencionado e possivelmente controlado via colunas no banco (um serviço `demoService.ts` gerenciaria criação de registro de demo, `feedbackService.ts` salvaria feedback, etc.).
    - Possível existência de **categorias de demo** (`categoryService.ts` para gerenciar categorias/gêneros) e **armazenamento** (`storageService.ts` provavelmente faz upload do arquivo de áudio para Supabase Storage).
    - **Implementação**: O sistema de envio de demos está implementado no básico — permitir que um fã envie uma demo com dados e possivelmente upload, e listar essas submissões para que artistas visualizem. O feedback simples (texto) está implementado. No entanto, funções avançadas como múltiplos critérios de avaliação, visualização de waveform de áudio, comentários em pontos específicos do áudio etc. podem estar pendentes (conforme planejado, mas ainda não codificado).
- **NFT Marketplace**: Módulo que simula compra, venda e exibição de NFTs dentro da plataforma:
    - **NFT Gallery & Collections:** Páginas como `NFTGallery.tsx` mostram todos os NFTs disponíveis (provavelmente puxando de uma tabela `nfts` no Supabase, com campos como nome, imagem, dono, coleção, etc.). `NFTCollections.tsx` e `NFTCollection.tsx` lidam com agrupamentos de NFTs por coleção (conjuntos temáticos ou de um artista).
    - **NFT Detail:** Em `NFTDetail.tsx`, o usuário vê detalhes de um NFT específico (imagem, descrição, histórico de transações, proprietário atual, etc.). Componentes associados (`NFTViewer`, `NFTActionButtons`) exibem a mídia (imagem ou vídeo) e fornecem ações como **comprar** ou **fazer oferta**.
    - **Mintagem (Mint) de NFT:** Página `NFTMint.tsx` permite que um artista crie (mint) um novo NFT, fornecendo nome, imagem (upload?) e possivelmente atributos. Ao mintar, um registro é inserido no DB e possivelmente um registro simulado de transação de mint.
    - **Backend NFT (simulado):** O projeto inclui `services/nft/blockchainService.ts` que **simula** funcionalidades de blockchain, como gerar hashes de transação, endereços de carteira, e retornar dados fictícios de histórico de transações e metadata de contratos. Isso indica que, até o momento, **não há integração com uma blockchain real** – o sistema está operando com dados mock para demonstrar comportamento (por exemplo, imagens dos NFTs usam um placeholder gerado, e transações são aleatórias). Os serviços NFT no front (`fetchNFTs`, `fetchNFTById` em `nftService.ts`) consultam o Supabase para obter os NFTs e coleções, e utilizam `blockchainService` apenas para enriquecer com histórico simulado.
    - **Status:** A interface de marketplace NFT está implementada (listas, detalhes, ações simuladas). Entretanto, funcionalidades completas como compra/venda real podem estar apenas simuladas. Pode ser possível “fingir” uma compra (transferindo propriedade no banco) e ver o histórico simulado, mas integração com pagamento real ou contratos reais ainda não foi feita. Testes unitários (`collectionService.test.ts`, `nftService.test.ts`) existem para garantir que as funções de listagem e filtro funcionem corretamente.
- **Loja de Produtos & Pagamentos (Store & Payments)**: Um módulo de e-commerce tradicional dentro da plataforma:
    - **Catálogo de Produtos:** Página `Store.tsx` mostra categorias e produtos disponíveis (por exemplo, merchandise do artista, itens digitais). `StoreSidebar` e `CategoryTabs` permitem filtrar por categoria. Produtos são provavelmente armazenados em uma tabela `products` no Supabase, e carregados via serviço (`lib/store/productService.ts` ou `services/store/productService.ts`) com funções `getProducts`, `getProductById`, etc. Há também `getFeaturedProducts` e possivelmente destaque para alguns itens.
    - **Detalhe do Produto:** `StoreProduct.tsx` exibe detalhes de um item selecionado (imagens, descrição, preço).
    - **Carrinho de Compras:** Gerenciado pelo `CartContext` (itens adicionados ficam em estado global). Usuário pode adicionar produtos ao carrinho (existe componente `AddToCartButton` possivelmente) e ver o carrinho e subtotal.
    - **Checkout:** `StoreCart.tsx` mostra os itens do carrinho; `StoreCheckout.tsx` coleta informações do comprador (endereços, pagamento). Formulários de checkout (`PersonalInfoForm.tsx`, `ShippingAddressForm.tsx`) recolhem dados necessários.
    - **Pedidos:** Ao confirmar compra, cria-se um pedido (order) no sistema. O `checkoutService.ts` coordena essa operação: chama `orderService.createOrder` para inserir um registro de pedido no DB (contendo usuário, total, status "pending"), registra os itens do pedido via `createOrderItems`, e então inicia o pagamento via `paymentProcessingService.processOrderPayment`.
    - **Pagamento (Stripe Integration):** A plataforma está integrada com **Stripe** para pagamentos reais. O `paymentService.ts` (em lib/payments) utiliza as **Funções Supabase**: ele invoca `supabase.functions.invoke('create-payment-intent')` enviando valor, moeda, ID do pedido e do cliente. Essa função edge, no backend, cria via Stripe um Payment Intent e retorna `clientSecret` e ID do intent. Em seguida, o front possivelmente usa o Stripe.js (não vi explicitamente, mas provavelmente integrado) ou redireciona para uma interface de pagamento. Após pagamento, o Stripe webhook (`webhook-stripe` função) atualiza o pedido no DB para status pago. Além disso, há função `confirm-payment` que o cliente pode chamar para verificar o status do PaymentIntent após o pagamento (caso o fluxo precise confirmação manual).
    - **Pós-pagamento:** A página `StoreOrders.tsx` pode listar os pedidos do usuário e seus status (pedidos concluídos, pendentes). Admins também têm interface para ver todos os pedidos (`OrderManagement.tsx`).
    - **Outras funcionalidades da loja:** Avaliações de produto (`ProductReviews.tsx`, `ProductRating.tsx`) para usuários deixarem feedback nos produtos; sistema de produtos relacionados (`relatedProductsService.ts` sugere itens similares); entrega de produtos digitais (`digitalProductService.ts` cuidaria de liberar download de conteúdo digital após compra); notificações de status de pedido (`notificationService.ts` envia aviso de confirmação de compra bem-sucedida, e-mails, etc.).
    - **Status:** O fluxo básico de compra está implementado e **funcionando**: é possível adicionar ao carrinho, fazer checkout, e processar pagamento real via Stripe. A criação e atualização de pedidos no banco está configurada via as funções e serviços correspondentes. Funcionalidades complementares como avaliações, recomendação de produtos e entregas digitais podem estar parcialmente implementadas ou esboçadas e ainda requerem finalização.
- **JestCoin & Carteira (Wallet)**: Sistema de moeda digital interna e recompensas:
    - **JestCoin:** É uma moeda virtual usada dentro da plataforma (não necessariamente uma criptomoeda real, mas um sistema de pontos). Os usuários têm carteiras associadas (tabela `wallets` no DB) com saldo de JestCoins.
    - **Carteira do Usuário:** A página `Wallet.tsx` provavelmente mostra o saldo atual do usuário, histórico de transações, e opções como transferir moedas ou resgatar recompensas. O `WalletContext` mantém dados atualizados da carteira do usuário logado.
    - **Transferências:** Usuários podem enviar JestCoins uns aos outros (por exemplo, fãs dão “gorjetas” a artistas). O `TransferForm.tsx` e serviço `transferService.ts` tratam de debitar e creditar saldos via Supabase (provavelmente inserindo uma transação em tabela `transactions` e atualizando as wallets).
    - **Recompensas (Rewards):** Há menção de um sistema de recompensas e afiliados:
        - _Airdrops:_ `AirdropTaskList.tsx` sugere tarefas que, se concluídas (ex.: seguir X artistas, compartilhar algo), dão direito a um airdrop de JestCoins. `rewardsService.ts` cuidaria da lógica de conceder moedas por atividades (login diário, participação, etc.).
        - _Programa de Afiliados:_ `AffiliateProgram.tsx` indica um sistema onde usuários convidam outros e ganham recompensas. Isso requer geração de códigos de referência e recompensas automáticas quando novos usuários se cadastram usando o código.
        - _Níveis e Conquistas:_ Provavelmente planejado (gamificação onde usuários sobem de nível conforme acumulam JestCoins ou completam ações).
    - **Administração do JestCoin:** Admins podem necessitar ajustar saldos ou conferir fraudes – há componente `UserWalletManagement.tsx` possivelmente para admins consultarem wallets de usuários e forçar ajustes se necessário.
    - **Status:** O básico da carteira funciona – usuários têm saldo e podem fazer transações internas (há APIs para buscar wallet, transferir). A integração com outras partes existe: ex. possivelmente usar JestCoin para comprar produtos ou doar em streams (a especificação do projeto sugere doações durante lives). Recursos avançados (tarefas de recompensa automatizadas, sistema de conquistas, gestão administrativa) parecem estar em grande parte **por implementar**. Alguns componentes de UI estão lá mas a lógica pode não estar completa.
- **Planejamento de Carreira (Career Canvas)**: Uma funcionalidade inovadora onde artistas podem planejar visualmente sua carreira como um **canvas** interativo, e possivelmente fãs podem visualizar:
    - **Canvas de Projetos:** Representado nas páginas `CareerDashboard.tsx` (lista de projetos/canvas existentes) e `CareerCanvas.tsx` (tela principal do canvas para um projeto de carreira específico). Os artistas podem criar um “projeto de carreira” que consiste em objetivos (nós) e conexões (arestas) representando passos ou metas em sua trajetória.
    - **React Flow:** Sob o capô, usa-se a biblioteca React Flow para a interface drag-and-drop de nós e conexões. O `CanvasContext` e hook `useCareerCanvas` gerenciam estado dos nós, arestas e seleção, integrando com React Flow’s state handlers (`onNodesChange`, `onConnect`, etc.).
    - **Nós e Arestas:** Cada nó pode representar um marco (por ex., “Lançar EP”, “Assinar com gravadora”) e as arestas representam dependências ou sequência. Componentes como `CanvasContainer`, `Toolbar`, `ElementEditDialog` permitem adicionar/editar nós e ligar uns aos outros. O timeline lateral (`TimelineNodes` possivelmente) permite visão linear desses marcos.
    - **Salvar/Persistir:** O `canvasService` (em `services/canvas/` ou `lib/canvas/`) oferece funções para salvar o estado do canvas no Supabase (tabelas como `projects`, `nodes`, `edges`). Por exemplo, `nodesApi.ts` e `edgesApi.ts` contêm chamadas ao Supabase para CRUD de nós/arestas. Assim, um artista pode montar seu plano e salvar, podendo retomar depois.
    - **Status:** A funcionalidade de canvas está em grande parte implementada: é possível criar projetos de carreira, adicionar nós/arestas e salvá-los. A interface gráfica está funcional (arrastar nós, alternar exibição de timeline, etc.). Melhorias futuras poderiam incluir templates de carreira, colaboração em tempo real no canvas ou mais atributos nos nós (percentual completo, datas). Atualmente, cumpre o básico de planejamento visual com persistência.
- **Streaming ao Vivo (Live Stream)**: Módulo para streaming de vídeo ao vivo dentro da plataforma:
    - **Canais e Eventos de Live:** Artistas teriam canais de live stream (tabela `stream_channels`). Eles podem agendar transmissões (tabela `streams` ou similar para eventos com data/hora futura). A página `LiveStreamHub.tsx` mostra, para um usuário logado, seu próprio canal (se artista) e a lista de streams agendados ou ativos. Também provê descoberta de outros streams (um campo de busca por canais).
    - **Assistir Live:** Página `LiveStream.tsx` seria usada para assistir a um stream ao vivo. Inclui o componente `StreamPlayer` (que usa HLS.js para reproduzir um vídeo HLS) e possivelmente componentes de chat e doação.
    - **Player de Vídeo:** `StreamPlayer.tsx` está preparado para conectar a um URL HLS (formato de streaming de vídeo segmentado) usando Hls.js – indica que o sistema espera um endpoint de streaming (talvez uma URL de vídeo gerada quando o artista inicia o stream). Como não há servidor de streaming implementado no projeto, pode ser que os streams sejam simulados ou reproduzidos de uma fonte externa (ex.: link m3u8 pré-gravado) para demonstrar a funcionalidade.
    - **Chat em Tempo Real:** O componente `ChatInterface.tsx` sugere um chat para cada live. Idealmente isso usaria o Supabase Realtime ou outro serviço para permitir que espectadores e o artista troquem mensagens ao vivo. Pode não estar finalizado; é provável que a estrutura de UI esteja lá, mas a lógica de escuta/envio de mensagens (via canal WebSocket do Supabase ou outra tecnologia) precise ser implementada.
    - **Doações (Tips) nas Lives:** Componente `DonationPanel.tsx` indica que espectadores podem enviar doações durante a transmissão. Essas doações podem ser em JestCoins ou via Stripe. Dado o ecossistema, é provável que optem por JestCoin para doação instantânea (transferindo moedas para o artista em tempo real). O painel permite escolher um valor e enviar – a implementação precisa integrar com o sistema de carteira (uma transferência de carteira do fã para a do artista, gerando notificação).
    - **Status:** A infraestrutura de lives está parcialmente implementada. É possível listar canais e streams agendados (fetch via Supabase). O player de vídeo HLS funciona se houver um URL; no entanto, a parte de geração desse stream não está resolvida dentro do projeto (exige um servidor ou serviço externo de streaming ao vivo, que não consta aqui). O chat e doações estão esboçados na UI, mas necessitam da lógica em tempo real para funcionar. Portanto, o módulo de streaming requer integração adicional para ser totalmente funcional, embora a base (UI e modelagem no banco) esteja pronta.
- **Administração e Analytics (Admin Dashboard)**: Funcionalidades reservadas a administradores para gerenciar a plataforma, bem como análise de dados:
    - **Dashboard Admin:** Página `AdminDashboard.tsx` provavelmente serve de container para várias subseções administrativas. Pelo código, importa componentes como `ProductManagement`, `OrderManagement`, etc., e configura rotas internas de admin.
        - _Gerenciamento de Produtos:_ Permite admins criarem, editarem ou removerem produtos na loja (componentes com formulários para nome, preço, estoque, etc.). Conecta-se ao `productService` para atualizar o banco.
        - _Gerenciamento de Pedidos:_ Lista todos os pedidos feitos na plataforma, com status, e talvez permite atualizar status (ex.: marcar como enviado, reembolsado).
        - _Gerenciar Usuários/Carteiras:_ Admins podem listar usuários, talvez promover a roles diferentes, ou inspecionar wallets (`UserWalletManagement.tsx` mostra busca de usuários e detalhes de saldo, possivelmente permitindo ajustar saldo ou banir usuários abusivos).
        - _Gerenciar Conteúdo:_ Embora não explícito no nome dos componentes, espera-se ferramentas para moderar posts da comunidade ou demos (ex.: remover conteúdo impróprio, aprovar demos pendentes).
    - **Analytics:** Página `Analytics.tsx` dá aos admins (ou usuários autorizados) uma visão geral de métricas:
        - _Estatísticas Gerais:_ `StatsGrid` pode mostrar números como total de usuários, posts, vendas, etc., via `getDashboardStats` (que consulta várias tabelas no Supabase para contar registros).
        - _Gráficos de Tendência:_ `OverviewCharts` e tabs como `UsersTab` indicam gráficos de séries temporais (usando dados de `getTimeSeriesData`). Isso permitiria visualizar crescimento de usuários ao longo do tempo, vendas por mês, etc.
        - _Filtros e Detalhes:_ Há uso de um componente Tabs para alternar entre visões (Usuários, Conteúdo, Finanças, etc.). Podem existir filtros de período (última semana, mês, etc.).
        - Esses dados provavelmente são gerados via consultas no Supabase (agrupamentos por data, etc.). Se não há funções definidas para isso, pode ser que estejam retornando dados estáticos ou calculando no client, o que pode ser ineficiente para grandes volumes.
    - **Status:** O admin dashboard básico e analytics **estão parcialmente funcionais**. É possível que o admin consiga ver e editar produtos e ver pedidos. As estatísticas principais podem aparecer (se implementaram queries no Supabase). Muitas funcionalidades de moderação e controles avançados ainda não aparecem implementadas (por ex., não vi um componente explícito para moderação de posts, mas isso poderia ser feito reaproveitando componentes de comunidade dentro de uma visão admin). O sistema de analytics provavelmente mostra contagens simples; funcionalidades mais avançadas (filtros customizados, gráficos interativos, exportar dados) parecem não implementadas ainda.

## Erros, Falhas de Lógica e Código Obsoleto/Redundante

- **Duplicação de Código em _lib/_ vs _services/_:** Há clara redundância entre a pasta `src/lib` e `src/services`. Muitos domínios têm implementação duplicada ou paralela em ambos locais (por exemplo, `lib/canvas/canvasService.ts` e `services/canvas/canvasService.ts` fazem coisas similares; `lib/store` e `services/store` ambos têm lógica de produtos; supabase client definido em `lib/supabase` e também em `integrations/supabase`). Essa duplicação pode levar a inconsistências e dificuldade de manutenção – é provável que partes do código estejam obsoletas (talvez `lib` seja versão antiga) ou que a refatoração para `services` não foi concluída. **Correção:** escolher uma única abordagem (possivelmente consolidar tudo em `services/` ou em `lib/`) e remover código redundante para evitar confusão.
- **Componentes e Arquivos Legados de Teste/Dev:** Existem arquivos como `CareerCanvasTest.tsx` e pasta `components/test/` com utilitários de teste. Também o uso do arquivo `README2.md` com prompts sugere que parte do desenvolvimento foi orientado por IA. Esses artefatos de teste (como páginas não usadas na navegação real, e código temporário) são obsoletos para a versão final. **Possível problema:** Se `CareerCanvasTest` for acessível, pode expor dados de debug ou causar confusão. Deve-se removê-los antes da produção.
- **Falta de Verificação de Permissões em Algumas Rotas/Funcionalidades:** Embora o sistema tenha o conceito de perfil de usuário (admin, artista, fã), não se vê clara implementação de guardas de rota ou checagem de permissões no front-end. Por exemplo, qualquer usuário logado poderia potencialmente acessar `AdminDashboard` via URL, já que as rotas estão definidas sem restrição explícita, e o código do AdminDashboard não deixou evidente uma restrição por tipo de perfil (pode haver uma checagem leve, mas não estava clara). Isso é uma falha de lógica de segurança – **risco:** usuários não-admin acessando telas ou ações restritas. Será necessário implementar proteção de rotas (no router ou dentro dos componentes, redirecionando se não autorizado) e, no backend (Supabase), assegurar regras RLS adequadas nas tabelas para que apenas admins possam alterar certas coisas.
- **Validações e Tratamento de Erros Incompletos:** Em diversas operações (envio de formulários, chamadas ao Supabase), há tentativa de tratar erros (muitos try/catch e uso de `useErrorHandler`). No entanto, algumas áreas podem não validar suficientemente entrada do usuário. Por exemplo, no formulário de registro, é esperado verificar força de senha ou formato de email (Supabase provavelmente já rejeita email inválido, mas não há confirmação de senha implementada aparentando). Outro exemplo: nos formulários de checkout, pode faltar validação robusta de campos de endereço, ou no de transferência de JestCoin, não limitar para saldo disponível. **Falhas de lógica potencial:** se inputs não forem validados, podem ocorrer erros ou dados inconsistentes (ex.: agendar booking em data passada, valor de doação negativo, etc.). É recomendável adicionar validações de frontend (e backend quando possível) para todas entradas críticas.
- **Uso Parcial de Ferramentas de Estado (React Query):** Vejo que foi adicionado `@tanstack/react-query` (QueryClientProvider no App.tsx), mas nas páginas o padrão ainda é usar hooks custom e state local para buscar dados (ex.: useEffect chamando funções de lib diretamente). Pode ser que react-query esteja subutilizado ou implementado apenas em algumas chamadas. Essa inconsistência pode levar a padrões duplicados de fetching e falta de cache unificado. Não é exatamente um _bug_, mas é um aspecto a otimizar – ou usar React Query para todas operações assíncronas de dados ou removê-lo se não for usar, para evitar complexidade desnecessária.
- **Placeholders e Funcionalidades Simuladas não substituídos:** Certos módulos usam dados simulados em vez da implementação real:
    - Ex.: NFT utiliza imagens placeholders e transações mockadas; Streaming não conecta a um servidor real; Analytics podem estar usando números estáticos. Se o produto final exigir essas funcionalidades de verdade, manter mocks seria inadequado. Isso pode ser visto como “código provisório” que se torna obsoleto quando a implementação real entrar. **Risco:** se esquecidos, esses mocks podem enganar os usuários (ex.: mostrar um NFT como “vendido” quando na verdade nada aconteceu, ou estatísticas que não batem com a realidade).
    - Necessário planejar a substituição dessas partes simuladas por integrações concretas ou fontes de dados reais antes do lançamento, ou pelo menos deixá-las bem indicadas como demo se for proposital.
- **Possíveis Problemas de Sincronização e Consistência:** Algumas funcionalidades complexas (ex.: checkout, bookings) envolvem múltiplos passos e estado global. É crucial garantir que os fluxos estejam bem sincronizados. Por exemplo, no checkout: criar pedido, depois pagamento, depois confirmar pedido – se algo falhar no meio, existe rollback ou feedback ao usuário? Atualmente, se a função de pagamento falhar, o código lança erro mas não está claro se limpa o pedido “pendente” criado. Isso pode deixar registros incoerentes (pedidos não pagos presos no sistema). Similar para bookings: se envolver pagamento ou notificações, falhas parciais podem causar estados inválidos. Esses fluxos precisam de tratamento de erro transacional (compensar ou permitir retentar de forma segura).
- **Erros Menores de Lógica:** Não foram identificados erros óbvios de sintaxe ou chamadas inexistentes na análise estática, porém alguns pontos a verificar:
    - Funções que retornam dados sem garantir que existam (por ex., assumem sempre que supabase retorna `data` não-nulo) – isso pode quebrar se consulta não retornar resultado. Deve-se adicionar checagem após consultas .single() ou .select() sem resultados.
    - Componentes que não tratam estado de loading/erro adequadamente. Vi que muitas páginas usam `useState` e `useEffect` para fetch e mostram loaders condicionalmente (`isLoading`). Contudo, importante revisar se todos casos de erro exibem mensagem (talvez usando `ErrorDisplay` component).
    - Console logs deixados no código (`console.log("Registrando usuário:", email)` etc.). Isso é trivial, mas pode expor informações no console do navegador. Esses logs deviam ser removidos ou transformados em logs estruturados somente no ambiente dev.
- **Código Obsoleto ou Não Utilizado:** Além dos duplicados já mencionados, pode haver trechos não usados:
    - Ex.: `supabase/functions/create-demo-users` – após popular dados de demo, em produção essa função não teria uso frequente (talvez só em staging). Ela requer uma senha secreta para rodar, então não é um bug, mas é código “dormindo” pós desenvolvimento.
    - Algumas partes do CSS ou componentes genéricos (talvez do ShadCN UI) que acabaram não sendo utilizados podem ser limpos para reduzir bundle.
    - O arquivo `bun.lockb` indica experimento com outro runtime; isso não afeta a execução, mas confunde – preferível removê-lo se decidirem usar apenas npm/Yarn, para clareza.
- **Potenciais Questões de Segurança:** Além das permissões já citadas, outras a considerar:
    - As funções Edge usam chaves secretas obtidas via `Deno.env` – ok. No front, a chave pública do Supabase está exposta (normal para supabase). Porém, se alguma lógica sensível foi acidentalmente deixada no cliente (ex.: verificações de admin via campo no JWT em vez de RLS), isso seria falha. Deve-se garantir que toda segurança crítica (como restrição de operações) esteja no lado servidor/RLS.
    - Sanitização de conteúdo: usuários podem postar texto (posts, comentários, chat). Atualmente não vejo sanitização de input HTML/JS, mas é importante evitar XSS – provavelmente a UI não interpreta HTML nos posts, mas convém verificar ou sanitizar.
    - Rate limiting: se funções como likePost ou transferCoins forem chamadas repetidamente, há proteções contra spam? Por enquanto não há indicação de limites, algo a pensar (mas talvez supabase possa gerenciar até certo ponto).

Em resumo, os principais problemas identificados residem em **dívida técnica** (código duplicado, partes inacabadas ou simuladas), **lacunas de segurança/permissões**, e **detalhes de robustez** (validações, tratamentos de erro). Não há erros de execução evidentes, mas sim áreas que precisam refinamento antes da conclusão.

## O que Já Está Funcionando Corretamente

- **Autenticação Básica:** O fluxo de cadastro, login e logout via Supabase funciona. Usuários podem criar contas, iniciar sessão e recuperar senha. A integração com o contexto garante que páginas possam obter o usuário atual (`useAuth`) e mostrar conteúdo condicionalmente (por ex., exibir nome do usuário logado, ou proteger rotas cliente vs. não logado de forma básica). Ou seja, a base de gerenciamento de usuários está sólida com o Supabase Auth.
- **Feed de Comunidade e Interações:** A funcionalidade essencial da comunidade – postar conteúdo e reagir – está presente. Artistas conseguem criar posts, fãs conseguem visualizar e comentar/curtir. Os dados são armazenados no banco e atualizados em tela. Embora melhorias sejam desejáveis, o núcleo (CRUD de posts e comentários, toggle de likes, seguir usuários) já opera corretamente com a infraestrutura atual. Isso permite engajamento entre usuários dentro da plataforma.
- **Envio de Demos e Feedback:** O sistema permite que fãs enviem suas músicas (provavelmente upload de arquivo ou link) e artistas acessem essas submissões. O ciclo de feedback básico – artista escreve uma resposta ao demo – está implementado. Os demos ficam catalogados (com status) e isso estabelece a base para um A&R (artistas avaliando material de fãs) funcional. Mesmo sem os refinamentos avançados, já cumpre a tarefa principal: enviar conteúdo e receber resposta.
- **Marketplace NFT (versão simulada):** A exibição de NFTs, coleções e detalhes está funcionando. Usuários podem navegar em coleções e itens, visualizar imagens e informações, e até realizar ações simuladas (como clicar em comprar ou ofertar, que acionam diálogos). A estrutura de dados no Supabase permite registrar NFTs e transferências (mesmo que simuladas). Além disso, existem **testes automatizados** para o serviço NFT, indicando que as funções de listagem/fetch estão retornando conforme esperado. Isso significa que a parte de frontend do marketplace está pronta, aguardando apenas integração real para tornar as ações efetivas.
- **Loja e Pagamentos Integrados:** A loja de produtos está operante: produtos podem ser listados e visualizados, adicionados no carrinho e comprados. A integração com Stripe através das funções Supabase foi configurada com sucesso – criar PaymentIntent e confirmar pagamento está funcionando, assim como o webhook para atualizar pedidos. Isso é uma parte crítica do sistema de monetização e já está **funcionando corretamente em ambiente de teste**. Usuários podem completar compras reais (provavelmente em modo teste do Stripe) e ver seus pedidos registrados. Essa pipeline do pedido ao pagamento completo é um ponto alto de funcionamento, demonstrando que a plataforma consegue gerar receita.
- **Sistema de Carteira Interna:** A infraestrutura de JestCoin e carteira está operacional em sua forma base. Cada usuário tem sua wallet, e operações como buscar saldo (`fetchUserWallet`), transferir moedas (`transferService.transfer(...)`) e registrar transações funcionam no contexto do app. Assim, recursos que dependem de JestCoin (ex.: possivelmente recompensas ou doações) podem ser construídos em cima dessa base já funcional. O contexto da Wallet provê acesso fácil ao saldo atual em qualquer parte da UI.
- **Canvas de Carreira Interativo:** A ferramenta de planejamento de carreira via canvas funciona de forma fluida. A interface de arrastar e soltar nós, conectar arestas, e salvar esse grafo de informações está implementada e sem erros aparentes. Os artistas conseguem mapear seus objetivos e ver uma timeline derivada disso. A persistência no Supabase permite que dados não se percam entre sessões. Essa funcionalidade, sendo bastante custom, ter sido implementada corretamente é um indicativo de boa arquitetura e uso adequado de bibliotecas (React Flow) integradas ao estado global.
- **Interface de Live Streaming (parcialmente):** Embora o streaming ao vivo completo não esteja ativo, o que já funciona é a capacidade de listar canais e eventos programados e reproduzir um stream se fornecido um link HLS. O player de vídeo com HLS.js funciona – testável com qualquer URL de playlist .m3u8 – e a interface de chat e doação aparece (a lógica de back-end disso precisa completar, mas a UI responde, por exemplo, campo de entrada de chat, lista de mensagens, etc., podem estar operacionais localmente com dummy data). Assim, se um módulo de streaming for acoplado, a frente já comporta o básico.
- **Fluxo Admin Básico:** A aplicação provê telas para administração que já interagem com o sistema: é possível que o admin adicione um produto novo (inserindo no DB), edite existentes, veja lista de pedidos e mude status manualmente, ou cheque usuários cadastrados. O fato de haver componentes e serviços dedicados para essas tarefas indica que elas foram testadas e estão ativas. Também, o painel de analytics básico provavelmente já exibe informações corretas (número de usuários, posts, etc., consultando o DB). Em resumo, a plataforma não é apenas um conjunto de features isoladas – existe uma console administrativa inicial funcional, o que é crucial para operar o sistema no mundo real.
- **Fundação de Integrações Externas:** Mesmo que nem todas estejam finalizadas, as integrações principais foram ao menos estabelecidas: Supabase como backend (banco de dados, armazenamento, autenticação e funções), Stripe para pagamentos, possivelmente HLS para vídeo, etc. Não há bloqueios técnicos nessas integrações – o código consegue se comunicar com elas, como evidenciado pelos pagamentos funcionando e dados fluindo para o Supabase. Isso significa que o projeto não tem impedimentos para crescer nessas áreas, pois a base de comunicação externo já é sólida.
- **UI e Experiência Consistente:** Em termos de interface, a aplicação usa uma biblioteca de design consistente (Radix via ShadCN + Tailwind), resultando em componentes reutilizáveis com aparência uniforme. Elementos de UI como modais, botões, campos de input, abas, alerts, skeletons de carregamento, todos seguem o mesmo estilo. Isso dá ao usuário uma experiência coesa nas diferentes partes (comunidade, loja, etc.). Além disso, a navegação SPA via React Router está configurada, incluindo fallback para página 404 (`NotFound.tsx`) e tratamento de erros por rota (`ErrorBoundary` e `ErrorPage.tsx`). Essas coisas já funcionando garantem que o usuário final tenha uma navegação suave e feedback adequado caso algo dê errado.

Em suma, **quase todos os subsistemas principais estão prototipados e vários já operam end-to-end** no ambiente de desenvolvimento. O projeto conseguiu integrar muitas partes (frontend, backend, terceiros) com sucesso, restando mais aprimoramentos e complementos do que correções de defeitos graves.

## Funcionalidades que Ainda Precisam Ser Desenvolvidas

Apesar do amplo escopo coberto, há diversas funcionalidades inacabadas ou planejadas que precisam ser implementadas para considerar o produto “completo”:

- **Camada de Segurança Avançada e Social Login:** Atualmente limitado a email/senha, falta adicionar autenticação via redes sociais (OAuth Google, Twitter, Discord, etc.) para comodidade dos usuários. Além disso, recursos como **autenticação de dois fatores (2FA)** não estão presentes – uma adição importante para usuários artistas/admin que queiram proteger mais suas contas. A verificação de e-mail do Supabase existe, mas poderia ser aprimorada com reminders ou bloqueio de certas ações até verificar. Também, definir e implementar diferentes níveis de permissão de forma consistente está pendente (ex.: distinção clara do que um colaborador pode fazer vs. um fã, ou um admin com superpoderes). Em resumo, _login social, 2FA, e sistema granular de roles/permissões_ são extensões necessárias de segurança/usabilidade.
- **Notificações em Tempo Real e Sistema de Mensagens:** Falta um sistema robusto de comunicação usuário-usuário fora dos posts públicos. Por exemplo, **mensagens diretas in-app** entre fãs e artistas (ou chat de grupo entre colaboradores) não foi implementado – seria um módulo valioso para engajamento, permitindo conversas privadas ou formação de grupos de trabalho. Além disso, **notificações push** em tempo real estão ausentes: atualmente para ver se alguém comentou seu post ou seguiu você, o usuário provavelmente precisa atualizar a página de notificações. Implementar notificações push (via Supabase Realtime ou serviço de push) melhoraria muito a reatividade da plataforma. Isso inclui push no browser/app e também **notificações por email** (ex.: receber email quando um artista que sigo faz um post novo, ou quando meu pedido é enviado). O alicerce existe (notificationService, etc.), mas precisa ser expandido para cobrir esses canais e disparos automatizados.
- **Aprimoramento do Sistema de Demos:** O envio de demos básico funciona, mas funcionalidades anunciadas como parte do roadmap não estão lá ainda:
    - _Feedback Avançado:_ Atualmente o feedback é só um texto simples. Seria necessário implementar **avaliações por múltiplos critérios** (ex.: nota para produção, originalidade, etc.), talvez permitindo ao artista preencher um formulário estruturado para cada demo.
    - _Análise de Áudio:_ Uma ideia proposta era mostrar a waveform do áudio e permitir comentários marcados em timestamps específicos (como ocorre em plataformas de música colaborativa). Isso requer processar o arquivo de áudio para extrair forma de onda (pode ser feito no cliente ou backend) e interface para adicionar comentários inline – nada disso está presente no estado atual.
    - _Workflow de Status:_ Expandir além de “pendente/aprovado”. Implementar estados como "em revisão", "retornado para revisão", "publicado" (se decidem publicar demos boas), com transições claras e possivelmente notificações atreladas (ex.: “Seu demo foi aprovado!”).
    - _Compartilhamento de Demos:_ Permitir que demos aprovados sejam compartilhados na comunidade ou no perfil do artista (um recurso social/legal para dar exposição aos fãs talentosos). Isso implica integrar a demo a outros módulos (por ex., criar um post automático com a demo, ou listá-la numa seção).
    - _Métricas de Demos:_ Fornecer estatísticas aos artistas sobre demos recebidas – quantas submissões, quantas aprovadas, tempo médio de resposta, etc. Seria útil para avaliar o engajamento e também para gamificar fãs (quem envia demos de qualidade).
- **Expansão do NFT Marketplace:** O marketplace precisa sair do ambiente simulado para um real:
    - _Integração com Blockchain Real:_ Escolher uma blockchain (Ethereum, Polygon, Solana, etc.) e integrar a mintagem e transferência de NFTs de verdade. Isso envolverá usar SDKs (como ethers.js, web3.js, ou APIs de terceiros) e possivelmente contratos inteligentes customizados para cunhar NFTs (a menos que use um serviço como NFT.storage + OpenSea). Também precisaria integrar carteiras de criptomoeda para artistas/fãs (ou custodial via Supabase, mas ideal seria permitir conectar Metamask, por exemplo).
    - _Sistema de Venda/Leilão:_ Implementar compra e venda reais – atualmente qualquer “compra” é só uma transferência de proprietário no DB. Deve-se introduzir funcionalidades de **leilão** (bids) e compras diretas usando criptomoeda ou moeda local convertida. Isso inclui UI para ofertar lance, temporizador de leilão e determinação de vencedor, além de contratos inteligentes para segurar NFT em escrow, etc. É complexo e ainda não feito.
    - _Royalties para Criadores:_ Nos mercados NFT reais, ao revender um NFT, o criador original recebe uma porcentagem. Essa lógica de royalties deve ser incorporada – possivelmente calculado no smart contract, mas também refletido na UI e registros de transação.
    - _Melhorias na Experiência NFT:_ Coisas como pesquisar NFTs por nome/atributo (filtro de busca funcional), visualizar propriedades detalhadas, suporte a diferentes mídias (vídeo, áudio NFT), e otimização de carregamento (ex.: carregar imagens NFT via CDN ou lazy load) são detalhes a adicionar.
    - Em resumo, a plataforma NFT está em **modo demo** – para finalizar, precisa ser conectada a um blockchain e ganhar as funcionalidades completas de marketplace (mint, trade, auctions, royalties).
- **Funcionalidades Avançadas da Loja:** Embora o e-commerce funcione, algumas capacidades estão incompletas:
    - _Entrega de Produtos Digitais:_ Se a loja vende itens digitais (músicas, vídeos exclusivos), deve automatizar a entrega após pagamento. Provavelmente planejado via `digitalProductService`, mas requer implementação de envio de link seguro de download ou liberação de conteúdo na conta do usuário.
    - _Sistema de Avaliação/Review de Produtos:_ Existe UI para reviews, mas é necessário implementar a lógica: permitir usuário que comprou um produto postar uma avaliação com nota e comentário, salvá-la no DB, e exibi-la para outros na página do produto. Com moderação se necessário (admins podendo remover reviews ofensivas).
    - _Filtros e Pesquisa na Loja:_ Atualmente pode haver filtragem simples por categoria, mas recursos como busca por nome de produto, filtragem por preço, ordenação (mais vendidos, recentes) melhoram a UX de loja. Isso requer implementar consultas mais complexas (ou usar funcionalidades como text search do Supabase) e interfaces (campo de busca na StoreHeader, etc.).
    - _Recomendações de Produtos:_ Usar o histórico de compras ou visualizações para recomendar produtos ao usuário (ex.: “Quem comprou X também gostou de Y”). O `relatedProductsService` está esboçado, mas precisa de algorítmo ou consulta (pode ser simples baseado na mesma categoria ou explícito via tabela de relações).
    - _Tracking de Estoque:_ Se aplicável, garantir que ao comprar um produto físico reduza-se seu estoque disponível e impedir venda de item esgotado – não vi isso mencionado, se for necessário deve ser implementado para realidade de loja.
- **Sistema de Recompensas e Gamificação (JestCoin):** O ecossistema de JestCoin pode ser ampliado conforme plano:
    - _Recompensas Automáticas:_ Atualmente, distribuir JestCoins por atividades (login diário, postar algo, ganhar likes) não parece implementado. Criar regras e mecanismos (ex.: triggers no Supabase ou lógica no client) para conceder moedas conforme objetivos atingidos.
    - _Sistema de Níveis e Conquistas:_ Definir níveis de usuário ou badges (conquistas) baseados em quantos JestCoins acumulou ou certas ações (ex.: “Conquistador: completou 10 compras”). Isso envolve tanto design de gamification quanto implementação de cálculo e exibição no perfil.
    - _Interface Admin de JestCoin:_ Fornecer aos administradores ferramentas para ajustar o sistema monetário – por exemplo, definir recompensas para certas tarefas, monitorar inflow/outflow de JestCoins na economia (estatísticas de quantas moedas em circulação, top holders, etc.), e ações manuais (dar moedas promocionais para alguém, ou remover de contas fraudulentas).
    - _Staking/Investimento:_ Uma ideia mais avançada seria permitir usuários “investirem” suas JestCoins – travar coins por recompensas (como juros ou privilégios) ou stake em artistas (investir moedas em um artista e ganhar retorno se ele crescer). Nada disso existe ainda, seria completamente novo mas estava citado como possibilidade. Implementar exigiria contratos inteligentes ou lógica complexa no backend para calcular rendimentos, etc., talvez fugindo do escopo MVP – mas consta como planejado.
- **Streaming ao Vivo – Funcionalidades Restantes:** Para completo funcionamento do módulo de lives:
    - _Transmissão (Broadcast) ao vivo:_ Integrar um servidor ou serviço de streaming (por exemplo, WebRTC via WebSocket, ou plataformas como Livepeer, Mux) para que artistas possam realmente transmitir vídeo e áudio em tempo real. Isso inclui criar uma interface no app para o **artista iniciar/parar a transmissão**, capturando webcam e microfone e enviando ao servidor. Atualmente nada disso está implementado, só o lado do espectador.
    - _Chat em tempo real:_ Ligar o chat da live a um canal de realtime. Supabase tem canais de realtime que poderiam ser usados para chat simples, ou usar outra tech (Socket.io, etc.). Sem isso, o chat UI não serve. Implementar significa configurar sala por stream, inserir mensagens no DB ou memória e distribuí-las instantaneamente aos participantes.
    - _Doações integradas na Live:_ Finalizar a lógica do DonationPanel – ao enviar doação, deve ou acionar um pagamento (via Stripe, mas isso interromperia a experiência) ou usar JestCoins imediatamente transferidas. O mais fluido é usar JestCoins: ao clicar “Doar 50”, debita do fã e credita na carteira do artista, e envia uma notificação (talvez apareça no chat “Fulano doou 50 JestCoins!”). Isso precisa ser implementado e testado para garantir que não haja delay ou perda (usar transação DB).
    - _Agendamento e Notificação de Lives:_ Os artistas podem agendar futuras lives, mas falta notificar os fãs. Integrar notificação push/email quando uma live vai começar (“Artista X vai entrar ao vivo em 10 minutos”). Além disso, depois que a live termina, talvez enviar resumo ou agradecer espectadores.
    - _Gravação e Arquivo de Lives:_ Seria bom salvar o vídeo da live para disponibilizar posteriormente a quem perdeu. Isso envolve gravar o stream e salvar em armazenamento (grande volume de dados) – possivelmente usando Supabase Storage ou um serviço externo de vídeo, nada disso implementado ainda.
    - _Métricas de Audiência:_ Durante e após a live, coletar dados – pico de espectadores, duração média da visualização, total arrecadado em doações – e mostrar isso ao artista (até para incentivar mais lives). Requer instrumentar o player e chat para contar usuários conectados e mensagens enviadas.
- **Analytics e Dashboard Avançados:** O sistema de analytics atual pode ser enriquecido:
    - _Filtros de Data Personalizados:_ Atualmente provavelmente há apenas visões fixas. Implementar seleção de intervalo de datas customizado para métricas (ex.: último trimestre, período custom). Isso exige ajustar consultas para filtrar por data de criação.
    - _Dashboards Personalizados:_ Permitir admins montar painéis com métricas que importam para eles, escolhendo gráficos e KPIs. Isso seria um plus de usabilidade interna.
    - _Atualizações em Tempo Real:_ Integrar com o supabase realtime ou triggers para que certos contadores (ex.: número de usuários online agora, novas vendas do dia) atualizem sem precisar refresh.
    - _Novos Tipos de Métrica:_ Exemplo, métricas de engajamento (média de posts por usuário, retenção de usuários novos em X dias, etc.) ou financeiras (receita por mês, LTV de cliente). Demandaria escrever consultas ou funções para calcular e armazenar esses dados periodicamente.
    - _Visualizações e Exportação:_ Adicionar gráficos interativos (talvez usando alguma lib tipo Chart.js ou Recharts se não incluso) para além dos básicos. E dar opção de exportar dados (CSV, PDF) para relatórios externos – útil a admins.
- **Moderação de Conteúdo e Gerenciamento de Usuários:** Até agora, qualquer conteúdo postado (posts, comentários, demos) fica disponível sem supervisão a não ser que um admin manualmente interfira pelo banco. Funcionalidades a desenvolver:
    - _Ferramentas de Moderação:_ Admins (ou mods) deveriam ter um painel para revisar conteúdo reportado ou automaticamente sinalizado. Isso incluiria possibilidade de **reportar posts/comentários** por usuários (um botão “Denunciar”), e então na interface admin ver a lista de itens denunciados, com ações para remover ou banir usuário se necessário.
    - _Filtro de Palavras/Inappropriate Content:_ Implementar no backend ou front um filtro básico para palavrões ou conteúdo proibido, para pelo menos alertar ou bloquear antes de publicar.
    - _Gerenciamento de Usuários:_ Expandir além de listar – permitir admin alterar roles (promover alguém a colaborador ou remover privilégio), suspender contas temporariamente, ou deletar contas. Isso requer endpoints seguros e UI para confirmar ações destrutivas.
    - _Monitoramento da Plataforma:_ Uma visão para admin ver o status geral do sistema – talvez uso de recursos (espaço de armazenamento de demos, largura de banda das lives, etc.) para escalar se necessário. Isso é avançado e possivelmente fora do escopo imediato, mas citado como “monitoramento de status da plataforma”.
- **Recursos de Receita e Assinaturas:** Além de venda direta de produtos e doações, o projeto menciona implementar sistemas de receita recorrente:
    - _Assinaturas (Memberships):_ Oferecer planos de assinatura para fãs, possivelmente níveis como “Bronze/Silver/Gold” com benefícios crescentes (acesso a conteúdo exclusivo, descontos, etc.). Isso envolve integração com Stripe novamente (produtos de assinatura, billing recurrente) ou gerenciamento manual via Supabase (cobrar todo mês via PaymentIntent – porém Stripe oferece melhor pronto). Nenhuma tela de UI para isso existe ainda, então seria do zero: página para escolher plano, fornecer pagamento, e backend para gerir assinaturas ativas e renovar pagamentos.
    - _Programa de Afiliados Completo:_ Já tem base (AffiliateProgram UI, e mention de integrar com JestCoin). Precisaria concluir: geração de link de referência único por usuário, rastrear novas inscrições ou compras através desse link, e recompensar o dono do link (com JestCoins ou % em dinheiro via Stripe). Também, possivelmente criar páginas mostrando top afiliados e suas comissões.
    - _Compartilhamento de Receita:_ Se artistas colaboram ou há co-criadores, implementar divisão de receita de venda de produtos ou NFTs proporcionalmente. Isso complica as tabelas de pedidos e pagamentos (precisaria armazenar splits) e calcular pagamentos de saída para artistas (talvez via Stripe Connect or offline calculation).
    - _Relatórios Financeiros:_ Gerar relatórios para admins e artistas sobre ganhos: total vendido por período, crescimento de receita, etc. (parte se cruza com analytics).
- **Melhorias Mobile e Cross-Platform:** A aplicação deve oferecer uma boa experiência em dispositivos móveis e possivelmente ser transformada em app:
    - _Design Responsivo Completo:_ Garantir que todas as páginas e componentes se ajustem bem em telas pequenas. Muitas vezes, layouts complexos (como dashboard com sidebars, tabelas de admin, canvas de carreira) podem quebrar no mobile ou ficar difíceis de usar. Será preciso revisar CSS/Tailwind para pontos de quebra, talvez ocultando elementos ou oferecendo versões compactas para mobile (ex.: menu sanduíche para navegação).
    - _Progressive Web App (PWA):_ Configurar o app para funcionar como PWA – isso inclui manifest.json, ícone, e suporte a modo offline para pelo menos conteúdo estático. A ideia é permitir que usuários instalem o "app" no celular e recebam notificações push.
    - _Funcionalidade Offline para Principais Recursos:_ Implementar cache de dados (usando service workers ou cache do React Query) para que partes do app funcionem offline ou com conexões ruins. Por exemplo, permitir ler posts antigos já carregados sem internet, ou compor um post/offline e publicar quando reconectar (fila de operações offline).
    - _Sincronização Multi-dispositivo:_ Garantir que ações iniciadas num dispositivo reflitam em outro rapidamente – provavelmente já acontece por ser centralizado no DB, mas casos como tocar um demo no celular e continuar no desktop, ou receber notificação push no celular quando está logado no desktop, etc., precisam ser pensados para consistência.
    - _Gestos e UI Mobile-first:_ Adicionar pequenos ajustes para mobile, como suporte a gestos (swipe para atualizar, swipe para navegar galeria de NFT, etc.) e atalhos de teclado ou toque longo para ações especiais, melhorando a usabilidade em touchscreens.
- **Otimização de Performance e Escalabilidade:** Embora o app funcione, para produção com muitos usuários há otimizações pendentes:
    - _Otimização de Imagens e Mídia:_ Implementar carregamento otimizado de imagens (usar tamanhos responsivos, compressão, e talvez um CDN para servir imagens de NFTs, produtos, perfis). Idem para vídeos ou áudio – streaming adaptativo já está pensado com HLS, mas garantir compressão e codificação eficientes.
    - _Carregamento Preguiçoso (Lazy Loading):_ Dividir o bundle JS por rotas (code splitting) para que o usuário carregue apenas o necessário de imediato. Pode já ocorrer via Vite, mas checar se páginas grandes (ex.: Admin, ou Canvas com libs pesadas) não estão sendo carregadas sem necessidade. Implementar `React.lazy` e Suspense para componentes pesados pode acelerar a carga inicial.
    - _Cache e Dados em Memória:_ Usar melhor o React Query (ou outro state global) para evitar refetch desnecessário de dados. Ex.: se o usuário navegou no feed e depois volta, não precisar recarregar tudo do zero – manter cache de posts, produtos, etc., pelo menos por sessão. Também configurar cache HTTP e do CDN para assets estáticos e respostas de API que podem ser armazenadas.
    - _Escalabilidade do Banco:_ Analisar se consultas atuais (especialmente as de analytics ou feed) vão escalar. Por exemplo, a feed de comunidade pega posts e todos comentários de uma vez? Pode saturar se houver milhares. Talvez implementar paginação infinita onde não houver (vi que fetchPosts tinha limite, ok). Além disso, índices no supabase para colunas de filtro (like, ilike, order by) devem ser garantidos – isso é ajuste de banco, mas deve ser notado como tarefa antes de crescer.
    - _Monitoramento de Performance:_ Integrar alguma ferramenta para monitorar performance real do app (New Relic, Datadog, ou mesmo um dashboard custom via Supabase logs) para detectar gargalos e erros em tempo real. Assim se algo congestionar (ex.: função edge demorada, ou muitas requisições de chat), os admins saberão e poderão agir.
- **Refinamento de UX/UI e Polimento Final:** Vários pequenos detalhes de UX ficam para finalizar:
    - Padronizar mensagens de erro e sucesso ao usuário – garantir que cada ação tem um feedback (toast ou mensagem na tela). Alguns flows podem não ter mensagens claras ainda.
    - Revisar textos e traduções (se é bilíngue; parece estar majoritariamente em português com alguns placeholders em inglês). Decidir por um idioma consistente ou i18n.
    - Melhorar a acessibilidade (atributos ARIA em botões modais, contraste de cores adequado, navegação por teclado funcionando em todos elementos interativos).
    - Testar a aplicação ponta-a-ponta como um usuário comum faria, para pegar quaisquer incoerências ou passos confusos, e ajustá-los (por exemplo, talvez após registrar o usuário não é levado automaticamente ao onboarding, ou coisas assim podem ser polidas).
    - Completar documentação para usuários (help sections ou tooltips explicando recursos complexos como canvas ou NFT).

Em resumo, **muitas funcionalidades avançadas e complementares ainda estão pendentes**: principalmente melhorias de segurança, comunicação em real-time, aprofundar os sistemas de NFT, loja, recompensas e streaming, e otimizar para produção em larga escala. Essas implementações são necessárias para que o JestFly realize todo seu potencial conforme a visão original.

## Melhorias Recomendadas (Otimização, Segurança e Desempenho)

Para otimizar e fortalecer o aplicativo, além das novas funcionalidades acima, algumas **melhorias técnicas gerais** são aconselháveis:

- **Refatoração e Organização de Código:** Como identificado, consolidar a lógica duplicada (unir `lib` e `services`) é prioritário. Manter um único padrão modular vai reduzir bugs e confusão. Além disso, remover arquivos não utilizados e limpar comentários/debug desnecessários tornará o códigobase mais leve e claro. Adoção de uma arquitetura consistente (por exemplo, todos serviços no padrão X, todos contextos fazendo Y) facilitará onboarding de futuros desenvolvedores e a manutenção.
- **Reforçar Segurança no Lado do Servidor:** Garantir que todas as tabelas do Supabase tenham _Row Level Security (RLS)_ configurado adequadamente e políticas para impedir acesso indevido. Por exemplo, posts só editáveis pelo autor, demos só visíveis para autor e destinatário até serem públicos, wallets só acessíveis pelo dono ou admin, etc. Complementar com validações nas edge functions (já fazem algumas checagens de input e keys, mas adicionar verificação se o pedido a confirmar pertence ao usuário que chamou, etc.). Considerar registrar logs de atividade sensível (ex.: transferências de JestCoin, tentativas de login falhas) para auditoria.
- **Melhorar Manejo de Erros Global:** Implementar um sistema global de tratamento de erros que capture exceções não previstas (por exemplo, integrar Sentry ou similar para logar erros de JS). Assim, em produção, qualquer erro que escape ao usuário pode ser relatado aos devs para correção. No front, padronizar uso do `useErrorHandler` e garantir que erros de fetch exibam mensagens amigáveis (em português) e talvez instruções do que fazer (ex.: "Tente novamente mais tarde"). No backend (edge functions), retornar códigos de status e mensagens padronizadas que o front possa entender e reagir.
- **Otimização de Consultas e Indexação:** Revisar as chamadas Supabase para buscar somente os campos necessários e usando filtros apropriados. Alguns atuais usam `select('*')` – poderia ser otimizado para campos específicos, reduzindo banda. Adicionar índices no banco para consultas frequentes (como por user_id em várias tabelas: posts, likes, transactions, etc.). Se algum relatório for pesado (analytics agregando muitos dados), talvez pré-calcular periodicamente ou usar materialized views para performance.
- **Escalabilidade do Streaming e Realtime:** Conforme implementar chat e live, considerar carga: supabase realtime funciona bem para número moderado de conexões, mas se planejam milhares de usuários simultâneos, talvez usar um serviço dedicado de websockets ou dividir cargas. Similarmente, streaming de vídeo para muitos usuários pode precisar de CDN de vídeo. Planejar infra de escalabilidade (e custos) desde cedo, integrando opções configuráveis (p.ex., permitir usar keys de API de serviços de streaming via environment).
- **Utilização de CDN e Cache:** Colocar frente a frente do aplicativo um CDN para conteúdo estático (imagens, CSS, JS) para reduzir latência global. O Vite já pode gerar assets otimizados; servir via Netlify/Vercel ou próprio Supabase Hosting com cache pode acelerar. Também, se há muitas imagens de usuários (perfil, posts), usar o Supabase Storage com caching e talvez transformações (Supabase Storage suporta CDN e transforms via URL).
- **Melhorar Performance Percetível (LCP, etc.):** Otimizar o tempo de carregamento das páginas principais. Por exemplo, a página inicial (Index) e feed de comunidade devem carregar rápido: isso pode requerer _server-side rendering (SSR)_ ou _static generation_ de partes públicas. Como é Vite (SPA), não há SSR atualmente – avaliar se migrar para Next.js ou incorporar alguma forma de prerender para SEO e primeira carga rápida seria benéfico, especialmente se pretendem conteúdo público indexável (posts de artistas, por exemplo, poderiam ser visíveis sem login e indexados no Google). Caso manter SPA, focar em lazy load de componentes não visíveis inicialmente e mostrar skeletons imediatos para percepção de rapidez.
- **Testes e Qualidade:** Expandir a cobertura de testes unitários/integrados. Atualmente existem alguns testes para NFT; deveria haver testes para funções críticas como checkout (simulando fluxo de pedido pago), transferência de JestCoin, criação de post, etc. Isso garante estabilidade quando for escalar. Além disso, testes de carga (particularmente no chat e streaming quando adicionados) para assegurar que o sistema aguenta X usuários simultâneos. Ferramentas como k6 ou JMeter podem ser usadas contra as funções edge e endpoints.
- **Segurança do Cliente:** Implementar medidas contra ataques no front: por exemplo, usar `Helmet` (já está usando HelmetProvider) corretamente para setar cabeçalhos de segurança, garantir que tokens JWT do Supabase sejam armazenados de forma segura (supabase-js já cuida disso via localstorage). Também considerar ofuscar ou mapear IDs sequenciais para evitar scraping (Supabase retorna IDs – não há proteção se alguém tentar enumerar, a RLS deve cuidar). E educar usuários/admins com confirmações para ações irreversíveis (ex.: “Tem certeza que deseja deletar este produto?”).
- **Engajamento e Retenção:** Do ponto de vista não técnico mas de produto (que os devs implementam via código), recomenda-se implementar mecanismos para aumentar retenção, como emails de boas-vindas, lembretes se o usuário ficar inativo (pode ser via cron job ou função programada no Supabase para mandar email se user não loga faz 30 dias). Isso não é exatamente performance ou segurança, mas faz parte do polimento final para sucesso do app.
- **Atualização de Dependências:** Manter as libs up-to-date. Por exemplo, Supabase JS, Stripe API version, Radix UI – tudo deve estar na última versão estável para evitar bugs conhecidos e ter melhorias. Também configurar auditoria de pacotes (npm audit) para fechar eventuais vulnerabilidades em dependências.
- **Modo de Produção e Configurações:** Revisar as config para produção: desligar logs detalhados, habilitar compressão de responses se aplicável, variáveis de ambiente corretas (ex.: apontar Supabase para instância prod, chaves Stripe live mode, etc.). Garantir que _adminSecret_ usado para função de demo users esteja seguro e diferente do padrão, ou removê-lo em produção.
- **Documentação e Manuais:** Do aspecto de manutenção e segurança a longo prazo, é bom gerar documentação do sistema (além do código): diagramas de arquitetura, README atualizado explicando como rodar, como configurar chaves, etc. Isso ajuda na segurança (menos chance de misconfiguration) e desempenho (novos devs entendendo rápido o sistema).

Implementando essas melhorias, o JestFly ficará mais robusto, rápido e seguro, pronto para um ambiente de produção real com usuários ativos. Agora, com base nessa análise, seguem prompts detalhados sugerindo as correções e implementações necessárias para finalizar completamente o aplicativo.

## Prompts Detalhados para Correções e Implementações Finais

### Prompt 1: Refatoração de Código e Otimizações Gerais

```
Realize uma refatoração abrangente do código para melhorar a qualidade e performance:
1. Unifique a lógica duplicada nas pastas `lib/` e `services/` – escolha uma delas e migre todas funções, removendo código redundante (por exemplo, consolidar serviços de NFT, canvas, loja, etc. em um único local).
2. Remova componentes e arquivos obsoletos ou de teste (como `CareerCanvasTest` e utilitários em `components/test/`) que não serão usados em produção.
3. Elimine `console.log` e comentários de depuração desnecessários, garantindo que o código de produção esteja limpo.
4. Verifique e corrija validações em formulários e serviços – adicione validação robusta de inputs do usuário (campos obrigatórios, formatos) e tratamento de erro consistente em todas operações assíncronas.
5. Implemente guardas de rota e verificações de permissão no front-end: bloqueie acesso não-autorizado a rotas de admin ou conteúdo restrito (redirigindo se o usuário não tiver o perfil adequado).
6. Atualize dependências do projeto para versões estáveis mais recentes e rode testes para garantir que tudo continua funcionando após a refatoração.
7. Otimize a configuração de build (Vite/Tailwind): habilite tree-shaking e remoção de código morto, e se possível ative compressão/minificação avançada para reduzir o bundle final.
```

### Prompt 2: Aprimoramentos de Autenticação e Segurança

```
Melhore a autenticação de usuários e a segurança da plataforma:
1. Implemente login social utilizando OAuth (Google, Twitter, Discord) via Supabase Auth, adicionando botões de login social nas telas de Login/Registro e tratando a criação/fusão de contas corretamente.
2. Adicione autenticação de dois fatores (2FA) para usuários que desejarem – por exemplo, via aplicativo autenticador ou SMS. Integre essa opção na página de configurações de perfil e ajuste o fluxo de login para solicitar o segundo fator quando habilitado.
3. Fortaleça a verificação de e-mail: exija e-mails verificados para ações críticas (postar conteúdo, compras) e envie reenvio de verificação quando necessário; apresente notificações claras se a conta não estiver verificada.
4. Implemente um sistema de autorização granular baseado em perfis/tipos de usuário: defina claramente as permissões de cada perfil (fã, artista, colaborador, admin) e adapte o front-end para exibir/permitir ações apenas se o usuário tiver permissão (por exemplo, esconder botões admin para não-admin, etc.).
5. Adicione registro de atividades da conta e sessões: crie uma página onde o usuário possa ver sessões ativas/dispositivos logados e encerrar sessões remotamente; e registre eventos importantes (mudança de senha, 2FA habilitado, falha de login) com timestamps para consulta pelo usuário ou admin.
6. Implemente detecção básica de atividades suspeitas e proteção contra brute force: por exemplo, bloqueie temporariamente login após várias tentativas falhas seguidas, e avise o usuário sobre tentativa de login não usual por e-mail.
```

### Prompt 3: Sistema de Comunicação e Notificações em Tempo Real

```
Implemente recursos de comunicação em tempo real na plataforma:
1. Crie um sistema de mensagens diretas (chat privado) entre usuários: permita que fãs enviem mensagens privadas a artistas e vice-versa. Implemente uma interface de chat simples com listagem de conversas recentes e histórico de mensagens armazenado no Supabase (tabela `direct_messages`), usando Supabase Realtime para entrega instantânea.
2. Adicione um recurso de chat em grupo ou comentários em tempo real durante eventos (por exemplo, um chat para todos os espectadores durante uma live ou um fórum ao vivo para discussões gerais). Utilize canais públicos no Supabase Realtime ou outro serviço de WebSockets para permitir múltiplos usuários na mesma sala.
3. Implemente notificações push no navegador para eventos importantes: novos posts de artistas que sigo, nova mensagem direta, confirmação de compra, etc. Use o Service Worker de um PWA ou a API de Notifications com Fallback de e-mail se o usuário estiver offline.
4. Desenvolva um sistema de notificações por e-mail: envie e-mails automatizados para usuários em eventos-chave (ex.: “Seu pedido foi enviado”, “Você recebeu um novo comentário no seu post”, “Sua live começará em 1 hora”). Use a função mail do Supabase ou integre um serviço externo (SendGrid) e crie modelos de e-mail adequados.
5. Adicione ferramentas colaborativas para artistas dentro do planejamento de carreira: permita que um artista convide colaboradores para editar juntos um canvas de carreira ou um documento de planejamento, comunicando-se via comentários em cada item ou um chat dedicado do projeto. Garanta sincronização em tempo real das edições (Supabase Realtime ou outro método) para todos visualizadores.
6. Implemente um calendário compartilhado para eventos: artistas podem ter um calendário de lançamentos/eventos que fãs podem subscrever. Sincronize eventos relevantes (lives agendadas, lançamentos de NFT, shows) no calendário do fã ou envie notificações lembrando-os. Permita que usuários adicionem esses eventos a seus calendários pessoais (Google Calendar, etc.) via links/arquivos iCal.
```

### Prompt 4: Aprimoramento do Sistema de Envio de Demos

```
Melhore e expanda o sistema de submissão de demos:
1. Implemente um sistema avançado de feedback para demos: permita que artistas avaliem demos com múltiplos critérios (por exemplo, Qualidade da Produção, Letra, Originalidade, Potencial Comercial) dando nota ou estrelas para cada um, além do comentário geral. Exiba essas avaliações estruturadas para o fã quando o feedback for enviado.
2. Adicione processamento de áudio nas demos: ao receber um arquivo de música, gere a visualização da forma de onda (waveform) e duração. Mostre o player de áudio com waveform na interface do artista ao avaliar e também para o fã ao ver o feedback, destacando visualmente pontos comentados.
3. Melhore o workflow de status das demos: acrescente estados como “Em análise” (quando um artista começou a avaliar) e “Feedback enviado” (após avaliação). Envie notificações apropriadas ao mudar de estado. Permita que artistas sinalizem demos como “Destacadas” ou “Para Revisar Depois” para organização interna.
4. Implemente comentários em pontos específicos do áudio: artistas podem pausar no player e deixar um comentário timestamped (por ex.: “00:45 - ótimo refrão!”). Exiba esses comentários alinhados à timeline da música para o fã, talvez como marcadores clicáveis no waveform.
5. Adicione opção de compartilhamento de demos aprovadas: com permissão do fã, permita ao artista publicar a demo aprovada em sua comunidade ou perfil (transformando-a em um post público ou adicionando a uma seção “Demos de fãs destacados”). Inclua os devidos créditos ao autor da demo.
6. Crie métricas e estatísticas para o módulo de demos: no dashboard do artista, mostre quantas demos recebeu no último mês, sua taxa de resposta, distribuição de notas médias que deu, etc. Isso ajuda o artista a acompanhar o processo de A&R e motiva fãs (p.ex., “20 demos enviadas, 5 aprovadas”).
```

### Prompt 5: Melhorias no Marketplace de NFT

```
Finalize e aprimore o NFT Marketplace:
1. Integre a plataforma com uma blockchain real (Ethereum ou Solana, etc.): implemente a cunhagem (mint) de NFTs na blockchain escolhida quando um artista criar um NFT. Use um smart contract padrão (ERC-721/1155 para Ethereum) ou serviço custodial se preferir. Armazene o token ID e contrato no Supabase, substituindo os dados mock.
2. Implemente um sistema completo de compra e venda de NFTs: permita que usuários conectem suas carteiras cripto (ex.: MetaMask) para realizar transações on-chain. Crie funcionalidades de listar NFT à venda, realizar oferta (bid) e fechar venda. Para vendas diretas, integre pagamento em criptomoeda ou conversão via um provedor (opcionalmente permitir compra com cartão integrando com Stripe + custodial mint).
3. Adicione um sistema de leilão para NFTs: artistas podem leiloar um NFT definindo um tempo de duração. Outros usuários fazem lances sucessivos. Exiba o maior lance em tempo real e encerre o leilão automaticamente, transferindo o NFT ao vencedor e JestCoins/cripto ao vendedor conforme o caso.
4. Implemente royalties para criadores nas revendas: sempre que um NFT for revendido entre usuários, calcule uma porcentagem para o criador original. Inclua essa lógica no smart contract ou então manualmente via backend (ex.: registrar venda no Supabase e criar uma transferência ao criador). Mostre nas informações do NFT qual a royalty rate e rastreie ganhos de royalties para os artistas.
5. Finalize o gerenciamento de coleções: permita que artistas criem e gerenciem coleções (com imagem de banner, descrição) e agrupem seus NFTs nelas. Inclua capacidade de coleção privada (apenas visível após lançamento, etc.). Adicione filtros na interface para navegar por coleções populares, recém-atualizadas, ou por artista.
6. Melhore a interface do NFT Viewer e marketplace: inclua busca por nome/atributos, filtros (por preço, raridade), paginação infinita para galerias, e indicadores visuais (por exemplo, tag “Vendido” ou “Em leilão” sobre as thumbnails). Otimize o carregamento das imagens NFT usando um serviço de imagens/CDN para não pesar o app.
```

### Prompt 6: Funcionalidades de Live Streaming ao Vivo

```
Complete o módulo de streaming ao vivo com recursos interativos:
1. Implemente a capacidade de transmissão de vídeo ao vivo para artistas via WebRTC ou protocolo similar: desenvolva uma interface para o artista iniciar uma live (capturar câmera/microfone) e envie o stream para um servidor de media (pode usar um serviço como Livepeer, Mux ou um SFU como mediasoup). Integre esse fluxo de forma que o player HLS atual possa reproduzir (se usar HLS, crie transcodificação em tempo real; ou adapte o player para WebRTC playback).
2. Desenvolva o sistema de chat em tempo real para lives: conecte o componente `ChatInterface` a um backend realtime (Supabase Realtime ou outro servidor de websocket) para que mensagens dos espectadores apareçam instantaneamente a todos. Garanta escala para suportar muitos usuários simultâneos e moderação básica (permitir hosts remover mensagens ou silenciar usuários abusivos).
3. Implemente o processamento de doações durante streams: conecte o `DonationPanel` com o sistema de pagamento. Para doações via JestCoin, deduza imediatamente o valor da carteira do doador e credite na carteira do artista, emitindo uma mensagem de destaque no chat (“👏 Fulano doou 50 JestCoins!”). Para doações via dinheiro/Stripe (se oferecido), utilize checkout rápido sem sair da página (ex.: Stripe Elements modal) e ao sucesso, informe o backend para notificar a doação na live.
4. Adicione funcionalidade de agendamento e aviso de streams: permita que artistas agendem lives futuras com título/tema e horário. Liste streams agendados no `LiveStreamHub` e ofereça aos fãs a opção de “Lembrar-me”/inscrição. Implementar envio de notificação (push/email) para inscritos quando a live estiver para começar.
5. Implemente arquivamento de streams passados: grave as transmissões (ou pelo menos permita que o artista faça upload de uma gravação pós-evento) e disponibilize na plataforma. Crie uma seção “Streams Anteriores” no canal do artista, onde fãs que perderam possam assistir a replay. Isso envolve salvar o vídeo (preferencialmente em Supabase Storage ou serviço de vídeo) e reproduzi-lo sob demanda com o mesmo player HLS.
6. Adicione métricas e painéis de audiência ao streaming: forneça ao artista dados durante a live (por exemplo, número atual de espectadores, picos de audiência, total de JestCoins arrecadados na sessão) e após o término mostre um resumo (curva de espectadores ao longo do tempo, novas follows durante a live, etc.). Isso incentiva melhoria contínua e mostra o impacto das lives.
```

### Prompt 7: Expansão da Loja e Pagamentos

```
Implemente melhorias no sistema de loja e pagamentos:
1. Finalize a integração com gateway de pagamento Stripe no modo produção, garantindo suporte a pagamentos internacionais e múltiplos métodos (cartão, Apple/Google Pay). Adicione tratamento de erros de pagamento (ex.: cartão recusado) com mensagens claras para o usuário e opção de tentar outro método.
2. Implemente a entrega automatizada de produtos digitais: para itens como músicas ou vídeos comprados na loja, disponibilize um link seguro de download ou desbloqueie o conteúdo na conta do usuário após o pagamento. Integre com Supabase Storage ou outro serviço para hospedar os arquivos digitais, gerando URLs expiradas para download protegido.
3. Adicione atualização de status de pedidos em tempo real: use o webhook do Stripe ou polling para atualizar a página `StoreOrders` do usuário assim que o pagamento for confirmado, mudando status de "Aguardando Pagamento" para "Pago/Em Processamento" sem precisar de refresh manual. Notifique também via email o resumo do pedido após confirmação.
4. Implemente o sistema de avaliação e reviews de produtos: permita que usuários que compraram um produto deixem uma avaliação com nota (estrelas) e comentário. Na página do produto, exiba a média de avaliações e os comentários recentes. Crie moderação para reviews (admins podendo remover ofensivos) e incentive avaliações enviando um lembrete por email algum tempo após a entrega.
5. Melhore a navegação e filtros de produtos: implemente busca por nome/descrição de produto na loja, filtros combinados (por categoria, faixa de preço, disponibilidade em estoque) e ordenação (mais vendidos, novidades, preço asc/desc). Utilize esses parâmetros para construir consultas ao Supabase (pode usar full-text search para texto). Atualize a UI `StoreHeader` e `StoreSidebar` para incluir barras de busca e controles de filtro dinâmicos.
6. Adicione recomendações personalizadas de produtos: na página principal da loja e na página de carrinho/checkout, mostre itens recomendados com base nas compras anteriores do usuário ou itens vistos recentemente. Implemente `relatedProductsService` para buscar produtos na mesma categoria ou frequentemente comprados juntos (precisará registrar relações de compra no banco). Assim, aumentamos vendas cruzadas e a experiência do usuário.
```

### Prompt 8: Sistema de Recompensas, JestCoin e Gamificação

```
Aprimore o ecossistema de JestCoin e o sistema de recompensas para engajar usuários:
1. Implemente um sistema automatizado de recompensas: defina regras onde ações do usuário geram JestCoins automaticamente (ex.: completar perfil dá 10 moedas, fazer check-in diário dá 2 moedas, ganhar 100 curtidas em posts dá 5 moedas, etc.). Implemente monitoramento dessas ações (via triggers no Supabase ou lógica no backend) e créditos automáticos na wallet do usuário quando atingidas.
2. Expanda a interface da carteira para mostrar conquistas e níveis: crie um sistema de níveis baseado em pontos (JestCoins ganhos ou outra métrica). Exiba o nível atual do usuário e uma barra de progresso para o próximo nível na página da carteira ou perfil. Ofereça badges de conquistas por marcos (por exemplo, “Influencer – alcançou 1000 seguidores” ou “Super Fã – enviou 10 demos”).
3. Desenvolva uma interface administrativa para gestão do JestCoin: permita admins ajustar manualmente o saldo de um usuário (com registro do motivo), criar recompensas custom (ex.: distribuir moedas para todos em uma promoção) e ver relatórios do "fluxo" de JestCoins na plataforma (quantos emitidos, ativos, gastos em compras, doações, etc.).
4. Integre o sistema de afiliados ao JestCoin: para cada novo usuário que se cadastrar com o código de referência de um membro existente, conceda moedas de bônus tanto ao referido quanto ao quem indicou. Registre essas recompensas automaticamente. Na tela de afiliados, mostre quantas pessoas usaram o código do usuário e quantas moedas ele ganhou de comissão.
5. Implemente um sistema de tiers VIP ou assinaturas usando JestCoin: por exemplo, usuários podem gastar uma certa quantidade de JestCoins por mês para se tornarem membros VIP de um artista, desbloqueando conteúdo exclusivo. Crie mecanismos para deduzir mensalmente essas moedas e sinalizar o status VIP no perfil do fã e nas páginas do artista (pode ser integrado ao sistema de assinatura via dinheiro, mas aqui usando moeda interna).
6. Explore opções de staking/investimento de JestCoin: permita que usuários travem (stake) uma quantidade de JestCoins por um período em troca de recompensas – isso pode ser juros pagos em JestCoin, ou benefícios (como maior visibilidade de seus posts). Implemente contratos simples no Supabase ou use mecanismos financeiros simulados para dar retorno proporcional após prazo definido, incentivando usuários a manter moedas na plataforma.
```

### Prompt 9: Aprimoramentos em Analytics e Dashboard Administrativo

```
Aprimore o sistema de analytics e o painel administrativo para gestão mais efetiva:
1. Adicione a possibilidade de filtrar dados por intervalo de datas personalizado no analytics: inclua date pickers no dashboard para que admins possam selecionar início e fim desejados e recalcular métricas (usuários ativos, vendas, posts) naquele período. Ajuste as consultas em `statsService` e `timeSeriesService` para usar esses filtros.
2. Implemente dashboards personalizados: permita que administradores escolham quais métricas e gráficos querem ver. Forneça uma opção de customização onde eles podem adicionar/remover widgets (por exemplo, gráfico de novos usuários, tabela de top artistas, etc.) e salvar essa configuração por admin.
3. Adicione atualizações em tempo real para métricas críticas: utilize Supabase Realtime ou polling curto para atualizar contadores de KPI (ex.: novas vendas hoje, usuários online agora) sem precisar recarregar a página de analytics. Desta forma, o admin vê quase em tempo real o movimento da plataforma (tal como um monitor).
4. Expanda os tipos de métricas disponíveis: inclua métricas de engajamento (ex.: média de posts por usuário por semana), retenção (coorte de quantos usuários retornam após X dias), e qualidade de conteúdo (ex.: taxa de aprovação de demos enviadas). Compute essas métricas via consultas SQL complexas ou funções armazenadas, e exiba-as em novos cards/gráficos.
5. Melhore as visualizações de dados com gráficos interativos: integre uma biblioteca de charts (por exemplo, Chart.js, Recharts ou D3) para apresentar gráficos de linhas, barras e pie charts no lugar de simples números. Permita interações como hover para detalhes, clicar para filtrar um dado específico, etc., tornando a análise mais rica.
6. Adicione funcionalidade de exportação de dados: no painel admin, inclua botões para exportar relatórios em CSV ou PDF. Por exemplo, exportar a lista de emails de usuários, ou extrair um relatório mensal de vendas. Implemente gerando arquivos no backend (pode usar uma função Edge para montar um CSV a partir de uma consulta) e fornecendo o download ao admin.
```

### Prompt 10: Moderação de Conteúdo e Ferramentas de Admin

```
Melhore o dashboard administrativo com foco em moderação e controle de conteúdo:
1. Expanda o gerenciamento de usuários: na seção de admin de usuários, permita buscar e filtrar por nome/email, ver detalhes completos do perfil (posts feitos, compras, status de verificação). Adicione ações para admins: promover/demover usuários de artistas a colaboradores ou vice-versa, bloquear/suspender usuários (impedir login temporariamente) e excluir contas, com confirmações e registro de quem executou a ação.
2. Adicione ferramentas de moderação de posts e comentários: crie uma lista administrativa de todo conteúdo recente ou denunciado. Implemente a funcionalidade de **denunciar conteúdo** para usuários (um botão em cada post/comentário que marca no DB aquele item como reportado). No painel admin, exiba os itens reportados com contagem de denúncias e detalhes, e dê opção de remover o post/comentário imediatamente ou avisar o autor.
3. Implemente moderação preventiva com filtros: integre uma lista de palavras proibidas ou use uma API de moderação (como Perspective API) para detectar conteúdo impróprio em posts, comentários, chat e demos. Se algo ofensivo for detectado, marque para revisão ou oculte automaticamente, notificando os admins.
4. Acrescente um dashboard avançado de analytics para admins: além do existente, inclua visualizações comparativas (ex.: crescimento semana vs semana, mês vs mês) e métricas financeiras resumidas (receita total, retirada de artistas se houver, etc.) para dar aos administradores uma visão do desempenho do negócio. Isso complementa o item de analytics com foco específico para decisões administrativas.
5. Adicione gerenciamento de inventário na loja: para produtos físicos, permita admins atualizarem estoque, ver itens esgotando (aba “Estoque baixo”), e receber alertas quando um produto atinge 0. Também inclua um fluxo de cadastro de novos produtos mais completo (upload de múltiplas imagens, especificar peso/dimensões para frete, etc.) no painel admin.
6. Melhore o workflow de aprovação de demos e conteúdo gerado: se deseja que administradores revisem certos conteúdos antes de irem ao ar (por exemplo, talvez demos aprovadas pelos artistas ainda precisam de um “OK” final de um admin), implemente filas de aprovação. Uma aba onde admin pode ver “conteúdos pendentes” (demos, posts de novos usuários, eventos criados) e aprová-los ou rejeitá-los antes de serem públicos.
7. Implemente monitoramento do status da plataforma: um painel no admin que mostra o estado de sistemas integrados – por exemplo, conexão com Supabase OK, uso de CPU/Memory se disponível via API, latência média das funções, filas de emails pendentes, etc. Ainda que simples, isso ajuda o admin a saber se tudo está funcionando ou se há alguma parte do sistema com problemas (ex.: “Webhooks do Stripe: 2 falhas nas últimas 24h”).
```

### Prompt 11: Experiência Mobile e Cross-platform

```
Melhore a experiência em dispositivos móveis e suporte multiplataforma:
1. Otimize o design responsivo para dispositivos móveis: revise todos os principais layouts (feed, perfil, loja, etc.) para garantir que ficam adequados em telas pequenas. Ajuste classes CSS/Tailwind onde necessário para empilhar colunas, esconder menus laterais e usar componentes adaptativos (por exemplo, menu hambúrguer no lugar da navbar completa).
2. Implemente experiência offline para funcionalidades principais: configure um Service Worker (via Workbox ou manualmente) para cachear recursos estáticos e, se possível, cachear dados recentes (posts, produtos) de modo que o usuário possa navegar no conteúdo já visto enquanto offline. Para ações offline (como escrever um post ou comentário sem conexão), armazene em IndexedDB ou localStorage temporariamente e tente enviar assim que a conexão retornar.
3. Adicione suporte a notificações push em mobile/PWA: utilize o Service Worker para receber push notifications mesmo com o app fechado (Web Push API). Assim, usuários móveis que instalarem o PWA receberão notificações de novas mensagens, posts ou eventos direto no device.
4. Implemente sincronização entre dispositivos: se um usuário estiver logado em múltiplos dispositivos (desktop e mobile), assegure que certas ações reflitam instantaneamente em ambos. Por exemplo, se ele lê uma notificação no celular, marque-a como lida no desktop também (isso pode ser resolvido marcando no DB e usando realtime para atualizar outros clients).
5. Crie uma versão PWA (Progressive Web App) do JestFly: adicione um `manifest.json` com nome, ícones e tema, habilite a instalação do app no mobile home screen. Teste no Android e iOS (via Safari) se o PWA funciona bem (full-screen, offline).
6. Adicione gestos e melhorias de usabilidade mobile: por exemplo, permitir swipe para atualizar o feed (pull-to-refresh), deslizar para navegar entre abas ou carrosséis de conteúdo, toque duplo em post para curtir, etc. Esses detalhes deixam a experiência mais natural no touchscreen.
```

### Prompt 12: Recursos de Assinaturas e Receita Recorrente

```
Implemente novos recursos de receita recorrente na plataforma:
1. Crie um sistema de assinaturas para fãs: permita que fãs assinem planos mensais para apoiar a plataforma ou artistas específicos. Configure planos no Stripe (ou use Supabase Payments futuramente) para cobranças recorrentes. No front-end, desenvolva uma página de "Assinatura VIP" onde o usuário escolhe um plano (ex.: Plano Fã Premium) com benefícios descritos, insere pagamento e ativa a assinatura.
2. Integre benefícios de assinatura no app: por exemplo, assinantes podem ter um selo especial ao lado do nome, acesso antecipado a demos exclusivas, descontos na loja ou moedas JestCoin mensais de bônus. Implemente a lógica para verificar assinatura ativa (via webhook ou campo no perfil do usuário) e desbloquear esses benefícios em todas as partes relevantes do app.
3. Implemente entrega avançada de produtos digitais para assinantes: caso existam produtos digitais como pacotes de conteúdo mensal, integre com o sistema de assinatura para entregar automaticamente (ex.: um assinante recebe todo mês um NFT exclusivo ou um pacote de músicas para download). Automatize isso via função agendada no Supabase que dispara quando renova uma assinatura.
4. Adicione integração com múltiplos gateways de pagamento: além do Stripe, ofereça opções como PayPal ou pagamentos locais (PIX/Boleto, se focado no Brasil) para compras únicas e assinaturas. Isso requer integrar SDKs/APIs desses provedores e tratar respostas de confirmação, aumentando as formas de pagamento suportadas.
5. Expanda o programa de afiliados para incluir comissões em assinaturas: se um usuário indica outro que se torna assinante pago, dê ao afiliado uma porcentagem recorrente ou um bônus fixo em JestCoin. Implemente rastreamento e cálculo dessas comissões de forma transparente, com visualização no painel do afiliado (quanto já ganhou de comissões).
6. Implemente sistema de compartilhamento de receita: para casos de colaborações remuneradas, ex.: dois artistas lançam um NFT juntos ou co-criam um produto na loja. Permita definir múltiplos beneficiários em um produto/ativo digital com porcentagens. No momento da venda ou assinatura relacionada, calcule e aloque as porcentagens de receita para cada parte (isso pode significar criar registros separados de ganhos para cada usuário, ou em caso de Stripe Connect, fazer transferência automatizada para contas conectadas dos artistas).
7. Desenvolva relatórios financeiros avançados: no painel admin e para artistas, disponibilize relatórios de receitas detalhadas – incluindo vendas únicas, assinaturas, comissões pagas, etc., por período. Garanta que esses relatórios batem com os registros do Stripe e do banco, facilitando a contabilidade e transparência dos ganhos.
```

### Prompt 13: Otimização de Performance e Escalabilidade

```
Otimize o sistema para alta performance e escalabilidade:
1. Melhore a otimização de mídia: implemente carregamento sob demanda (lazy loading) para imagens e vídeos não visíveis imediatamente (por exemplo, usar atributo loading="lazy" em imagens de NFT e posts). Introduza geração de thumbnails menores para listagens e carregue a imagem de alta resolução somente no modal/visualização detalhada. Utilize compressão adequada e formatos modernos (WebP/AVIF para imagens) para reduzir tamanho.
2. Configure uma CDN para conteúdo estático e mídia: sirva arquivos JavaScript, CSS e imagens através de uma CDN global para reduzir latência para usuários de diferentes regiões. Se usar Supabase Storage para imagens de usuários, ative a distribuição via CDN fornecida pelo Supabase. Verifique se as respostas estão com cabeçalhos de cache corretos (Cache-Control) para que o navegador armazene arquivos que não mudam com frequência.
3. Adicione técnicas avançadas de lazy loading e splitting: divida o código em chunks menores, separando especialmente módulos raramente usados (ex.: administração, streaming) do bundle principal. Utilize `React.lazy` para importar esses componentes somente quando a rota for acessada. Assim, a carga inicial (Largest Contentful Paint) da home e login fica o mais rápida possível. Verifique o build do Vite e considere configurar dynamic import para cada página em `App.tsx`.
4. Otimize o sistema de cache e estado: utilize melhor o React Query para cachear requisições frequentes (ex.: dados do perfil, lista de produtos) evitando chamadas duplicadas. Configure tempos de stale/refresh adequados para equilíbrio entre frescor e desempenho. Considere implementar um cache de nível de aplicação (em memória) para dados estáticos ou raramente mudados, como lista de categorias de produto ou configurações globais.
5. Implemente monitoramento de performance em tempo real: integre uma ferramenta como Google Analytics com métricas de Web Vitals ou um serviço como Sentry Performance para coletar dados de tempo de carregamento, uso de CPU/memória no cliente e frequência de erros. Adicione logs de desempenho nas funções Edge (tempo de execução, event loop delay) e crie alertas se ultrapassar certos limiares. Isso ajudará a detectar gargalos sob carga real.
6. Realize testes de carga e otimize conforme necessário: simule centenas de usuários usando a plataforma simultaneamente (especialmente em áreas críticas como feed, chat e pagamento) e monitore o comportamento do Supabase (conexões, throughput) e do front-end (uso de CPU). Com base nos resultados, otimize consultas (por exemplo, acrescentando paginação onde faltar), considere uso de caches intermediários (como Redis via Supabase Edge Functions para dados repetidos), e ajuste tamanhos de instância ou políticas de escalonamento do Supabase se aplicável.
```

### Prompt 14: Finalização do Marketplace NFT e Integração Blockchain

```
Conclua totalmente o NFT Marketplace com integração blockchain:
1. Implemente contrato inteligente próprio para os NFTs JestFly, se necessário: desenvolva um smart contract (ou use um pré-existente adaptado) que suporte cunhagem por artistas, transferência e aplicação de royalties. Faça deploy na rede escolhida e registre o contrato (endereço, ABI) para interações via front-end.
2. Integre a carteira cripto dos usuários: permita que usuários conectem suas carteiras Web3 (MetaMask, WalletConnect) para interagir com o marketplace descentralizado. Exibir o endereço conectado e saldo de token relevante (por exemplo, ETH ou SOL) no perfil quando conectado. Lidar com conexões/disconexões e solicitar assinatura de transações quando precisam executar uma ação (comprar, listar NFT).
3. Ajuste o fluxo de mint de NFT para ser on-chain: quando um artista criar um NFT, em vez de apenas salvar no Supabase, invoque o contrato inteligente de mint (com os metadados do NFT armazenados no IPFS ou Supabase Storage). Aguarde confirmação da transação e então salve no Supabase o token ID, URL de metadata e endereço on-chain do NFT. Trate erros (transação recusada, etc.) informando o usuário.
4. Atualize o sistema de compra/venda para on-chain: quando um usuário clicar em comprar um NFT, verifique se é um NFT on-chain. Se sim, iniciar o processo de transação via contrato (por exemplo, chamar um método de transferência ou marketplace contract). Para leilões, interaja com o contrato de leilão. Garanta que o front-end mostre feedback durante a espera da confirmação (loading/spinner) e reflete o novo dono após a conclusão.
5. Implemente sincronização de eventos on-chain com a base de dados: para manter o Supabase atualizado, crie um serviço (ou função edge) que escute eventos da blockchain (ex.: Transfer event do contrato ERC721). Quando detectar uma mudança de proprietário ou novo mint via transação externa, atualize as tabelas `nfts` e relacionadas. Isso previne discrepâncias caso transações ocorram fora do controle direto do app (ex.: venda peer-to-peer).
6. Realize testes completos do marketplace integrado: teste cenários de ponta a ponta – criação de NFT (metadados aparecem corretamente, token cunhado de fato), compra direta (saldo do comprador diminui, NFT transfere), leilão (lances registrados, vencedor recebe NFT após fim, perdedores não são cobrados), royalties (ao revender, criador recebe %). Corrija quaisquer bugs de sincronização ou timing que surgirem durante esses testes.
```

### Prompt 15: Integrações Finais e Polimento Completo

```
Finalize todas as integrações e realize o polimento final do aplicativo:
1. Integre e verifique todos os sistemas principais de forma conjunta: teste fluxos completos que atravessam múltiplos módulos (por exemplo: um usuário novo se registra, ganha moedas de boas-vindas, segue um artista, compra um NFT com essas moedas, envia um demo, etc.) garantindo que os módulos (auth, comunidade, loja, NFT, wallet) estão bem integrados e consistentes entre si (IDs corretos, dados sincronizados).
2. Aprimore a UX/UI em toda a plataforma: passe um pente-fino no design – ajuste espaçamentos, alinhe componentes desalinhados, corrija textos truncados em mobile, traduza ou padronize todos os textos (evitar misturar inglês/português). Adicione explicações/tooltips onde funcionalidades complexas possam confundir (por ex.: ícone de info explicando o que é JestCoin, ou como funciona o canvas de carreira).
3. Conduza testes de performance e usabilidade: peça a beta testers para utilizarem o app e cole feedback. Identifique telas lentas e otimize consultas ou carregamento (cache, indices) conforme necessidade. Simplifique quaisquer fluxos muito complicados após observar usuários (p.ex., se acharam difícil achar onde enviar demo, destaque essa função).
4. Corrija todos os bugs e problemas pendentes identificados nos testes: verifique a lista de issues encontradas (ex.: alguma notificação não dispara, um link de navegação quebrado, formulário X não limpa após envio) e resolva cada um, por menor que seja, para entregar um produto polido. Escreva testes automatizados adicionais se pertinente para evitar regressões nesses pontos.
5. Adicione documentação abrangente: atualize o README.md principal para refletir o estado completo do projeto, incluindo instruções de uso, descrição de todas funcionalidades implementadas e talvez um changelog. Crie documentação interna ou wiki para manutenção (detalhando arquitetura, como rodar em dev, como configurar chaves de API, etc.), garantindo que qualquer desenvolvedor futuro ou administrador saiba operar e dar suporte ao sistema.
6. Prepare o aplicativo para lançamento completo: configure ambientes de produção (Supabase prod, chaves Stripe live, domínio próprio para a aplicação). Verifique todos os pontos de configuração (URLs de callback OAuth, configurações de CORS, variáveis de ambiente) para o ambiente live. Realize um último deploy e teste final em produção controlada, marcando todas as funcionalidades como concluídas no README e garantindo que o JestFly está 100% pronto para os usuários finais.
```